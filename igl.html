<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGMSCL</title>
    <title>CGMSCL</title>

    <link rel="icon" type="image/png" href="/static/images/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/static/images/favicon.svg" />
    <link rel="shortcut icon" href="/static/images/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/static/images/apple-touch-icon.png" />
    <link rel="manifest" href="/static/images/site.webmanifest" />
 
    <!-- MathJax configuration -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>

    <!-- MathJax for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Marked.js for Markdown rendering -->
    <script async src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Chart libraries -->
    <script async src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
    <!-- Apache ECharts for all chart types -->
    <script async src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    
    <!-- Tailwind CSS for additional styling -->
    <script async src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM + Babel -->
    <script async src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script async src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script async src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- React Awesome Loaders -->
    <script async src="https://unpkg.com/react-awesome-loaders@1.4.0/dist/react-awesome-loaders.umd.js"></script>
    
    <!-- PocketSphinx.js for offline speech recognition -->
    <script async src="https://cdn.jsdelivr.net/npm/pocketsphinx.js@0.2.0/dist/pocketsphinx.js"></script>

    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');

        /* Remove outer page scrollbar: eliminate body padding and hide overflow */
        html, body {
            height: 100%;
            overflow: hidden;
            scroll-behavior: smooth;
        }

        body {
            background: #ffffff;
            margin: 0;
            padding: 0;
            color: #1f1f1f;
            letter-spacing: -0.01em;
        }

        /* Loading screen styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e0e0e0;
            border-top: 3px solid #1F7246;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #666;
            font-size: 14px;
            font-weight: 500;
        }

        /* Microsoft Copilot Layout */
        .copilot-layout {
            display: flex;
            height: 100vh;
            width: 100%;
            background: #ffffff;
            transition: all 0.3s ease;
        }

        /* CSS Variables for dynamic layout */
        :root {
            --content-padding: 20px;
        }

        /* Header Logo Styles */
        .top-left-logo {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 102;
        }

        .header-logo {
            width: 120px;
            height: auto;
        }



        /* Version Info Styles */
        .version-info {
            padding: 8px 12px;
            text-align: center;
            margin-top: 8px;
        }

        .version-info span {
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        /* AI Disclaimer Styles */
        .ai-disclaimer {
            padding: 12px 20px;
            text-align: center;
            margin-top: 8px;
        }

        .ai-disclaimer p {
            font-size: 12px;
            color: #6b7280;
            margin: 0;
            font-weight: 400;
            line-height: 1.4;
        }



        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            width: 100vw;
            max-width: 100vw;
            margin-left: 0;
            position: relative;
        }

        /* Welcome Screen Styles */
        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Fixed Header Section */
        .welcome-fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            z-index: 50;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-bottom: none;
            box-shadow: none;
            max-height: 250px;
        }

        /* Scrollable Content Section */
        .welcome-scrollable-content {
            flex: 1;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow-y: auto;
            padding: 270px 20px 40px 20px; /* Top padding to account for fixed header */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            margin-top: 0;
        }

        /* Main content scrollbar styling */
        .main-content::-webkit-scrollbar {
            width: 12px;
        }

        .main-content::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 0;
            border-left: 1px solid #e9ecef;
        }

        .main-content::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #1F7246, #2D5016);
            border-radius: 0;
            border-left: 3px solid #f8f9fa;
        }

        .main-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2D5016, #1a3d0e);
            box-shadow: inset -2px 0 4px rgba(31, 114, 70, 0.3);
        }

        .main-content::-webkit-scrollbar-corner {
            background: #f8f9fa;
        }

        .welcome-header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 600px;
        }

        .welcome-title {
            font-size: 2.2rem;
            font-weight: 600;
            color: #1f1f1f;
            margin: 0 0 12px 0;
            line-height: 1.1;
        }

        .welcome-subtitle {
            font-size: 1rem;
            color: #6b7280;
            margin: 0 0 16px 0;
            line-height: 1.4;
            max-width: 600px;
        }

        /* Scrollable content area styles - Hide scrollbar */
        .welcome-scrollable-content {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .welcome-scrollable-content::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Centered Search Container */
        /* Old centered search container styles removed */

        /* Main Prompt Cards */
        .main-prompt-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: min-content;
            gap: 20px;
            width: 100%;
            max-width: 800px;
            margin-bottom: 24px;
            padding: 0;
            align-items: start;
            grid-auto-flow: row;
            align-content: start;
        }

        .prompt-card-main {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s;
            text-align: left;
            height: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .prompt-card-main:hover {
            border-color: #1F7246;
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.1);
            transform: translateY(-2px);
        }

        .card-header-main {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        /* Ensure the dropdown toggle does not overlap or hide text */
        .card-header-main .dropdown-toggle {
            position: relative;
            z-index: 1;
            background: transparent;
            padding: 4px;
            min-width: 24px;
            min-height: 24px;
            border-radius: 4px;
        }
        
        .card-header-main .dropdown-toggle:hover {
            background: rgba(107, 114, 128, 0.05);
        }

        .card-header-main .card-title {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-header-main .card-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .card-header-main .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #1f1f1f;
            margin: 0;
            flex: 1;
            line-height: 1.3;
            min-height: 2.6em; /* Ensure consistent height for 2-line titles */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .prompt-card-main .card-description {
            font-size: 14px;
            color: #6b7280;
            margin: 0 0 12px 0;
            line-height: 1.4;
        }

        .dropdown-content-main {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e5e5;
            animation: slideDown 0.3s ease-out;
            position: relative;
            z-index: 1;
        }

        .dropdown-item-main {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(31, 114, 70, 0.05);
            border-radius: 8px;
            color: #1F7246;
            font-size: 14px;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(31, 114, 70, 0.1);
        }

        .dropdown-item-main:hover {
            background: rgba(31, 114, 70, 0.1);
            border-color: rgba(31, 114, 70, 0.3);
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(31, 114, 70, 0.15);
        }

        .dropdown-item-main:last-child {
            margin-bottom: 0;
        }

        /* Legacy prompt card styles for compatibility */
        .prompt-card {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .prompt-card:hover {
            border-color: #1F7246;
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.1);
            transform: translateY(-2px);
        }

        .prompt-card .card-icon {
            font-size: 24px;
            margin-bottom: 12px;
            display: block;
        }

        .prompt-card .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #1f1f1f;
            margin: 0 0 8px 0;
            line-height: 1.3;
            white-space: normal;
            word-break: keep-all;
            overflow-wrap: break-word;
            hyphens: none;
        }

        .prompt-card .card-description {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            line-height: 1.4;
            white-space: normal;
            word-break: keep-all;
            overflow-wrap: break-word;
            hyphens: none;
        }

        /* See More Button */
        .see-more-container {
            align-self: flex-end;
            margin-top: 16px;
        }

        .see-more-btn {
            background: transparent;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 8px 16px;
            color: #6b7280;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .see-more-btn:hover {
            background: #f3f4f6;
            border-color: #1F7246;
            color: #1F7246;
        }

        /* Extended Prompt Cards */
        .extended-prompt-cards {
            width: 100%;
            max-width: 800px;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e5e5e5;
            transition: all 0.4s ease-in-out;
            overflow: visible;
            height: auto;
            max-height: none;
            transform-origin: top;
            opacity: 1;
        }

        .extended-prompt-cards.hidden {
            opacity: 0;
            transform: translateY(-10px);
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        /* Custom scrollbar styling for extended cards */
        /* Extended cards now flow naturally without internal scrolling */

        /* Hide Sync SharePoint button completely */
        .sync-button,
        .sync-sharepoint-btn,
        .sharepoint-sync,
        [data-sharepoint="sync"],
        .sidebar .sync-button {
            display: none !important;
        }

        /* Remove the circled floating prompt gallery button */
        .prompt-gallery-floating-btn,
        .chat-prompts-fab,
        .floating-prompt-gallery-btn,
        .chat-prompt-gallery-floating,
        [data-floating="gallery-btn"] {
            display: none !important;
        }

        /* Remove suggestions from search container */
        .chat-floating-suggestions,
        .search-suggestions,
        .suggestion-pills-container {
            display: none !important;
        }

        /* Remove gallery button from search container */
        .search-container .prompt-gallery-btn,
        .chat-input-wrapper .gallery-icon,
        .chat-prompt-gallery-btn {
            display: none !important;
        }

        /* Remove front page floating suggestions and prompt gallery */
        .copilot-search-container .floating-suggestions,
        .copilot-search-container .suggestion-pill,
        .copilot-search-container .prompt-gallery-btn {
            display: none !important;
        }

        /* Ensure all dropdown arrows are gray */
        .prompt-card .dropdown-toggle,
        .card .dropdown-toggle,
        .prompt-card .fa-chevron-down,
        .prompt-card .arrow-down,
        .card-dropdown-icon,
        .dropdown-toggle,
        .modal-body .dropdown-toggle {
            color: #6B7280 !important;
            fill: #6B7280 !important;
        }

        /* For SVG icons */
        .prompt-card svg path,
        .card svg path,
        .dropdown-toggle svg path {
            stroke: #6B7280 !important;
            fill: #6B7280 !important;
        }

        /* Microsoft Copilot-style Search Interface - Front Page Only */
        .copilot-search-container {
            position: relative;
            max-width: 700px !important;
            margin: 0 auto !important; /* Center horizontally */
            padding: 0 20px;
            text-align: center; /* Center content within container */
            width: 100%;
        }

        /* When inside fixed header, ensure proper centering */
        .welcome-fixed-header .copilot-search-container {
            left: auto;
            transform: none;
            margin: 0 auto;
            max-width: 600px;
        }

        /* Ensure proper width is maintained on larger screens */
        @media (min-width: 1024px) {
            .copilot-search-container {
                max-width: 700px !important;
                margin: 0 auto !important;
            }
            
            .welcome-fixed-header .copilot-search-container {
                max-width: 600px !important;
            }
        }

        /* Force proper width on desktop screens */
        @media (min-width: 1200px) {
            .copilot-search-container {
                max-width: 700px !important;
                margin: 0 auto !important;
            }
            
            .welcome-fixed-header .copilot-search-container {
                max-width: 650px !important;
            }
        }

        /* Ensure search container is visible and has correct width */
        .copilot-search-container {
            display: block !important;
            visibility: visible !important;
        }

        /* Ensure search box takes full width of container */
        .copilot-search-box {
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 auto; /* Center the search box within container */
            border: none !important;
            box-shadow: none !important;
        }

        /* Top Right Controls */
        .top-right-controls {
            position: absolute;
            top: 20px;
            right: 60px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 1000;
        }


        /* Settings dropdown container */
        .settings-dropdown {
            position: relative;
        }

        /* Settings button */
        .settings-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            color: #374151;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .settings-btn:hover,
        .settings-btn[aria-expanded="true"] {
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #d1d5db;
            color: #1F7246;
        }

        /* Remove shadow box for settings button inside Prompt Gallery header */
        .CGMSCL-prompt-gallery-modal .settings-btn {
            background: transparent !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            padding: 8px !important;
        }
        .CGMSCL-prompt-gallery-modal .settings-btn:hover,
        .CGMSCL-prompt-gallery-modal .settings-btn[aria-expanded="true"] {
            background: transparent !important;
            box-shadow: none !important;
            border-color: transparent !important;
            outline: none !important;
            color: #6B7280 !important;
        }

        /* Settings dropdown menu */
        .settings-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            padding: 8px;
            min-width: 200px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.2s ease;
            z-index: 10000;
        }

        .settings-menu[aria-hidden="false"] {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Settings menu items */
        .settings-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
            color: #374151;
            user-select: none;
        }

        .settings-item:hover {
            background: #f3f4f6;
            color: #1F7246;
        }

        .settings-item i {
            width: 16px;
            font-size: 14px;
            color: #6b7280;
            transition: color 0.15s ease;
        }

        .settings-item:hover i {
            color: #1F7246;
        }

        .settings-item span {
            font-weight: 500;
        }

        /* Override the global hide rule for settings menu add button */
        .settings-menu .settings-item[data-action="add"] {
            display: flex !important;
            visibility: visible !important;
        }
        /* Specific styling for CRUD operations */
        .settings-item[data-action="add"]:hover {
            background: #f0fdf4;
            color: #1F7246;
        }

        .settings-item[data-action="add"]:hover i {
            color: #1F7246;
        }

        .settings-item[data-action="edit"]:hover {
            background: #fff8e1;
            color: #D4AF37;
        }

        .settings-item[data-action="edit"]:hover i {
            color: #D4AF37;
        }

        .settings-item[data-action="delete"]:hover {
            background: #fef2f2;
            color: #1F7246
;
        }

        .settings-item[data-action="delete"]:hover i {
            color: #1F7246
;
        }

        /* Separator between option groups */
        .settings-separator {
            height: 1px;
            background: #e5e7eb;
            margin: 4px 0;
        }

        /* Focus styles */
        .settings-item:focus {
            outline: 2px solid #1F7246;
            outline-offset: -2px;
            background: #f0fdf4;
        }

        /* Screen reader support */
        .settings-item[aria-selected="true"] {
            background: #f0fdf4;
            color: #1F7246;
        }

        .settings-btn:focus {
            outline: none;
            outline-offset: 0;
        }

        /* New Chat Button */
        /* Excel Download Button */
        .excel-download-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 40px;
            min-height: 40px;
        }

        .excel-download-btn:hover {
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }

        .excel-download-btn:focus {
            outline: 2px solid #1F7246;
            outline-offset: 2px;
        }

        .excel-download-btn svg {
            width: 20px;
            height: 20px;
        }

        .new-chat-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #374151;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 40px;
            min-height: 40px;
        }

        .new-chat-btn:hover {
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #1F7246;
            color: #1F7246;
        }

        .new-chat-btn:focus {
            outline: 2px solid #1F7246;
            outline-offset: 2px;
        }

        .new-chat-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Session Info Display */
        .session-info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            color: #6b7280;
            backdrop-filter: blur(10px);
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .session-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .session-limit {
            font-weight: 500;
            color: #374151;
        }

        .session-limit-caution {
            color: #f59e0b !important;
        }

        .session-limit-warning {
            color: #1F7246 !important;
            font-weight: 600;
        }

        .session-id {
            font-family: monospace;
            font-size: 10px;
            opacity: 0.7;
        }

        .floating-suggestions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .suggestion-pill {
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
            animation: fadeInUp 0.5s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        .suggestion-pill:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .suggestion-pill:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .prompt-gallery-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #1F7246;
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            font-size: 16px;
            animation: fadeInUp 0.5s ease-out;
        }

        .prompt-gallery-btn:hover {
            background: #2D5016;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(31, 114, 70, 0.3);
        }

        .prompt-gallery-btn:active {
            transform: scale(0.95);
        }

        /* Container adjustments */
        .copilot-search-box,
        .search-container,
        .input-wrapper,
        .input-container {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            padding: 18px 20px; /* Increased from 12px 16px to 18px 20px for more height and width */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            animation: fadeInUp 0.6s ease-out 0.5s both;
            gap: 8px;
        }

        .copilot-search-box:focus-within {
            border-color: #1F7246;
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.15);
        }

        /* Search input styling */
        .copilot-search-box input,
        .search-input,
        input[placeholder*="message"],
        input[placeholder*="email"] {
            flex: 1;
            border: none;
            outline: none;
            font-size: 18px; /* Increased from 16px to 18px for better visibility */
            padding: 0 12px;
            background: transparent;
            color: #374151;
            border-radius: 24px;
        }

        .copilot-search-box input::placeholder,
        .search-input::placeholder,
        input[placeholder*="message"]::placeholder,
        input[placeholder*="email"]::placeholder {
            color: #9ca3af;
        }

        .copilot-search-box input:focus,
        .search-input:focus,
        input[placeholder*="message"]:focus {
            outline: none;
            border: none;
        }

        .add-attachment-btn,
        .mic-btn,
        .send-btn {
            width: 36px; /* Increased from 32px to 36px */
            height: 36px; /* Increased from 32px to 36px */
            border-radius: 50%;
            border: none;
            margin-left: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px; /* Increased from 14px to 16px */
        }

        /* Hide all variations of the plus/add button */
        .add-attachment-btn,
        .plus-button,
        .attachment-button,
        .btn-add,
        .btn-plus,
        .icon-add,
        .icon-plus,
        .fa-plus,
        button[class="add"],
        button[class*="plus"],
        [data-action="add"],
        [data-action="attachment"] {
            display: none !important;
            visibility: hidden !important;
        }

        /* Mic button styling */
        .mic-btn,
        .mic-button,
        .btn-mic,
        .button-mic,
        [class*="mic"] {
            background: #1F7246;
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
        }

        .mic-btn:hover,
        .btn-mic:hover,
        [class*="mic"]:hover {
            background: #2D5016;
            transform: scale(1.05);
        }

        /* Mic button recording state */
        .mic-btn.recording,
        [class*="mic"].recording {
            background: #059669 !important;
            animation: pulse 1s infinite;
        }

        /* Pulse animation for mic button */
        @keyframes pulse {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 0 0 rgba(5, 150, 105, 0.7); 
            }
            70% { 
                transform: scale(1.05); 
                box-shadow: 0 0 0 10px rgba(5, 150, 105, 0); 
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 0 rgba(5, 150, 105, 0); 
            }
        }

        /* Send button styling */
        .send-btn,
        .send-button,
        .btn-send,
        .button-send,
        [class*="send"] {
            background: #1F7246;
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
        }

        .send-btn:hover,
        .btn-send:hover,
        [class*="send"]:hover {
            background: #2D5016;
            transform: scale(1.05);
        }

        .send-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        /* Enhanced Chat Container Search Interface */
        .chat-search-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            z-index: 100;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }

        /* Add padding to chat area to accommodate floating suggestions */
        .chat-area {
            padding-bottom: 0;
        }

        .chat-floating-suggestions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: flex-start;
        }

        .chat-floating-suggestions .suggestion-pill {
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 13px;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
            animation: fadeInUp 0.5s ease-out;
        }

        .chat-floating-suggestions .suggestion-pill:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chat-floating-suggestions .suggestion-pill:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .chat-prompt-gallery-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #1F7246;
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            font-size: 14px;
            animation: fadeInUp 0.5s ease-out;
        }

        .chat-prompt-gallery-btn:hover {
            background: #2D5016;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(31, 114, 70, 0.3);
        }

        .chat-prompt-gallery-btn:active {
            transform: scale(0.95);
        }

        /* Microsoft Copilot Style Chat Search Container */
        .chat-search-container {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 90%;
            height: 74px;
            background: #ffffff;
            border: 1px solid #e1e5e9;
            border-radius: 37px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            padding: 0 20px;
            margin: 0 auto;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chat-search-container:focus-within {
            border-color: #1F7246;
            box-shadow: 0 0 0 2px rgba(31, 114, 70, 0.2);
        }

        .chat-search-container:hover {
            border-color: #c7c7c7;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        /* Input field with Copilot-style placeholder and sizing */
        .chat-search-input {
            flex: 1;
            height: 70px;
            border: none;
            outline: none;
            background: transparent;
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #323130;
            padding: 0 12px 0 0;
            line-height: 1.4;
            overflow: hidden;
            resize: none;
            display: flex;
            align-items: center;
        }

        .chat-search-input::placeholder {
            color: #605e5c;
            font-size: 16px;
            opacity: 0.8;
        }

        .chat-search-input:focus {
            outline: none;
        }

        /* Mic and Send buttons integrated on the right */
        .chat-button {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: #1F7246;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            transition: all 0.2s ease;
            color: #ffffff;
            font-size: 18px;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(31, 114, 70, 0.2);
        }

        .chat-button:hover {
            background: #2D5016;
            color: #ffffff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(31, 114, 70, 0.3);
        }

        .chat-button:active {
            background: #1a3d0e;
            transform: scale(0.95);
        }

        .chat-button.mic-button {
            color: #ffffff;
            background: #1F7246;
        }

        .chat-button.mic-button:hover {
            background: #2D5016;
            color: #ffffff;
        }

        .chat-button.tts-button {
            color: #ffffff;
            background: #059669;
        }

        .chat-button.tts-button:hover {
            background: #047857;
            color: #ffffff;
        }

        .chat-button.tts-button.playing {
            background: #10b981;
            animation: pulse 1s infinite;
        }

        .chat-button.send-button {
            color: #ffffff;
            background: #1F7246;
        }

        .chat-button.send-button:hover {
            background: #2D5016;
            color: #ffffff;
        }

        .chat-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #1F7246;
        }

        .chat-button:disabled:hover {
            background: #1F7246;
            transform: none;
        }

        /* Legacy chat input wrapper - keep for compatibility */
        .chat-input-wrapper {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            padding: 8px 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .chat-input-wrapper:focus-within {
            border-color: #d1d5db;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Remove red focus highlight from search input */
        .chat-input,
        .search-input,
        input[type="text"]:focus,
        textarea:focus {
            outline: none !important;
            border-color: #e5e7eb !important; /* Neutral gray instead of red */
            box-shadow: 0 0 0 1px rgba(229, 231, 235, 0.5) !important;
        }

        /* Optional: Add subtle focus styling */
        .chat-input:focus,
        .input-textarea:focus {
            border-color: #d1d5db;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Floating Suggestions and Gallery Button Above Search Box */
        .floating-suggestions-container {
            position: fixed;
            bottom: 90px; /* Above the fixed input container */
            left: 0;
            right: 0;
            z-index: 1000;
            pointer-events: none; /* Allow clicks to pass through container */
            display: flex;
            justify-content: center;
            padding: 0 1rem;
        }

        .floating-suggestions-wrapper {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* Enable clicks on buttons */
            min-height: 60px;
            padding: 12px 0;
        }

        .floating-suggestion-pill {
            background: rgba(243, 244, 246, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(229, 231, 235, 0.8);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-weight: 500;
            animation: fadeInUp 0.5s ease-out;
        }

        .floating-suggestion-pill:hover {
            background: rgba(229, 231, 235, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .floating-suggestion-pill:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .floating-gallery-btn {
            width: 40px;
            height: 40px;
            border-radius: 20px;
            background: rgba(31, 114, 70, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 16px;
            animation: fadeInUp 0.5s ease-out;
            margin-left: 4px;
        }

        .floating-gallery-btn:hover {
            background: rgba(45, 80, 22, 0.95);
            transform: translateY(-1px) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .floating-gallery-btn:active {
            transform: translateY(0) scale(0.95);
        }

        .extended-cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: auto;
            gap: 1rem;
            margin-bottom: 24px;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            align-items: start;
            transition: all 0.3s ease;
        }

        .prompt-card-extended {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s;
            text-align: left;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            position: relative;
            align-self: start;
        }

        .prompt-card-extended:hover {
            border-color: #1F7246;
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.1);
            transform: translateY(-2px);
        }

        /* Hide Coming Soon placeholder cards */
        .placeholder-card,
        .prompt-card-extended.placeholder-card,
        .card[data-status="coming-soon"],
        .prompt-card.coming-soon {
            display: none !important;
        }
        /* Hide cards with "Coming Soon" in their title */
        .prompt-card-extended:has(.card-title:contains("Coming Soon")),
        .prompt-card:has(.card-title:contains("Coming Soon")) {
            display: none !important;
        }

        /* Placeholder card styling (for any remaining placeholders) */
        .placeholder-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px dashed #dee2e6;
            opacity: 0.6;
            pointer-events: none;
            cursor: default;
        }

        .placeholder-card:hover {
            transform: none;
            box-shadow: none;
            border-color: #dee2e6;
        }

        .placeholder-card .card-icon {
            color: #6c757d;
        }

        .placeholder-card .card-title {
            color: #6c757d;
        }

        .placeholder-card .card-description {
            color: #6c757d;
        }

        .card-header-extended {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .card-header-extended .card-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .card-header-extended .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #1f1f1f;
            margin: 0;
            flex: 1;
            line-height: 1.3;
        }

        /* Dropdown toggle button for extended cards */
        .prompt-card-extended .dropdown-toggle {
            position: relative;
            top: auto;
            right: auto;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            color: #6b7280;
            font-size: 14px;
            z-index: 10;
            margin-left: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
            min-height: 24px;
        }

        .prompt-card-extended .dropdown-toggle:hover {
            background: rgba(107, 114, 128, 0.05);
            color: #374151;
        }

        /* Arrow icons are now handled by changing fa-chevron-down to fa-chevron-up in JavaScript */

        .prompt-card-extended .dropdown-toggle i {
            transition: transform 0.2s ease;
        }

        /* Card description for extended cards */
        .prompt-card-extended .card-description {
            color: #6b7280;
            font-size: 14px;
            line-height: 1.5;
            margin: 0 0 16px 0;
            padding-right: 0; /* Remove extra padding since button is no longer absolute */
        }

        /* Expandable content for extended cards */
        .prompt-card-extended .card-expanded-content {
            max-height: 0;
            overflow: hidden;
            background: #fef2f2;
            border-radius: 8px;
            margin-top: 12px;
            transition: max-height 0.3s cubic-bezier(0.4,0,0.2,1);
        }

        .prompt-card-extended .card-expanded-content.expanded {
            max-height: 400px;
            padding: 16px;
            transition: max-height 0.3s cubic-bezier(0.4,0,0.2,1);
        }

        /* Prompt options for extended cards */
        .prompt-card-extended .prompt-option {
            padding: 9px 14px;
            font-size: 15px;
            color: #2D5016;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #D4AF37;
            margin-bottom: 8px;
            cursor: pointer;
            transition: border 0.2s, background 0.15s;
        }

        .prompt-card-extended .prompt-option:hover {
            border: 1.5px solid #1F7246;
            background: #f0fdf4;
        }

        .prompt-card-extended .prompt-option:last-child {
            margin-bottom: 0;
        }

        .dropdown-toggle {
            background: rgba(107, 114, 128, 0.1);
            color: #6B7280;
            border: none;
            border-radius: 6px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            min-height: 28px;
        }

        .dropdown-toggle:hover {
            background: rgba(107, 114, 128, 0.2);
            transform: scale(1.05);
        }

        /* Arrow rotation now handled by icon class changes in JavaScript */

        /* Non-intrusive search highlight that doesn't shift layout */
        .search-highlight {
            background: linear-gradient(transparent 60%, #fef3c7 60%);
            color: inherit;
            border-radius: 2px;
            padding: 0 0.5px; /* tiny padding to avoid text collision without wrapping */
            display: inline;
            line-height: inherit;
            box-decoration-break: clone; /* prevent awkward breaks when wrapping */
        }

        .dropdown-content-extended {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e5e5;
            animation: slideDown 0.3s ease-out;
        }

        .dropdown-item-extended {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(31, 114, 70, 0.05);
            border-radius: 8px;
            color: #1F7246;
            font-size: 14px;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(31, 114, 70, 0.1);
        }

        .dropdown-item-extended:hover {
            background: rgba(31, 114, 70, 0.1);
            border-color: rgba(31, 114, 70, 0.3);
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(31, 114, 70, 0.15);
        }

        .dropdown-item-extended:last-child {
            margin-bottom: 0;
        }

        @keyframes slideDown {
            from {
            opacity: 0;
                max-height: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                max-height: 300px;
                transform: translateY(0);
            }
        }

        /* Chat Area Styles */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: white;
            position: relative;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 120px; /* Space for fixed input area */
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Bottom Input Container */
        .bottom-input-container {
            border-top: 1px solid #e5e5e5;
            background: white;
            padding: 16px 20px;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            padding: 4px;
            transition: border-color 0.2s;
        }

        .input-wrapper:focus-within {
            border-color: #1F7246;
            box-shadow: 0 2px 8px rgba(31, 114, 70, 0.1);
        }

        .input-textarea {
            flex: 1;
            border: none;
            outline: none;
            padding: 12px 16px;
            font-size: 16px;
            background: transparent;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            line-height: 1.5;
            color: #1f1f1f;
        }

        .input-textarea::placeholder {
            color: #9ca3af;
        }

        .send-button,
        .mic-button {
            background: #1F7246;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
        }

        .send-button:hover,
        .mic-button:hover {
            background: #2D5016;
        }

        .send-button.processing {
            background: #6b7280;
        }

        .mic-button.recording {
            background: #ef4444;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Chat Prompts Button */
        .chat-prompts-button {
            background: #1F7246;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
        }

        .chat-prompts-button:hover {
            background: #2D5016;
        }

        .chat-prompts-button .w-5 {
            width: 20px;
            height: 20px;
        }

        /* Floating Prompt Gallery Button */
        .prompt-gallery-floating-btn {
            position: fixed;
            bottom: 120px; /* Above the mic button with space */
            right: 20px; /* Aligned with mic button */
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #1F7246;
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            font-size: 0;
            animation: floating-pulse 3s ease-in-out infinite;
        }

        .prompt-gallery-floating-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            background: #2D5016;
            animation: none;
        }

        .prompt-gallery-floating-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .prompt-gallery-floating-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Focus styles for accessibility */
        .prompt-gallery-floating-btn:focus {
            outline: 2px solid #1F7246;
            outline-offset: 2px;
        }

        .prompt-gallery-floating-btn:focus:not(:focus-visible) {
            outline: none;
        }

        /* Subtle pulse animation */
        @keyframes floating-pulse {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }
            50% {
                box-shadow: 0 4px 12px rgba(31, 114, 70, 0.3);
            }
        }


        /* Responsive Design for Floating Button */
        @media (max-width: 768px) {
            .prompt-gallery-floating-btn {
                bottom: 130px; /* Above mic button with space */
                right: 20px; /* Aligned with mic button */
                width: 48px;
                height: 48px;
            }
        }

        @media (max-width: 480px) {
            .prompt-gallery-floating-btn {
                bottom: 135px; /* Above mic button with space */
                right: 16px; /* Aligned with mic button */
                width: 44px;
                height: 44px;
            }

            .prompt-gallery-floating-btn svg {
                width: 18px;
                height: 18px;
            }

            /* Copilot search responsive design */
            .copilot-search-container {
                padding: 0 16px;
                margin: 0 auto !important;
                max-width: 95%; /* Ensure it fits on mobile */
                text-align: center;
            }
            
            .welcome-fixed-header .copilot-search-container {
                max-width: 90%;
                padding: 0 12px;
            }

            .copilot-search-box {
                padding: 16px 18px; /* Maintain larger size on mobile */
            }

            .copilot-search-box input {
                font-size: 17px; /* Slightly smaller but still larger than original */
            }

            .add-attachment-btn,
            .mic-btn,
            .send-btn {
                width: 34px; /* Slightly smaller on mobile */
                height: 34px;
                font-size: 15px;
            }

            /* Chat container responsive design */
            .chat-floating-suggestions {
                flex-direction: column;
                align-items: stretch;
                gap: 6px;
            }
            
            .chat-floating-suggestions .suggestion-pill {
                text-align: center;
                margin-bottom: 4px;
                width: 100%;
                max-width: 300px;
                margin-left: auto;
                margin-right: auto;
            }
            
            .chat-prompt-gallery-btn {
                align-self: center;
                margin: 8px 0 0 0;
            }

            .chat-search-container {
                padding: 0.75rem;
            }

            /* Mobile adjustments for top controls */
            .top-right-controls {
                top: 16px;
                right: 50px;
                gap: 8px;
            }
            
            .settings-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }
            
            .settings-menu {
                min-width: 180px;
                right: -8px;
            }
            
            .settings-item {
                padding: 10px 14px;
                font-size: 13px;
            }

            /* Excel Download Button mobile adjustments */
            .excel-download-btn {
                min-width: 36px;
                min-height: 36px;
                padding: 6px 10px;
            }
            
            .excel-download-btn svg {
                width: 18px;
                height: 18px;
            }

            /* New Chat Button mobile adjustments */
            .new-chat-btn {
                min-width: 36px;
                min-height: 36px;
                padding: 6px 10px;
            }
            
            .new-chat-btn svg {
                width: 18px;
                height: 18px;
            }

            .chat-input-wrapper {
                padding: 6px 10px;
            }

            /* Responsive adjustments for Copilot-style search */
            .chat-search-container {
                max-width: 100%;
                height: 56px;
                padding: 0 16px;
            }
            
            .chat-search-input {
                height: 52px;
                line-height: 52px;
                font-size: 16px; /* Prevent zoom on iOS */
            }
            
            .chat-button {
                width: 44px;
                height: 44px;
                margin-left: 6px;
                background: #1F7246;
                color: #ffffff;
            }
            
            .chat-button svg {
                width: 14px;
                height: 14px;
            }
        }

        @media (max-width: 480px) {
            .chat-search-container {
                max-width: 100%;
                height: 52px;
                padding: 0 12px;
            }
            
            .chat-search-input {
                height: 48px;
                line-height: 48px;
                font-size: 16px;
                padding: 0 8px 0 0;
            }
            
            .chat-button {
                width: 40px;
                height: 40px;
                background: #1F7246;
                color: #ffffff;
            }

            /* Floating elements responsive design */
            .floating-suggestions-container {
                margin-bottom: 12px;
            }
            
            .floating-suggestions-wrapper {
                flex-direction: column;
                align-items: stretch;
            }
            
            .floating-suggestion-pill {
                text-align: center;
                margin-bottom: 8px;
            }
            
            .floating-gallery-btn {
                align-self: center;
            }
        }

        @media (min-width: 1200px) {
            .prompt-gallery-floating-btn {
                bottom: 125px; /* Above mic button with space */
                right: 20px; /* Aligned with mic button */
                width: 52px;
                height: 52px;
            }

            .prompt-gallery-floating-btn svg {
                width: 22px;
                height: 22px;
            }
        }

        /* Hide floating button when sidebar is open on mobile */
        @media (max-width: 899px) {
            .sidebar.open ~ .prompt-gallery-floating-btn {
                opacity: 0.5;
                pointer-events: none;
            }
        }

        /* Show button only in chat area */
        .chat-area .prompt-gallery-floating-btn {
            display: flex;
        }

        /* Hide button on welcome screen */
        .welcome-screen ~ .prompt-gallery-floating-btn {
            display: none;
        }

        /* Show button when chat area is visible */
        .chat-area[style*="display: block"] ~ .prompt-gallery-floating-btn,
        .chat-area:not([style*="display: none"]) ~ .prompt-gallery-floating-btn {
            display: flex;
        }

        /* Responsive Design */
        /* Tablet responsive design for extended cards */
        @media (max-width: 1199px) and (min-width: 768px) {
            .extended-cards-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-auto-rows: max-content;
                gap: 1rem;
                align-items: start;
            }
            
            /* Extended cards now flow naturally without height restrictions */
        }

        @media (max-width: 768px) {
            /* Adjust main content for mobile */
            .main-content {
                margin-left: 0;
                width: 100vw;
                max-width: 100vw;
            }

            /* Adjust fixed elements for mobile */
            .chat-search-container {
                left: 0;
            }

            .floating-suggestions-container {
                left: 0;
            }

            .welcome-fixed-header {
                left: 0;
                padding: 16px;
                max-height: 220px;
            }

            .top-left-logo {
                left: 16px;
            }

            .header-logo {
                width: 100px;
            }

            .welcome-title {
                font-size: 1.8rem;
            }

            .welcome-subtitle {
                font-size: 0.9rem;
            }

            .welcome-scrollable-content {
                padding: 230px 16px 40px 16px; /* Less top padding on mobile */
            }



            .main-content {
                width: 100vw;
                max-width: 100vw;
                margin-left: 0;
            }

            .welcome-title {
                font-size: 2rem;
            }

            .welcome-header {
                margin-top: 50px;
            }

            .welcome-subtitle {
                font-size: 1rem;
            }

            .main-prompt-cards {
                grid-template-columns: 1fr;
                gap: 16px;
                max-width: 100%;
            }

            /* Old centered search container responsive styles removed */

            .chat-messages {
                padding: 16px;
            }

            .bottom-input-container {
                padding: 12px 16px;
            }

            .extended-cards-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-auto-rows: max-content;
                gap: 14px;
                align-items: start;
            }
        }

        @media (max-width: 480px) {
            .welcome-screen {
                padding: 20px 16px;
            }

            .welcome-header {
                margin-top: 40px;
            }

            .welcome-title {
                font-size: 1.75rem;
            }

            /* Very small screens - Excel Download Button */
            .excel-download-btn {
                min-width: 32px;
                min-height: 32px;
                padding: 6px 8px;
            }
            
            .excel-download-btn svg {
                width: 16px;
                height: 16px;
            }

            /* Very small screens - New Chat Button */
            .new-chat-btn {
                min-width: 32px;
                min-height: 32px;
                padding: 6px 8px;
            }
            
            .new-chat-btn svg {
                width: 16px;
                height: 16px;
            }

            .welcome-subtitle {
                font-size: 0.95rem;
            }

            .prompt-card {
                padding: 16px;
            }

            .prompt-card .card-title {
                font-size: 15px;
            }

            .prompt-card .card-description {
                font-size: 13px;
            }

            .extended-cards-grid {
                grid-template-columns: 1fr;
                grid-auto-rows: max-content;
                gap: 12px;
                align-items: start;
            }

            /* Hide placeholder cards on mobile */
            .placeholder-card {
                display: none;
            }
            
            /* Extended cards now flow naturally without height restrictions */

            .prompt-card-extended {
                padding: 16px;
            }

            .card-header-extended .card-title {
                font-size: 15px;
            }

            .dropdown-item-extended {
                font-size: 13px;
                padding: 8px 10px;
            }

            .prompt-card-main {
                padding: 16px;
            }

            .card-header-main .card-title {
                font-size: 15px;
            }

            .dropdown-item-main {
                font-size: 13px;
                padding: 8px 10px;
            }
        }



        /* Legacy styles - keeping for compatibility */

        /* Gallery Backdrop */
        .gallery-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            backdrop-filter: blur(4px);
            display: none;
        }
        /* CGMSCL Prompt Gallery Modal */
        .CGMSCL-prompt-gallery-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            max-width: 900px;
            max-height: 90vh;
            background: #f9fafb;
            z-index: 2000;
            overflow-y: auto;
            font-family: 'Segoe UI', system-ui, sans-serif;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: none;
            opacity: 0;
            transition: all 0.3s ease-in-out;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .CGMSCL-prompt-gallery-modal.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Reset any browser defaults or inherited margins */
        .CGMSCL-prompt-gallery-modal * {
            box-sizing: border-box;
        }

        /* Remove any potential scrollbar spacing issues */
        .CGMSCL-prompt-gallery-modal {
            overflow-x: hidden;
        }

        .CGMSCL-prompt-gallery-modal[open] {
            display: block;
        }

        .CGMSCL-prompt-gallery-modal::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(6px);
        }

        /* Gallery Header */
        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            margin: 0;
            width: 100%;
            box-sizing: border-box;
        }

        .gallery-header h2 {
            color: #1f2937;
            font-size: 24px;
            font-weight: 600;
            margin: 0;
        }

        .header-controls {
            display: flex;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #f3f4f6;
            color: #1F7246;
        }

        /* Settings Dropdown */
        .header-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }

        .settings-dropdown {
            position: relative;
            display: inline-block;
        }

        .settings-btn {
            background: none;
            border: none;
            font-size: 18px;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }

        .settings-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .settings-btn.active {
            color: #1F7246;
            background: #f0fdf4;
        }

        .settings-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 2001;
            min-width: 120px;
            overflow: hidden;
            margin-top: 4px;
        }

        .settings-dropdown-menu.show {
            display: block;
            animation: dropdownFadeIn 0.2s ease-in-out;
        }

        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dropdown-option {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f3f4f6;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .dropdown-option:hover {
            background: #f9fafb;
            color: #1F7246;
        }

        .dropdown-option i {
            margin-right: 8px;
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        /* Specific colors for each option */
        .dropdown-option:nth-child(1):hover { /* Add */
            background: #f0f9ff;
            color: #0ea5e9;
        }

        .dropdown-option:nth-child(2):hover { /* Edit */
            background: #fffbeb;
            color: #f59e0b;
        }

        .dropdown-option:nth-child(3):hover { /* Delete */
            background: #fef2f2;
            color: #ef4444;
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90vw;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
        }

        .modal-header h3 {
            margin: 0;
            color: #111827;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            color: #1F7246 !important;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #1F7246;
            box-shadow: 0 0 0 3px rgba(31, 114, 70, 0.1);
        }

        .form-group small {
            display: block;
            margin-top: 4px;
            color: #6b7280;
            font-size: 12px;
            line-height: 1.4;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .form-actions button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .form-actions button[type="button"] {
            background: #f3f4f6;
            color: #374151;
        }

        .form-actions button[type="button"]:hover {
            background: #e5e7eb;
        }

        .form-actions button[type="submit"] {
            background: #1F7246;
            color: white;
        }

        .form-actions button[type="submit"]:hover {
            background: #2D5016;
        }

        /* Edit/Delete mode styles */
        .prompt-card.edit-mode {
            border: 2px dashed #1F7246;
        }
        
        .prompt-card.delete-mode {
            border: 2px dashed #1F7246
;
            cursor: pointer;
        }

        .prompt-card.edit-mode:hover {
            background: #fffbeb;
        }

        .prompt-card.delete-mode:hover {
            background: #fef2f2;
        }

        .cancel-edit-btn,
        .cancel-delete-btn {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 8px;
        }

        .cancel-edit-btn:hover,
        .cancel-delete-btn:hover {
            background: #d97706;
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 4000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-success {
            background: #10b981;
        }

        .notification-warning {
            background: #f59e0b;
        }

        .notification-info {
            background: #3b82f6;
        }

        /* Internal Prompts Modal */
        .internal-prompts-modal {
            border: none;
            border-radius: 12px;
            padding: 0;
            max-width: 500px;
            width: 90vw;
            max-height: 80vh;
            overflow: hidden;
        }

        .internal-prompts-modal::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .modal-info {
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
        }

        .internal-prompts-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .internal-prompt-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .internal-prompt-item:hover {
            background: #f3f4f6;
            border-color: #1F7246
;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(31, 114, 70, 0.1);
        }

        .internal-prompt-text {
            flex: 1;
            font-size: 14px;
            color: #374151;
        }

        .internal-prompt-delete {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .internal-prompt-delete:hover {
            color: #1F7246
;
            background: #fef2f2;
        }

        .add-prompt-section {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .add-prompt-section input {
            flex: 1;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
        }

        .add-prompt-section input:focus {
            outline: none;
            border-color: #1F7246
;
            box-shadow: 0 0 0 3px rgba(31, 114, 70, 0.1);
        }

        .add-prompt-section button {
            padding: 12px 20px;
            background: #1F7246
;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-prompt-section button:hover {
            background: #2D5016;
        }

        .add-prompt-section button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .prompt-counter {
            text-align: center;
            color: #6b7280;
            font-size: 12px;
        }

        /* Gallery Search Section */
        .gallery-search-section {
            padding: 16px 24px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            width: 100%;
            margin: 0;
            box-sizing: border-box;
        }

        .search-container {
            max-width: 100%;
            margin: 0;
            width: 100%;
            padding: 0;
            box-sizing: border-box;
        }

        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            transition: all 0.2s ease;
            width: 100%;
            max-width: none;
        }

        .search-input-wrapper:focus-within {
            border-color: #1F7246
;
            box-shadow: 0 0 0 1px rgba(31, 114, 70, 0.1);
            background: white;
        }

        .search-icon {
            color: #9ca3af;
            margin-right: 8px;
            font-size: 14px;
        }

        .prompt-search-input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            color: #374151;
            transition: all 0.2s ease;
        }

        .prompt-search-input:focus {
            font-size: 15px;
        }

        .prompt-search-input::placeholder {
            color: #9ca3af;
        }

        .clear-search-btn {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            margin-left: 8px;
            transition: all 0.2s ease;
        }

        .clear-search-btn:hover {
            color: #1F7246
;
            background: #fef2f2;
        }

        /* Prompts Grid */
        .prompts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: auto;
            gap: 16px;
            padding: 24px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            align-items: start;
        }

        /* Add transitions for search animations */
        .prompt-card {
            transition: opacity 0.3s ease, transform 0.3s ease, display 0.3s ease;
        }

        /* Search input enhancements */
        .prompt-search-input:focus {
            font-size: 15px;
            outline: none;
            border-color: #1F7246
;
            box-shadow: 0 0 0 2px rgba(31, 114, 70, 0.1);
        }

        /* Search results counter */
        .search-results-counter {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
            text-align: center;
        }

        /* Enhanced clear button */
        .clear-search-btn {
            transition: all 0.2s ease;
        }

        .clear-search-btn:hover {
            transform: scale(1.1);
            color: #1F7246
;
        }

        /* Ensure all cards have uniform grid positioning and dimensions */
        .prompt-card:nth-child(1),
        .prompt-card:nth-child(2),
        .prompt-card:nth-child(3),
        .prompt-card:nth-child(4),
        .prompt-card:nth-child(5),
        .prompt-card:nth-child(6),
        .prompt-card:nth-child(7),
        .prompt-card:nth-child(8),
        .prompt-card:nth-child(9),
        .prompt-card:nth-child(10) {
            grid-column: span 1 !important;
            grid-row: span 1 !important;
            min-height: 180px !important;
            height: auto !important;
            padding: 20px !important;
            box-sizing: border-box !important;
            width: 100% !important;
        }

        .prompt-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            min-height: 180px;
            width: 100%;
            height: auto;
            box-sizing: border-box;
            align-self: start;
        }

        .prompt-card:hover {
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.1);
            border-color: #1F7246
;
            transform: translateY(-2px);
        }
        
        /* Ensure hover effects apply to all cards equally */
        .prompt-card:nth-child(10):hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.1) !important;
            border-color: #1F7246
 !important;
        }
        
        /* Force identical layout for all cards - final override */
        .prompts-grid > .prompt-card {
            display: flex !important;
            flex-direction: column !important;
            width: 100% !important;
            height: auto !important;
            min-height: 180px !important;
            padding: 20px !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            align-self: stretch !important;
            justify-self: stretch !important;
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            position: relative;
            padding-right: 40px; /* Space for dropdown button */
        }

        .card-icon {
            width: 40px;
            height: 40px;
            background: #1F7246
;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            margin-right: 12px;
        }

        .card-title {
            font-weight: 600;
            font-size: 16px;
            color: #1f2937;
            margin: 0;
            margin-right: 40px; /* Prevent overlap with dropdown */
        }

        .card-description {
            font-size: 14px;
            color: #6b7280;
            line-height: 1.4;
            flex-grow: 1;
            margin-bottom: 16px;
        }

        .card-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: auto;
        }

        .card-actions {
            display: flex;
            gap: 8px;
        }

        /* Action buttons container */
        .message .message-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding: 8px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            justify-content: flex-end;
        }

        /* Base action button styles */
        .message .action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .message .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .message .action-btn:active {
            transform: translateY(0);
        }

        /* Copy button specific styles */
        .message .copy-btn {
            background: linear-gradient(135deg, #1F7246
, #EF4444);
            color: white;
            border: 1px solid #1F7246;
        }

        /* Excel download button specific styles */
        .message .excel-download-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            color: inherit;
        }

        .message .excel-download-btn:hover {
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }

        .message .excel-download-btn img {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }

        .message .copy-btn:hover {
            background: linear-gradient(135deg, #2D5016, #1F7246
);
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.3);
        }

        .message .copy-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Thumbs up button styles */
        .message .thumbs-up-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.8);
            color: #374151;
        }

        .message .thumbs-up-btn:hover {
            background: rgba(34, 197, 94, 0.9);
            border-color: rgba(34, 197, 94, 1);
            color: white;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .message .thumbs-up-btn.active {
            background: rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 1);
            color: white;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
        }

        /* Thumbs down button styles */
        .message .thumbs-down-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.8);
            color: #374151;
        }

        .message .thumbs-down-btn:hover {
            background: rgba(239, 68, 68, 0.9);
            border-color: rgba(239, 68, 68, 1);
            color: white;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .message .thumbs-down-btn.active {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(239, 68, 68, 1);
            color: white;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
        }

        /* Download button styles */
        .message .download-btn {
            background: linear-gradient(135deg, #1F7246
, #EF4444);
            color: white;
            border: 1px solid #1F7246;
        }

        .message .download-btn:hover {
            background: linear-gradient(135deg, #2D5016, #1F7246
);
            box-shadow: 0 4px 12px rgba(31, 114, 70, 0.3);
        }

        .message .download-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Ensure action buttons are visible */
        .message .message-actions {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .message .action-btn {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Download menu styles */
        .download-menu {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 180px;
            padding: 4px 0;
        }

        .download-menu-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            color: #374151;
            transition: background-color 0.2s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .download-menu-item:hover {
            background: #f3f4f6;
        }

        .download-menu-item svg {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            color: #6B7280;
        }

        .download-menu-item:hover svg {
            color: #374151;
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: #10B981;
        }

        .notification.error {
            background: #EF4444;
        }

        .notification.info {
            background: #3B82F6;
        }

        /* Feedback modal styles */
        .feedback-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .feedback-modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .feedback-modal h3 {
            margin: 0 0 16px 0;
            color: #111827;
            font-size: 18px;
            font-weight: 600;
        }

        .feedback-modal textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }

        .feedback-modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .feedback-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .feedback-modal-buttons .submit-btn {
            background: #3B82F6;
            color: white;
        }

        .feedback-modal-buttons .submit-btn:hover {
            background: #2563EB;
        }

        .feedback-modal-buttons .cancel-btn {
            background: #f3f4f6;
            color: #374151;
        }

        .feedback-modal-buttons .cancel-btn:hover {
            background: #e5e7eb;
        }

        /* Analytics Modal Styles */
        .analytics-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .analytics-modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .analytics-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .analytics-card h4 {
            margin: 0 0 15px 0;
            color: #007bff;
            font-size: 16px;
        }

        .analytics-card p {
            margin: 5px 0;
            font-size: 14px;
        }

        .analytics-card ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .analytics-card li {
            margin: 5px 0;
            font-size: 14px;
        }

        .analytics-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .export-btn:hover {
            background: #218838;
        }

        .analytics-button:hover {
            background: #0056b3;
        }

        /* Dropdown Toggle Button - Matching Front Page Design */
        .prompt-card .dropdown-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #6B7280;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .prompt-card .dropdown-toggle:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .prompt-card .dropdown-toggle i {
            color: inherit;
        }

        /* Expandable Content */
        .card-expanded-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            background: #fef2f2;
            border-radius: 8px;
            margin: 12px 0;
        }

        .card-expanded-content.expanded {
            max-height: none; /* Allow full expansion */
            overflow-y: visible; /* Show all content */
            overflow-x: hidden; /* Prevent horizontal scroll */
            padding: 16px;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #1F7246
 #f3f4f6; /* Firefox - thumb and track colors */
        }

        /* Custom scrollbar styling for WebKit browsers */
        .card-expanded-content.expanded::-webkit-scrollbar {
            width: 8px;
        }

        .card-expanded-content.expanded::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 4px;
        }

        .card-expanded-content.expanded::-webkit-scrollbar-thumb {
            background: #1F7246
;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .card-expanded-content.expanded::-webkit-scrollbar-thumb:hover {
            background: #2D5016;
        }

        /* Ensure smooth scrolling */
        .card-expanded-content {
            scroll-behavior: smooth;
        }
        .prompt-option {
            padding: 8px 12px;
            margin: 4px 0;
            background: white;
            border: 1px solid #f3f4f6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: all 0.2s ease;
        }

        .prompt-option:hover {
            background: #f9fafb;
            border-color: #1F7246
;
            color: #1F7246
;
        }

        /* Arrow rotation now handled by icon class changes in JavaScript */

        .dropdown-toggle {
            transition: transform 0.3s ease;
        }


        /* Responsive Design */
        @media (min-width: 1024px) {
            .CGMSCL-prompt-gallery-modal {
                width: 80vw;
                max-width: 1000px;
            }
        }

        @media (max-width: 1023px) and (min-width: 768px) {
            .CGMSCL-prompt-gallery-modal {
                width: 85vw;
                max-width: 800px;
            }
            
            .prompts-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-auto-rows: minmax(180px, auto);
            }
            
            .prompt-card:nth-child(10) {
                grid-column: span 1 !important;
            }
        }

        @media (max-width: 768px) {
            .CGMSCL-prompt-gallery-modal {
                width: 95vw;
                height: 90vh;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
            .prompts-grid {
                grid-template-columns: 1fr;
                grid-auto-rows: minmax(160px, auto);
                padding: 16px;
                justify-content: center;
            }
            
            .prompt-card:nth-child(10) {
                grid-column: span 1 !important;
            }
            
            .prompt-card {
                min-height: 160px;
                height: auto;
            }
            
            .gallery-header {
                padding: 16px 20px;
                width: 100%;
                max-width: 100%;
            }
            
            .gallery-header h2 {
                font-size: 20px;
            }
            
            .gallery-search-section {
                padding: 12px 16px;
            }
            
            .search-container {
                max-width: 100%;
                width: 100%;
                padding: 0;
            }
            
            .prompt-search-input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
            
            /* Mobile dropdown button adjustments */
            .prompt-card .dropdown-toggle {
                top: 16px;
                right: 16px;
                font-size: 14px;
            }
            
            .card-header {
                padding-right: 35px;
            }
            
            .card-title {
                margin-right: 35px;
            }
            
            /* Mobile expandable content adjustments */
            .card-expanded-content.expanded {
                max-height: 180px; /* Smaller max height on mobile */
            }
            
            .card-expanded-content.expanded::-webkit-scrollbar {
                width: 6px; /* Thinner scrollbar on mobile */
            }
            
            .prompt-option {
                font-size: 13px;
                padding: 6px 10px;
            }
        }

        @media (max-width: 480px) {
            .card-expanded-content.expanded {
                max-height: 150px; /* Even smaller on very small screens */
            }
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #e5e7eb;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #1F7246
;
        }

        input:checked + .slider:before {
            transform: translateX(18px);
        }

        /* Chat Area Component */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 120px clamp(8px, 2vw, 16px) clamp(8px, 2vw, 16px);
            display: flex;
            flex-direction: column;
            gap: clamp(6px, 1.5vw, 10px);
            /* Hide scrollbar on Firefox/Edge while preserving scroll */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Hide scrollbar on WebKit browsers for chat containers */
        .chat-container::-webkit-scrollbar,
        .chat-messages::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none;
        }

        /* Ensure chat-messages also hides native scrollbars cross-browser */
        .chat-messages {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Glassmorphism Chat Header */
        .chat-glassmorphism-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 1;
            transform: translateY(0);
        }

        .chat-glassmorphism-header.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 4px;
        }

        .chat-header-logo {
            width: 50px;
            height: auto;
            object-fit: contain;
            display: block;
        }

        .chat-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-new-chat-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 8px 16px;
            color: #333;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .chat-new-chat-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .chat-menu-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .chat-menu-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.25);
        }

        /* Adjust chat container for header */
        .chat-area.has-header .chat-container {
            padding-top: 90px;
        }

        /* Mobile responsiveness for chat header */
        @media (max-width: 768px) {
            .chat-glassmorphism-header {
                height: 65px;
                padding: 6px 16px;
            }

            .chat-header-logo {
                width: 35px;
            }

            .chat-header-left {
                padding-top: 3px;
            }

            .chat-new-chat-btn {
                padding: 6px 12px;
                font-size: 13px;
            }

            .chat-menu-btn {
                width: 28px;
                height: 28px;
            }

            .chat-container {
                padding: 100px clamp(8px, 2vw, 16px) clamp(8px, 2vw, 16px);
            }
        }

        .welcome-message-area {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            gap: 15px; 
            max-width: 80%; 
            margin: auto; 
        }

        .bot-icon {
            width: 100px; 
            height: auto;
            display: block; 
            margin-bottom: 10px; 
        }

        .welcome-text {
            font-size: clamp(1.5rem, 4vw, 2rem); 
            font-weight: bold;
            color: #A855F7; 
            margin: 0; 
        }

        .question-text {
            font-size: clamp(1.2rem, 3.5vw, 1.6rem); 
            color: #8B5CF6; 
            margin: 0; 
        }

        .chat-container::-webkit-scrollbar {
            width: 5px;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #C4B5FD, #DDD6FE);
            border-radius: 3px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease;
        }

        .user-message {
            justify-content: flex-end;
        }

        .bot-message {
            justify-content: flex-start;
            flex-direction: column;
            align-items: flex-start;
        }

        .message-bubble {
            max-width: 80%;
            padding: clamp(12px, 2vw, 16px) clamp(14px, 2.5vw, 20px);
            border-radius: 16px;
            line-height: 1.5;
            font-size: clamp(14px, 1.8vw, 16px);
            position: relative;
            letter-spacing: -0.01em;
        }

        /* Fix list styling in message bubbles */
        .message-bubble ul,
        .message-bubble ol {
            padding-left: 24px !important;
            margin: 10px 0 !important;
        }

        .message-bubble li {
            margin: 6px 0 !important;
            padding-left: 4px !important;
        }

        /* Table styles - exact copy from index2.html */
        .message-bubble table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1); 
            border-radius: 8px;
            overflow: hidden;
            min-width: max-content; /* Ensure table doesn't shrink below content */
        }
        
        /* Auto-wrap tables that aren't already in scroll containers */
        .message-bubble > table,
        .message-bubble .message-text > table:not(.table-scroll-container table) {
            display: block;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
            margin: 15px 0;
        }
        
        /* Ensure wrapped tables maintain their structure */
        .message-bubble > table,
        .message-bubble .message-text > table:not(.table-scroll-container table) {
            display: table;
            width: max-content;
            min-width: 100%;
        }

        .message-bubble th {
            background: rgba(218, 32, 32, 0.1);
            color: #1F7246;
            font-weight: 600;
            padding: 12px;
            text-align: left;
            border: 1px solid rgba(218, 32, 32, 0.3);
            white-space: normal;
        }

        .message-bubble td {
            padding: 10px 12px;
            border: 1px solid rgba(218, 32, 32, 0.2);
            white-space: normal;
            vertical-align: top;
            color: #374151;
        }

        .message-bubble tr:nth-child(even) {
             background: rgba(218, 32, 32, 0.05);
        }

        .message-bubble tr:hover {
            background: rgba(218, 32, 32, 0.1);
        }

        /* Document header styles */
        .message-bubble h3 {
            color: #DA2020;
            font-weight: 600;
            margin: 20px 0 10px 0;
            font-size: 1.1em;
        }

        /* Add styles for code blocks and inline code */
        .message-bubble pre {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .message-bubble code {
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        .message-bubble pre code {
            background: none;
            padding: 0;
        }

        /* Enhanced source links styling for multi-PDF system */
        .message-bubble .sources {
            margin-top: 15px;
            padding: 12px;
            background: rgba(218, 32, 32, 0.06);
            border-radius: 8px;
            border-left: 4px solid #DA2020;
        }

        .message-bubble .sources h4 {
            color: #DA2020;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .message-bubble .sources ul {
            list-style: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        .message-bubble .sources li {
            margin-bottom: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            border: 1px solid rgba(237, 93, 5, 0.1);
            transition: all 0.3s ease;
        }

        .message-bubble .sources li:hover {
            background: rgba(218, 32, 32, 0.08);
            border-color: rgba(218, 32, 32, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(218, 32, 32, 0.12);
        }

        /* Most relevant source styling */
        .message-bubble .sources .most-relevant-source {
            background: rgba(218, 32, 32, 0.12);
            border-color: rgba(218, 32, 32, 0.35);
            box-shadow: 0 2px 8px rgba(218, 32, 32, 0.18);
        }

        .message-bubble .sources .most-relevant-source:hover {
            background: rgba(218, 32, 32, 0.16);
            border-color: rgba(218, 32, 32, 0.45);
        }

        /* Ranked source styling */
        .message-bubble .sources .ranked-source {
            background: rgba(74, 144, 226, 0.1);
            border-color: rgba(74, 144, 226, 0.2);
        }

        .message-bubble .sources .ranked-source:hover {
            background: rgba(74, 144, 226, 0.15);
            border-color: rgba(74, 144, 226, 0.4);
        }

        /* Numbered source styling */
        .message-bubble .sources .numbered-source {
            background: rgba(74, 144, 226, 0.1);
            border-color: rgba(74, 144, 226, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .message-bubble .sources .numbered-source:hover {
            background: rgba(74, 144, 226, 0.15);
            border-color: rgba(74, 144, 226, 0.4);
        }

        .message-bubble .sources .numbered-source strong {
            color: #4a90e2;
            font-weight: 700;
            min-width: 20px;
        }

        /* Source link styling */
        .message-bubble .sources .source-link {
            color: #DA2020;
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .message-bubble .sources .source-link:hover {
            background: rgba(218, 32, 32, 0.12);
            color: #2D5016;
            text-decoration: none;
            transform: scale(1.02);
        }

        .message-bubble .sources .most-relevant-source .source-link {
            color: #DA2020;
            font-weight: 700;
        }

        .message-bubble .sources .most-relevant-source .source-link:hover {
            background: rgba(218, 32, 32, 0.14);
            color: #2D5016;
        }


        /* Fallback for standard links */
        .message-bubble .sources a:not(.source-link) {
            color: #DA2020;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .message-bubble .sources a:not(.source-link):hover {
            text-decoration: underline;
            color: #2D5016;
        }

        .message-bubble .sources a:not(.source-link):before {
            content: "";
            font-size: 12px;
        }

        /* Analysis Dropdown Styles */
        .analysis-dropdown {
            position: relative;
            display: inline-block;
            margin: 10px 0;
        }

        /* Analysis Toggle Dropdown Button Styles */
        .analysis-toggle-dropdown {
            display: flex;
            align-items: center;
        }

        .analysis-toggle-btn {
            background: #1F7246
;
            color: transparent;
            border: 2px solid #1F7246;
            border-radius: 20px;
            padding: 0;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            justify-content: flex-start;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            height: 32px;
        }

        .analysis-toggle-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .analysis-toggle-btn:active {
            transform: translateY(0);
        }

        /* ON State - White */
        .analysis-toggle-btn.on {
            background: white;
            border-color: #1F7246;
        }

        .analysis-toggle-btn.on:hover {
            background: #FEF2F2;
        }

        .analysis-toggle-btn.on::before {
            transform: translateX(28px);
            background: #1F7246
;
        }

        /* OFF State - Red */
        .analysis-toggle-btn.off {
            background: #1F7246
;
            border-color: #1F7246;
        }

        .analysis-toggle-btn.off:hover {
            background: #2D5016;
        }

        .toggle-text {
            display: none;
        }

        .toggle-icon {
            display: none;
        }

        /* Toggle Switch Slider */
        .analysis-toggle-btn::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }

        /* Mobile responsiveness for toggle button */
        @media (max-width: 768px) {
            .analysis-toggle-btn {
                min-width: 50px;
                height: 28px;
            }
            
            .analysis-toggle-btn::before {
                width: 20px;
                height: 20px;
            }
            
            .analysis-toggle-btn.on::before {
                transform: translateX(22px);
            }
        }

        .analysis-dropdown-btn {
            background: #E3F2FD;
            color: #1976D2;
            border: 2px solid #2196F3;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }

        .analysis-dropdown-btn:hover {
            background: #BBDEFB;
            border-color: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
        }

        .analysis-dropdown-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }

        .analysis-dropdown-content {
            display: none;
            position: absolute;
            background: white;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            z-index: 1000;
            top: 100%;
            left: 0;
            margin-top: 4px;
            overflow: hidden;
        }

        .analysis-dropdown-content.show {
            display: block;
            animation: fadeInDown 0.2s ease-out;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .analysis-dropdown-header {
            background: rgba(31, 114, 70, 0.05);
            padding: 12px 16px;
            border-bottom: 1px solid rgba(31, 114, 70, 0.1);
            font-weight: 600;
            color: #1F7246;
            font-size: 14px;
        }

        .analysis-dropdown-body {
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
        }

        .sql-query-code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.4;
            color: #495057;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        .analysis-dropdown-footer {
            background: rgba(31, 114, 70, 0.02);
            padding: 8px 16px;
            border-top: 1px solid rgba(31, 114, 70, 0.1);
            font-size: 12px;
            color: #6c757d;
            text-align: center;
        }

        /* Analysis Panel Styles */
        .analysis-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: white;
            border-left: 1px solid #e5e7eb;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        .analysis-panel.show {
            transform: translateX(0);
        }

        .analysis-panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }

        .analysis-panel-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #374151;
        }

        .analysis-panel-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            color: #6b7280;
            transition: all 0.2s ease;
        }

        .analysis-panel-close:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .analysis-panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .analysis-section {
            margin-bottom: 24px;
        }

        .analysis-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .analysis-query-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .analysis-empty-state {
            color: #6b7280;
            font-size: 13px;
            text-align: center;
            padding: 20px;
            margin: 0;
        }

        .analysis-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-label {
            font-size: 13px;
            color: #6b7280;
        }

        .stat-value {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
        }

        /* Mobile responsiveness for analysis dropdown */
        @media (max-width: 768px) {
            .analysis-dropdown-content {
                min-width: 300px;
                max-width: 90vw;
            }
            
            .analysis-panel {
                width: 100vw;
                max-width: 100vw;
            }
            
            .sql-query-code {
                font-size: 12px;
                padding: 10px;
            }
        }

        .user-message .message-bubble {
            /* Solid green background for user prompt messages (no gradient) */
            background: #1F7246;
            color: #fff;
            border-bottom-right-radius: 4px;
            box-shadow: 0 4px 15px rgba(31, 114, 70, 0.3);
        }

        .bot-message .message-bubble {
            background: rgba(255, 255, 255, 0.95);
            color: #1F2937;
            border-bottom-left-radius: 4px;
            box-shadow: 0 4px 15px rgba(31, 114, 70, 0.15);
            border: 1px solid rgba(31, 114, 70, 0.12);
            backdrop-filter: blur(10px);
        }

        .timestamp {
            font-size: clamp(10px, 1.5vw, 12px);
            color: #a0aec0;
            margin-top: 3px;
            letter-spacing: -0.01em;
            line-height: 1.2;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .avatar {
            width: clamp(32px, 4vw, 40px);
            height: clamp(32px, 4vw, 40px);
            border-radius: 50%;
            margin: 0 clamp(8px, 1.5vw, 12px);
            object-fit: cover;
            border: 2px solid #8B5CF6;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }

        .bot-avatar {
            border-color: #4A4A4A;
            box-shadow: 0 2px 8px rgba(74, 74, 74, 0.2);
        }

        .error-message {
            color: #1F7246
;
            font-size: clamp(12px, 1.8vw, 14px);
            text-align: center;
            padding: 8px;
            animation: slideIn 0.3s ease;
            font-weight: 500;
            letter-spacing: -0.01em;
        }

        .loader {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: clamp(6px, 1.5vw, 10px);
        }

        .loader::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 3px solid #8B5CF6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .typing-indicator {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: clamp(6px, 1.5vw, 10px);
        }

        .typing-indicator span {
            width: 6px;
            height: 6px;
            background: #4A4A4A;
            border-radius: 50%;
            margin: 0 3px;
            animation: bounce 0.6s infinite alternate;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .input-container {
            align-self: center;
            width: 95%;
            padding: clamp(12px, 2vw, 16px);
            border-top: 2px solid #4f46e5;
            display: flex;
            align-items: center;
            gap: 8px;
            position: sticky;
            bottom: 0;
            z-index: 10;
            flex-wrap: wrap;
            border-radius: 10px;
            -webkit-backdrop-filter: blur(50px);
            backdrop-filter: blur(50px);
            border: solid 4px #ffffff;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
            box-shadow: 0 8px 32px rgba(79, 70, 229, 0.1);
        }

        .input-textarea {
            flex: 1;
            background: transparent;
            border: none;
            border-radius: 50px;
            padding: clamp(10px, 2vw, 14px) clamp(12px, 2.5vw, 18px);
            color: #374151;
            font-size: clamp(14px, 1.8vw, 16px);
            resize: none;
            height: 50px;
            outline: none;
            transition: all 0.2s ease;
            letter-spacing: -0.01em;
            min-width: 200px;
            overflow: hidden; 
            box-shadow: 
            inset 4px 4px 8px rgba(79, 70, 229, 0.1),
            inset -4px -4px 8px rgba(255, 255, 255, 0.8);
        }


        .input-textarea:focus {
            border-color: #1F7246;
            box-shadow: 0 0 0 3px rgba(31, 114, 70, 0.2);
        }

        .input-textarea:hover {
            border-color: #1F7246;
        }

        .send-button, .mic-button, .tts-button {
            color: #fff;
            padding: 10px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: clamp(14px, 1.8vw, 16px);
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: -0.01em;
            touch-action: manipulation;
            width: 48px;
            height: 48px;
        }

        .send-button, .mic-button {
            background: linear-gradient(135deg, #1F7246
, #EF4444);
            box-shadow: 0 4px 15px rgba(31, 114, 70, 0.3);
        }

        .tts-button {
            background: linear-gradient(135deg, #059669, #10b981);
            box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3);
        }

        .send-button {
            border-radius: 12px;
            width: auto;
            padding: 10px 20px;
            height: 48px;
            min-width: 44px;
        }

        .send-button:hover, .mic-button:hover {
            background: linear-gradient(135deg, #2D5016, #1F7246
);
            box-shadow: 0 6px 20px rgba(31, 114, 70, 0.4);
            transform: translateY(-2px);
        }

        .tts-button:hover {
            background: linear-gradient(135deg, #047857, #059669);
            box-shadow: 0 6px 20px rgba(5, 150, 105, 0.4);
            transform: translateY(-2px);
        }

        .tts-button.playing {
            background: linear-gradient(135deg, #10b981, #34d399);
            animation: glow 0.8s infinite alternate ease-in-out;
        }

        .send-button.processing {
            background: #4A4A4A;
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #1F7246
, #2D5016);
            animation: glow 0.8s infinite alternate ease-in-out;
        }

        .mute-button.muted {
            background: #4A4A4A;
        }

        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(31, 114, 70, 0.7); }
            to { box-shadow: 0 0 40px rgba(31, 114, 70, 1.0); }
        }

        .footer {
            text-align: center;
            padding: clamp(12px, 2vw, 16px);
            font-size: clamp(13px, 1.8vw, 15px);
            color: #6B7280;
            letter-spacing: -0.01em;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(-4px);
            }
        }

        @media (max-width: 768px) {
            .container {
                border-radius: 8px;
                padding: 15px;
            }

            .header {
                padding: 10px;
            }

            .header .logo {
                width: 40px;
            }

            .header h1 {
                font-size: 18px;
            }

            .toggle-container {
                gap: 4px;
            }

            .toggle-label {
                font-size: 12px;
            }

            .toggle-switch {
                width: 30px;
                height: 15px;
            }

            .slider:before {
                height: 11px;
                width: 11px;
                bottom: 2px;
                left: 2px;
            }

            input:checked + .slider:before {
                transform: translateX(15px);
            }

            .chat-container {
                padding: 10px;
                gap: 8px;
            }

            .welcome-message-area {
                max-width: 95%;
            }

            .welcome-text {
                font-size: 1.2rem;
            }

            .question-text {
                font-size: 1rem;
            }

            .chat-container::-webkit-scrollbar {
                width: 3px;
            }

            .chat-container::-webkit-scrollbar-thumb {
                border-radius: 2px;
            }

            .message-bubble {
                padding: 10px 14px;
                border-radius: 12px;
                font-size: 14px;
            }

            .message-bubble table,
            .message-bubble th,
            .message-bubble td {
                font-size: 13px;
                padding: 8px;
            }

            .message-bubble h3 {
                font-size: 1em;
                margin: 15px 0 8px 0;
            }

            .avatar {
                width: 30px;
                height: 30px;
                margin: 0 6px;
            }

            .input-container {
                padding: 10px;
                gap: 6px;
                flex-wrap: nowrap;
            }

            .input-textarea {
                height: 40px;
                padding: 8px 12px;
                font-size: 14px;
                flex-grow: 1;
            }

            .send-button, .mic-button {
                padding: 8px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .send-button {
                padding: 8px 16px;
                min-width: 40px;
                height: 40px;
            }

            .sheets-button {
                width: 40px;
                height: 40px;
                margin-left: 6px;
                border-radius: 10px;
            }

            .footer {
                padding: 10px;
                font-size: 12px;
            }
        }
        @media (max-width: 480px) {
            .container {
                border-radius: 0;
                padding: 10px;
            }

            .header {
                padding: 6px;
            }

            .header .logo {
                width: 35px;
            }

            .header h1 {
                font-size: 16px;
            }

            .toggle-switch {
                width: 28px;
                height: 14px;
            }

            .slider:before {
                height: 10px;
                width: 10px;
                bottom: 2px;
                left: 2px;
            }

            input:checked + .slider:before {
                transform: translateX(14px);
            }

            .chat-container {
                padding: 6px;
                gap: 4px;
            }

            .message-bubble {
                padding: 8px 10px;
                border-radius: 10px;
                font-size: 13px;
            }

            .message-bubble table,
            .message-bubble th,
            .message-bubble td {
                font-size: 12px;
                padding: 6px;
            }

            .message-bubble h3 {
                font-size: 0.9em;
                margin: 10px 0 6px 0;
            }

            .timestamp {
                font-size: 9px;
                line-height: 1.1;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            .avatar {
                width: 25px;
                height: 25px;
                margin: 0 4px;
            }

            .input-container {
                padding: 8px;
                gap: 4px;
            }

            .input-textarea {
                height: 36px;
                padding: 6px 10px;
                font-size: 13px;
            }

            .send-button, .mic-button {
                padding: 6px;
                width: 36px;
                height: 36px;
                font-size: 13px;
                border-radius: 8px;
            }

            .send-button {
                padding: 6px 12px;
                height: 36px;
            }

            .sheets-button {
                width: 36px;
                height: 36px;
                margin-left: 4px;
                border-radius: 8px;
            }

            .footer {
                padding: 6px;
                font-size: 11px;
            }
        }

        @media (min-width: 1200px) {
            .container {
                max-width: 1000px;
            }

            .header h1 {
                font-size: 20px;
            }

            .message-bubble {
                font-size: 16px;
            }

            .input-textarea {
                font-size: 16px;
            }
        }

        .sheets-button {
            background: #000;
            color: #fff;
            padding: 10px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: clamp(14px, 1.8vw, 16px);
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: -0.01em;
            touch-action: manipulation;
            width: 48px;
            height: 48px;
            margin-left: 8px;
            box-shadow: 0 2px 8px rgba(74, 74, 74, 0.2);
        }

        .sheets-button:hover {
            background: #4A4A4A;
            box-shadow: 0 0 12px rgba(255, 107, 53, 0.9), 0 2px 6px rgba(255, 107, 53, 0.4);
        }

        .sheets-button.active {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
        }

        .sheets-button {
            display: none !important;
        }

        /* Sync button styles removed */

        /* Add styles for document headers */
        .document-header {
            color: #ed5d05;
            font-weight: 600;
            margin: 20px 0 10px 0;
            font-size: 1.1em;
        }

        .mute-slash {
            display: none;
        }

        .sound-waves {
            display: block;
        }

        .mute-button.muted .mute-slash {
            display: block;
        }

        .mute-button.muted .sound-waves {
            display: none;
        }

        .mute-button.glowing {
             animation: glow 0.8s infinite alternate ease-in-out;
        }

        .send-button.glowing {
             animation: glow 0.8s infinite alternate ease-in-out;
        }

        /* Enhanced Scrollable Table Container - Required for all tables - HIGH SPECIFICITY */
        .message-bubble .table-scroll-container {
            overflow-x: auto !important;
            overflow-y: hidden !important;
            scroll-behavior: smooth !important;
            max-width: 100% !important;
            width: 100% !important;
            margin: 15px 0 !important;
            border-radius: 8px !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
            position: relative !important;
            z-index: 1 !important;
            /* Enhanced smooth scrolling */
            -webkit-overflow-scrolling: touch !important;
            /* Ensure container doesn't expand beyond parent */
            box-sizing: border-box !important;
            /* Always show horizontal scrollbar when needed */
            scrollbar-width: thin;
            scrollbar-color: rgba(218, 32, 32, 0.7) rgba(0, 0, 0, 0.1);
        }

        /* Ensure table content doesn't wrap - HIGH SPECIFICITY */
        .message-bubble .table-scroll-container table,
        .message-bubble .table-scroll-container .markdown-table {
            white-space: nowrap !important;
            min-width: 100% !important;
            width: max-content !important;
            display: table !important;
        }

        .message-bubble .table-scroll-container table th,
        .message-bubble .table-scroll-container table td,
        .message-bubble .table-scroll-container .markdown-table th,
        .message-bubble .table-scroll-container .markdown-table td {
            white-space: nowrap !important;
        }

        /* Enhanced Custom scrollbar styling for better UX - HIGH SPECIFICITY */
        .message-bubble .table-scroll-container::-webkit-scrollbar {
            height: 10px !important;
            width: 10px !important;
        }

        .message-bubble .table-scroll-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1) !important;
            border-radius: 5px !important;
            margin: 0 2px !important;
        }

        .message-bubble .table-scroll-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, rgba(218, 32, 32, 0.7), rgba(237, 93, 5, 0.7)) !important;
            border-radius: 5px !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            transition: all 0.3s ease !important;
        }

        .message-bubble .table-scroll-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, rgba(218, 32, 32, 0.9), rgba(237, 93, 5, 0.9)) !important;
            transform: scaleY(1.1) !important;
        }

        .message-bubble .table-scroll-container::-webkit-scrollbar-corner {
            background: transparent !important;
        }

        /* Firefox scrollbar styling */
        .message-bubble .table-scroll-container {
            scrollbar-width: thin !important;
            scrollbar-color: rgba(218, 32, 32, 0.7) rgba(0, 0, 0, 0.1) !important;
        }

        /* Styles for inline preview table - Now using table-scroll-container */
        .table-wrapper-scroll {
            /* Legacy class - now handled by .table-scroll-container */
            overflow-x: auto;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .preview-table-inline {
            width: auto; 
            min-width: 100%; 
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-table-inline th,
        .preview-table-inline td {
            padding: 12px; 
            border: 1px solid #ed5d05; 
            text-align: left;
            white-space: nowrap; 
            color: #000; 
        }

        .preview-table-inline th {
            background: #ed5d0587; 
            color: #000; 
            font-weight: 600;
            white-space: normal; 
        }
        
        .preview-table-inline tr:nth-child(even) {
            background: rgba(235, 119, 37, 0.05); 
        }

        .preview-table-inline tr:hover {
            background: rgba(37, 99, 235, 0.1); 
        }

        /* Enhanced mathematical expression styles */
        .math-display {
            margin: 15px 0;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #ed5d05;
            overflow-x: auto;
        }

        .math-inline {
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-family: 'Times New Roman', serif;
        }

        /* Enhanced markdown table styles - Updated for scrollable container */
        .markdown-table {
            width: 100%;
            min-width: max-content; /* Ensure table doesn't shrink below content */
            border-collapse: collapse;
            margin: 0; /* Remove margin since container handles spacing */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: visible !important; /* Ensure table content is not hidden */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            table-layout: auto; /* Allow table to expand naturally */
            font-size: 14px;
            line-height: 1.4;
        }

        .markdown-table .table-header {
            background: rgba(218, 32, 32, 0.15);
            color: #1f1f1f;
            font-weight: 600;
            padding: 12px;
            border: 1px solid rgba(218, 32, 32, 0.2);
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
            white-space: nowrap; /* Prevent header wrapping for scrollable tables */
            min-width: max-content; /* Ensure headers don't shrink */
        }

        .markdown-table .table-cell {
            padding: 10px 12px;
            border: 1px solid rgba(218, 32, 32, 0.1);
            color: #1f1f1f;
            background: rgba(255, 255, 255, 0.05);
            vertical-align: top;
            word-wrap: break-word;
            white-space: nowrap; /* Prevent cell content wrapping for scrollable tables */
            min-width: max-content; /* Ensure cells don't shrink */
        }

        .markdown-table tr:nth-child(even) .table-cell {
            background: rgba(235, 119, 37, 0.05);
        }

        .markdown-table tr:hover .table-cell {
            background: rgba(37, 99, 235, 0.1);
        }

        /* Ensure all table rows are visible */
        .markdown-table tr {
            display: table-row !important;
            visibility: visible !important;
            height: auto !important;
            opacity: 1 !important;
        }

        .markdown-table tbody {
            display: table-row-group !important;
            visibility: visible !important;
        }

        /* Fix for table display issues - ensure tbody rows are shown */
        .markdown-table tbody tr {
            display: table-row !important;
            visibility: visible !important;
            height: auto !important;
            opacity: 1 !important;
        }
        
        /* Ensure all table elements are properly displayed */
        .markdown-table,
        .markdown-table * {
            box-sizing: border-box !important;
        }
        
        /* Fix for any overflow or hidden content issues - BUT allow scrollable containers */
        .message-bubble {
            overflow: visible !important;
            max-width: 100% !important;
        }
        
        /* Ensure ALL tables in message bubbles can scroll horizontally */
        .message-bubble table {
            max-width: none !important;
            width: max-content !important;
            min-width: 100% !important;
        }
        
        /* Auto-scroll for tables not in containers - fallback */
        /* Message text container - allow horizontal scroll for wide content */
        .message-bubble .message-text {
            overflow-x: auto !important;
            overflow-y: visible !important;
            max-width: 100% !important;
            word-wrap: break-word !important;
            /* Show scrollbar when needed */
            scrollbar-width: thin;
            scrollbar-color: rgba(218, 32, 32, 0.5) rgba(0, 0, 0, 0.1);
        }
        
        .message-bubble .message-text::-webkit-scrollbar {
            height: 8px;
        }
        
        .message-bubble .message-text::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        .message-bubble .message-text::-webkit-scrollbar-thumb {
            background: rgba(218, 32, 32, 0.5);
            border-radius: 4px;
        }
        
        .message-bubble .message-text::-webkit-scrollbar-thumb:hover {
            background: rgba(218, 32, 32, 0.7);
        }
        
        /* Ensure scrollable containers work even within message bubbles */
        .message-bubble .table-scroll-container {
            overflow-x: auto !important;
            overflow-y: hidden !important;
            position: relative !important;
            z-index: 1 !important;
            max-width: 100% !important;
            width: 100% !important;
            margin: 15px 0 !important;
        }
        
        /* Tables inside scroll containers */
        .message-bubble .table-scroll-container table,
        .message-bubble .table-scroll-container .markdown-table {
            overflow: visible !important;
            max-height: none !important;
            height: auto !important;
            display: table !important;
            width: max-content !important;
            min-width: 100% !important;
        }
        
        /* Tables NOT in scroll containers - wrap them automatically */
        .message-bubble table:not(.table-scroll-container table) {
            display: block;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
            margin: 15px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(218, 32, 32, 0.5) rgba(0, 0, 0, 0.1);
        }
        
        .message-bubble table:not(.table-scroll-container table)::-webkit-scrollbar {
            height: 8px;
        }
        
        .message-bubble table:not(.table-scroll-container table)::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        .message-bubble table:not(.table-scroll-container table)::-webkit-scrollbar-thumb {
            background: rgba(218, 32, 32, 0.5);
            border-radius: 4px;
        }
        
        .message-bubble table:not(.table-scroll-container table)::-webkit-scrollbar-thumb:hover {
            background: rgba(218, 32, 32, 0.7);
        }
        
        /* Maintain table structure for unwrapped tables */
        .message-bubble table:not(.table-scroll-container table) thead,
        .message-bubble table:not(.table-scroll-container table) tbody,
        .message-bubble table:not(.table-scroll-container table) tr {
            display: table;
            width: 100%;
            table-layout: auto;
        }
        
        .message-bubble table:not(.table-scroll-container table) {
            width: max-content;
            min-width: 100%;
        }
        
        /* Force table elements to be visible */
        .markdown-table tbody tr,
        .markdown-table thead tr,
        .markdown-table tr {
            display: table-row !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            max-height: none !important;
            overflow: visible !important;
        }

        .markdown-table thead {
            display: table-header-group !important;
            visibility: visible !important;
        }

        /* Document comparison table styles */
        .markdown-table .document-header {
            background: rgba(218, 32, 32, 0.2);
            color: #1f1f1f;
            font-weight: 700;
            padding: 15px 12px;
            border: 2px solid rgba(218, 32, 32, 0.3);
            text-align: center;
            font-size: 1.1em;
        }

        /* Enhanced Mobile responsiveness for scrollable table containers - HIGH SPECIFICITY */
        @media (max-width: 768px) {
            .message-bubble .table-scroll-container {
                margin: 12px 0 !important;
                border-radius: 6px !important;
                /* Enhanced scrollbar visibility and touch scrolling on mobile */
                -webkit-overflow-scrolling: touch !important;
                /* Better touch target size */
                padding-bottom: 2px !important;
            }
            
            .message-bubble .table-scroll-container::-webkit-scrollbar {
                height: 14px !important; /* Larger scrollbar on mobile for easier touch */
            }
            
            .message-bubble .table-scroll-container::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.15) !important;
                border-radius: 7px !important;
            }
            
            .message-bubble .table-scroll-container::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, rgba(218, 32, 32, 0.8), rgba(237, 93, 5, 0.8)) !important;
                border-radius: 7px !important;
                min-height: 20px !important; /* Ensure touch target is large enough */
            }
            
            /* Ensure tables are fully scrollable on mobile */
            .message-bubble .table-scroll-container .markdown-table {
                min-width: 100% !important;
            }
            
            .message-bubble .table-scroll-container .markdown-table th,
            .message-bubble .table-scroll-container .markdown-table td {
                padding: 10px 12px !important; /* Adequate padding for touch */
                font-size: 13px !important; /* Readable font size */
            }
        }

        @media (max-width: 480px) {
            .message-bubble .table-scroll-container {
                margin: 10px 0 !important;
                border-radius: 4px !important;
                /* Extra touch-friendly scrolling */
                -webkit-overflow-scrolling: touch !important;
            }
            
            .message-bubble .table-scroll-container::-webkit-scrollbar {
                height: 16px !important; /* Even larger scrollbar on very small screens */
            }
            
            .message-bubble .table-scroll-container::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, rgba(218, 32, 32, 0.9), rgba(237, 93, 5, 0.9)) !important;
                border-radius: 8px !important;
                min-height: 24px !important;
            }
            
            .message-bubble .table-scroll-container .markdown-table th,
            .message-bubble .table-scroll-container .markdown-table td {
                padding: 8px 10px !important; /* Optimized padding for small screens */
                font-size: 12px !important; /* Smaller font for better fit */
            }
        }

        /* CRITICAL: Force scrollable table containers to work - MAXIMUM SPECIFICITY */
        .message-bubble .table-scroll-container {
            overflow-x: auto !important;
            overflow-y: hidden !important;
            max-width: 100% !important;
            width: 100% !important;
            /* Ensure container respects parent boundaries */
            contain: layout style !important;
            /* Prevent any overflow outside chat container */
            clip-path: inset(0) !important;
        }
        
        .message-bubble .table-scroll-container .markdown-table {
            overflow: visible !important;
            min-width: max-content !important;
            width: auto !important;
            /* Ensure table doesn't break out of container */
            max-width: none !important;
        }
        
        .message-bubble .table-scroll-container .markdown-table th,
        .message-bubble .table-scroll-container .markdown-table td {
            white-space: nowrap !important;
            min-width: max-content !important;
            /* Prevent cell content from breaking layout */
            word-break: keep-all !important;
        }

        /* Visual indicators for scrollable content */
        .message-bubble .table-scroll-container::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(to left, rgba(255, 255, 255, 0.1), transparent);
            pointer-events: none;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .message-bubble .table-scroll-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(to right, rgba(255, 255, 255, 0.1), transparent);
            pointer-events: none;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show scroll indicators when content overflows */
        .message-bubble .table-scroll-container.scrollable-left::after {
            opacity: 1;
        }

        .message-bubble .table-scroll-container.scrollable-right::before {
            opacity: 1;
        }

        /* Fallback for browsers without ResizeObserver support */
        @supports not (resize: none) {
            .message-bubble .table-scroll-container {
                /* Ensure basic functionality works */
                overflow-x: scroll !important;
            }
        }

        /* Ensure table scroll containers work in all scenarios */
        .message-bubble .table-scroll-container {
            /* Force hardware acceleration for smooth scrolling */
            transform: translateZ(0) !important;
            will-change: scroll-position !important;
        }

        /* Additional safety measures for viewport containment */
        .chat-container {
            overflow-x: hidden !important;
            overflow-y: auto !important;
        }

        /* Ensure message bubbles don't overflow chat container */
        .message-bubble {
            max-width: 100% !important;
            overflow: visible !important;
            word-wrap: break-word !important;
        }

        /* Retry button styles */
        .retry-sync-btn {
            background: #ed5d05 !important;
            color: white !important;
            border: none !important;
            padding: 8px 16px !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            transition: all 0.3s ease !important;
            margin-top: 10px !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 6px !important;
        }

        .retry-sync-btn:hover {
            background: #d14d00 !important;
            transform: scale(1.02) !important;
            box-shadow: 0 2px 8px rgba(237, 93, 5, 0.3) !important;
        }

        .retry-sync-btn:disabled {
            background: #a0a0a0 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }


        /* AI Assistant Cards Styles - Purple Theme */
        .ai-cards-section {
            padding: 20px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.8s ease;
            overflow-y: auto;
        }

        .ai-cards-section.show {
            display: flex;
        }

        .ai-cards-section.scatter-exit {
            opacity: 0;
            transform: scale(0.8);
            filter: blur(10px);
        }

        .ai-cards-section.scatter-exit .ai-card {
            animation: scatterCards 0.8s ease-out forwards;
        }

        @keyframes scatterCards {
            0% { opacity: 1; transform: translateY(0) rotate(0deg) scale(1); }
            100% { 
                opacity: 0; 
                transform: translateY(-100px) rotate(20deg) scale(0.5);
                filter: blur(5px);
            }
        }

        .cards-header {
            text-align: center;
            margin-bottom: 16px;
        }

        .cards-title {
            font-size: 2rem;
            font-weight: 800;
            color: #1F7246;
            margin-bottom: 6px;
            letter-spacing: -0.02em;
            text-shadow: 0 2px 10px rgba(31, 114, 70, 0.2);
        }

        .cards-subtitle {
            font-size: 0.9rem;
            color: #2D5016;
            max-width: 720px;
            margin: 0 auto;
            line-height: 1.4;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
        }

        .ai-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 14px;
            padding: 14px;
            box-shadow: 
                0 4px 15px rgba(31, 114, 70, 0.1),
                0 15px 35px rgba(31, 114, 70, 0.15);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid rgba(31, 114, 70, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            animation-delay: var(--delay, 0s);
        }

        .ai-card:hover {
            transform: translateY(-8px);
            box-shadow: 
                0 8px 30px rgba(31, 114, 70, 0.25),
                0 25px 50px rgba(31, 114, 70, 0.2);
            border-color: #1F7246;
        }

        .ai-card:nth-child(1) { --delay: 0.1s; }
        .ai-card:nth-child(2) { --delay: 0.2s; }
        .ai-card:nth-child(3) { --delay: 0.3s; }
        .ai-card:nth-child(4) { --delay: 0.4s; }
        .ai-card:nth-child(5) { --delay: 0.5s; }
        .ai-card:nth-child(6) { --delay: 0.6s; }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .card-icon {
            font-size: 1.3rem;
            margin-right: 10px;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #1F7246
, #EF4444);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 15px rgba(31, 114, 70, 0.3);
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1F7246
;
            line-height: 1.2;
            flex: 1;
        }

        .card-description {
            color: #1F7246
;
            line-height: 1.6;
            font-size: 0.95rem;
        }

        /* Dropdown Styles */
        .dropdown-toggle {
            font-size: 1rem;
            color: #6B7280;
            cursor: pointer;
            margin-left: 12px;
            transition: transform 0.3s ease;
            user-select: none;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
            min-height: 24px;
        }

        .dropdown-toggle:hover {
            background-color: rgba(107, 114, 128, 0.1);
        }

        /* Arrow rotation now handled by icon class changes in JavaScript */

        .dropdown-content {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(31, 114, 70, 0.2);
            animation: slideDown 0.3s ease-out;
            max-height: none;
            overflow-y: visible;
            position: relative;
            z-index: 1;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(31, 114, 70, 0.05);
            border-radius: 6px;
            color: #1F7246
;
            font-size: 0.85rem;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(31, 114, 70, 0.1);
        }

        .dropdown-item:hover {
            background: rgba(31, 114, 70, 0.1);
            border-color: rgba(31, 114, 70, 0.3);
            transform: translateX(4px);
        }

        .dropdown-item:last-child {
            margin-bottom: 0;
        }

        /* Ensure only one dropdown is open at a time */
        .cards-grid .ai-card:not(.active) .dropdown-content {
            display: none !important;
        }

        /* Arrow state now handled by icon class changes in JavaScript */

        .cards-grid .ai-card.active .dropdown-content {
            display: block !important;
        }

        /* Reset all cards initially */
        .cards-grid .ai-card {
            transition: all 0.3s ease;
        }

        .cards-grid .ai-card .dropdown-content {
            display: none;
        }

        /* Arrow state now handled by icon class changes in JavaScript */

        /* Show More Button Styles */
        .show-more-button {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #1F7246
, #EF4444);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(31, 114, 70, 0.3);
            margin-top: 20px;
        }

        .show-more-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(31, 114, 70, 0.4);
        }

        .show-more-arrow {
            transition: transform 0.3s ease;
            font-size: 1.2rem;
        }

        /* Arrow rotation now handled by icon class changes in JavaScript */

        .additional-categories {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        .additional-categories.show {
            display: grid;
        }

        /* Suggested Prompts Styles */
        /* Inline suggestions container (no box/heading) */
        .suggested-inline {
            margin-top: 10px;
            width: 100%;
            max-width: 80%;
            margin-left: auto;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            align-items: center;
        }

        /* Title removed per requirement */

        .suggested-prompts-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
            justify-content: flex-end;
        }

        /* Ensure prompt gallery button shows inside suggestions block */
        .suggested-inline .chat-prompt-gallery-btn {
            display: inline-flex !important;
        }

        .suggested-prompt-btn {
            padding: 10px 16px;
            background: #ffffff;
            border: 1.5px solid rgba(31, 114, 70, 0.35);
            border-radius: 9999px; /* pill */
            color: #1F7246
;
            font-size: 0.9rem;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(31, 114, 70, 0.08);
        }

        .suggested-prompt-btn:hover,
        .suggested-prompt-btn:focus {
            background: rgba(31, 114, 70, 0.06);
            border-color: rgba(31, 114, 70, 0.6);
            outline: none;
            transform: translateY(-1px);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                max-height: 500px;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .ai-cards-section {
                padding: 15px;
            }
            .cards-title {
                font-size: 1.8rem;
            }
            .cards-subtitle {
                font-size: 1rem;
            }
            .cards-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            .ai-card {
                padding: 16px;
            }
            .card-title {
                font-size: 1.1rem;
            }
            .card-description {
                font-size: 0.9rem;
            }
        }
        /* Quick fix to restore textarea scrollbar */
        #user-input {
            overflow-y: scroll !important;
            scrollbar-width: auto !important;
            -ms-overflow-style: auto !important;
        }

        #user-input::-webkit-scrollbar {
            display: block !important;
            width: 6px !important;
        }

        #user-input::-webkit-scrollbar-thumb {
            background: #aaaaaa;
            border-radius: 3px;
        }

        /* ========================================
           ENHANCED PROMPT CARD STYLING
           ======================================== */

        /* 1. ENHANCED BOX SHADOWS FOR ALL PROMPT CARDS */
        .prompt-card,
        .prompt-card-main,
        .prompt-card-extended {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08),
                        0 1px 3px rgba(0, 0, 0, 0.12) !important;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
            border-radius: 16px !important;
            background: linear-gradient(145deg, #ffffff 0%, #fefefe 100%) !important;
            position: relative;
            overflow: hidden;
            will-change: transform, box-shadow;
            backface-visibility: hidden;
        }

        /* Enhanced shadow on hover */
        .prompt-card:hover,
        .prompt-card-main:hover,
        .prompt-card-extended:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12),
                        0 2px 6px rgba(0, 0, 0, 0.16) !important;
            transform: translateY(-2px) !important;
        }

        /* Expanded card shadow adjustment */
        .prompt-card.expanded,
        .prompt-card-extended.expanded {
            box-shadow: 0 6px 18px rgba(31, 114, 70, 0.15),
                        0 2px 4px rgba(31, 114, 70, 0.08) !important;
        }

        /* Subtle inner highlight */
        .prompt-card::before,
        .prompt-card-main::before,
        .prompt-card-extended::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.8) 50%,
                transparent 100%);
            pointer-events: none;
        }

        /* 2. CENTER ICONS IN CARDS */
        .prompt-card .card-icon,
        .prompt-card-main .card-icon,
        .prompt-card-extended .card-icon,
        .card-header-main .card-icon,
        .card-header-extended .card-icon {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin: 0 auto 16px auto !important;
            text-align: center !important;
            background: #1F7246
 !important;
            color: white !important;
            border-radius: 10px !important;
            width: 44px !important;
            height: 44px !important;
            font-size: 20px !important;
            box-shadow: 0 2px 4px rgba(31, 114, 70, 0.2) !important;
        }

        /* For cards with icon + title layout */
        .card-header-main,
        .card-header-extended {
            display: flex !important;
            align-items: center !important;
            justify-content: flex-start !important;
            margin-bottom: 16px !important;
        }

        .card-header-main .card-icon,
        .card-header-extended .card-icon {
            margin-right: 12px !important;
            margin-left: 0 !important;
            margin-bottom: 0 !important;
            flex-shrink: 0 !important;
        }

        .card-header-main .card-title,
        .card-header-extended .card-title {
            flex: 1 !important;
            margin: 0 !important;
            font-weight: 600 !important;
            font-size: 18px !important;
            color: #1f2937 !important;
            padding-right: 0 !important; /* Ensure no extra padding */
        }

        /* 3. RESPONSIVE ADJUSTMENTS */
        /* Mobile responsive shadows */
        @media (max-width: 768px) {
            .prompt-card,
            .prompt-card-main,
            .prompt-card-extended {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06),
                            0 1px 2px rgba(0, 0, 0, 0.10) !important;
            }

            .prompt-card:hover,
            .prompt-card-main:hover,
            .prompt-card-extended:hover {
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.10), 
                            0 1px 4px rgba(0, 0, 0, 0.14) !important;
                transform: translateY(-1px) !important;
            }

            .prompt-card .card-icon,
            .prompt-card-main .card-icon,
            .prompt-card-extended .card-icon,
            .card-header-main .card-icon,
            .card-header-extended .card-icon {
                width: 40px !important;
                height: 40px !important;
                margin-bottom: 16px !important;
            }
        }

        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .prompt-card,
            .prompt-card-main,
            .prompt-card-extended {
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07),
                            0 1px 2px rgba(0, 0, 0, 0.11) !important;
            }
        }

        /* 4. GRID LAYOUT ENHANCEMENTS */
        .main-prompt-cards,
        .extended-cards-grid {
            display: grid !important;
            gap: 24px !important;
            margin-bottom: 32px !important;
        }

        .main-prompt-cards {
            grid-template-columns: repeat(3, 1fr) !important;
        }

        .extended-cards-grid {
            grid-template-columns: repeat(3, 1fr) !important;
        }

        .main-prompt-cards .prompt-card-main,
        .extended-cards-grid .prompt-card-extended {
            height: auto !important;
            min-height: 200px !important;
            align-self: start !important;
        }
        /* Mobile grid adjustments */
        @media (max-width: 767px) {
            .main-prompt-cards,
            .extended-cards-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }
        }

        /* Tablet grid adjustments */
        @media (min-width: 768px) and (max-width: 1023px) {
            .main-prompt-cards,
            .extended-cards-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 20px !important;
            }
        }

        /* 5. ACCESSIBILITY AND PERFORMANCE */
        /* Respect user's motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .prompt-card,
            .prompt-card-main,
            .prompt-card-extended,
            .prompt-card:hover,
            .prompt-card-main:hover,
            .prompt-card-extended:hover {
                transition: none !important;
                transform: none !important;
            }
        }

        /* High contrast mode adjustments */
        @media (prefers-contrast: high) {
            .prompt-card,
            .prompt-card-main,
            .prompt-card-extended {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3),
                            0 1px 3px rgba(0, 0, 0, 0.4) !important;
                border: 1px solid #000 !important;
            }
        }

        /* 6. PRESERVE ALL EXISTING FUNCTIONALITY */
        /* Ensure dropdown toggles remain functional */
        .prompt-card .dropdown-toggle {
            position: absolute !important;
            top: 24px !important;
            right: 24px !important;
            z-index: 2 !important;
        }
        
        /* Extended card toggles are now inline with the title */
        .prompt-card-extended .dropdown-toggle {
            position: relative !important;
            top: auto !important;
            right: auto !important;
            z-index: 2 !important;
        }

        /* Ensure expanded content works properly */
        .card-expanded-content {
            z-index: 1 !important;
        }

        /* Ensure hover states don't interfere with interactions */
        .prompt-card:hover .dropdown-toggle,
        .prompt-card-extended:hover .dropdown-toggle {
            pointer-events: auto !important;
        }

        /* 7. SPECIFIC OVERRIDES FOR CONSISTENCY */
        /* Override any conflicting styles */
        .prompt-card .card-icon {
            font-size: 20px !important;
            margin-bottom: 16px !important;
            display: flex !important;
        }

        .prompt-card .card-title {
            font-size: 18px !important;
            font-weight: 600 !important;
            color: #1f2937 !important;
            margin: 0 0 8px 0 !important;
            line-height: 1.3 !important;
        }

        .prompt-card .card-description {
            font-size: 14px !important;
            color: #6b7280 !important;
            margin: 0 !important;
            line-height: 1.4 !important;
        }

        /* 8. TITLE ALIGNMENT ENHANCEMENTS */
        /* Ensure all card titles are properly aligned */
        .card-header-main,
        .card-header-extended,
        .card-header {
            display: flex !important;
            align-items: center !important;
            justify-content: flex-start !important;
            margin-bottom: 16px !important;
            min-height: 44px !important; /* Match icon height for consistent alignment */
        }

        /* Title alignment within headers */
        .card-header-main .card-title,
        .card-header-extended .card-title,
        .card-header .card-title {
            display: flex !important;
            align-items: center !important;
            flex: 1 !important;
            margin: 0 !important;
            padding: 0 !important;
            font-size: 18px !important;
            font-weight: 600 !important;
            color: #1f2937 !important;
            line-height: 1.3 !important;
            text-align: left !important;
            vertical-align: middle !important;
            height: auto !important;
            min-height: 24px !important; /* Ensure minimum height for consistency */
        }

        /* Ensure dropdown arrows are properly positioned */
        .card-header-main .dropdown-toggle,
        .card-header-extended .dropdown-toggle {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin-left: 8px !important;
            flex-shrink: 0 !important;
            height: 28px !important;
            width: 28px !important;
            background: transparent !important;
        }
        
        .card-header .dropdown-toggle {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin-left: auto !important;
            flex-shrink: 0 !important;
            height: 32px !important;
            width: 32px !important;
        }

        /* Icon alignment within headers */
        .card-header-main .card-icon,
        .card-header-extended .card-icon,
        .card-header .card-icon {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin-right: 12px !important;
            margin-left: 0 !important;
            margin-bottom: 0 !important;
            flex-shrink: 0 !important;
            width: 44px !important;
            height: 44px !important;
        }

        /* Responsive title alignment */
        @media (max-width: 768px) {
            .card-header-main,
            .card-header-extended,
            .card-header {
                min-height: 40px !important; /* Match mobile icon height */
            }

            .card-header-main .card-title,
            .card-header-extended .card-title,
            .card-header .card-title {
                font-size: 16px !important;
                min-height: 20px !important;
            }

            .card-header-main .card-icon,
            .card-header-extended .card-icon,
            .card-header .card-icon {
                width: 40px !important;
                height: 40px !important;
            }
        }

        /* Ensure consistent spacing for all card types */
        .prompt-card-main,
        .prompt-card-extended,
        .prompt-card {
            display: flex !important;
            flex-direction: column !important;
        }

        /* Fix any potential text wrapping issues */
        .card-header-main .card-title,
        .card-header-extended .card-title,
        .card-header .card-title {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            hyphens: auto !important;
            white-space: normal !important;
            word-break: normal !important;
            display: -webkit-box !important;
            -webkit-line-clamp: 2 !important;
            -webkit-box-orient: vertical !important;
            overflow: hidden !important;
            min-height: 2.6em !important;
        }

        /* Ensure proper spacing between title and description */
        .prompt-card-main .card-description,
        .prompt-card-extended .card-description,
        .prompt-card .card-description {
            margin-top: 8px !important;
            margin-bottom: 0 !important;
        }

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading CGMSCL Dashboard...</div>
    </div>

    <div class="copilot-layout" id="chatContainer">


        <!-- Main Content Area -->
        <div class="main-content" id="main-content">

            <!-- Analysis Panel -->
            <div class="analysis-panel" id="analysisPanel" style="display: none;">
                <div class="analysis-panel-header">
                    <h3>Analysis Panel</h3>
                    <button class="analysis-panel-close" onclick="toggleAnalysisPanel()" aria-label="Close Analysis Panel">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="analysis-panel-content">
                    <div class="analysis-section">
                        <h4>Recent Queries</h4>
                        <div class="analysis-query-list" id="analysisQueryList">
                            <p class="analysis-empty-state">No analysis queries yet. Start a conversation to see analysis data here.</p>
                        </div>
                    </div>
                    <div class="analysis-section">
                        <h4>Query Statistics</h4>
                        <div class="analysis-stats" id="analysisStats">
                            <div class="stat-item">
                                <span class="stat-label">Total Queries:</span>
                                <span class="stat-value" id="totalQueries">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">SQL Queries:</span>
                                <span class="stat-value" id="sqlQueries">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Welcome Screen -->
            <div class="welcome-screen" id="welcome-screen">
                
                <!-- Fixed Header Section -->
                <div class="welcome-fixed-header">
                    <!-- CGMSCL Logo on Left -->
                    <div class="top-left-logo">
                        <img src="static/images/motherson2.png" alt="CGMSCL Logo" class="header-logo" onerror="this.onerror=null; this.src='https://via.placeholder.com/150x60?text=Logo+Error';">
                    </div>
                    
                    <!-- Top Right Controls -->
                    <div class="top-right-controls">
                    <!-- Session Info Display -->
                   
                    <!-- Excel Download Button -->
                    <button class="excel-download-btn" id="excelDownloadButton" aria-label="Download Excel Feedback" title="Download feedback as Excel file">
                        <img src="/static/images/excel.png" alt="Download Excel" style="width: 20px; height: 20px; object-fit: contain;">
                    </button>
                    
                    <!-- New Chat Button -->
                    <button class="new-chat-btn" id="newChatButton" aria-label="New Chat">
                        <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="size-5">
                            <mask id="mask0" maskUnits="userSpaceOnUse" x="0" y="0" width="20" height="20" style="mask-type: alpha;">
                                <path d="M19.7803 1.28033C20.0732 0.987435 20.0732 0.512561 19.7803 0.219669C19.4874 -0.0732238 19.0125 -0.0732228 18.7196 0.219671L8.71967 10.2197L8.25 11.75L9.78033 11.2803L19.7803 1.28033ZM4.25 1C2.45507 1 1 2.45508 1 4.25V15.75C1 17.5449 2.45507 19 4.25 19H15.75C17.5449 19 19 17.5449 19 15.75V7.75C19 7.33579 18.6642 7 18.25 7C17.8358 7 17.5 7.33579 17.5 7.75V15.75C17.5 16.7165 16.7165 17.5 15.75 17.5H4.25C3.2835 17.5 2.5 16.7165 2.5 15.75V4.25C2.5 3.2835 3.2835 2.5 4.25 2.5H12.25C12.6642 2.5 13 2.16421 13 1.75C13 1.33579 12.6642 1 12.25 1H4.25Z" fill="currentColor"></path>
                            </mask>
                            <g mask="url(#mask0)">
                                <rect width="24" height="24" transform="translate(-2 -2)" fill="currentColor"></rect>
                            </g>
                        </svg>
                    </button>

                    <!-- Analysis Toggle Dropdown Button -->
                    <div class="analysis-toggle-dropdown">
                        <button class="analysis-toggle-btn" id="analysisToggleHome" onclick="toggleAnalysisMode()" aria-label="Toggle Analysis Mode">
                            <span class="toggle-text" id="analysisToggleTextHome">Analysis: OFF</span>
                            <span class="toggle-icon" id="analysisToggleIconHome"></span>
                        </button>
                    </div>

                    <!-- Settings dropdown -->
                    <div class="settings-dropdown">
                        <!-- <button class="settings-btn" aria-haspopup="true" aria-expanded="false" aria-label="Settings">
                            <i class="fas fa-ellipsis-v"></i>
                        </button> -->
                        
                        <!-- Settings dropdown menu -->
                        <div class="settings-menu" role="menu" aria-hidden="true">
                            <!-- New CRUD options -->
                            <div class="settings-item" role="menuitem" data-action="add" tabindex="0">
                                <i class="fas fa-plus"></i>
                                <span>Add</span>
                            </div>
                            <div class="settings-item" role="menuitem" data-action="edit" tabindex="0">
                                <i class="fas fa-edit"></i>
                                <span>Edit</span>
                            </div>
                            <div class="settings-item" role="menuitem" data-action="delete" tabindex="0">
                                <i class="fas fa-trash"></i>
                                <span>Delete</span>
                            </div>
                            
                            <!-- Separator -->
                            <div class="settings-separator"></div>
                            
                            <!-- Existing options -->
                            <div class="settings-item" role="menuitem" data-action="recent" tabindex="0">
                                <i class="fas fa-clock"></i>
                                <span>Recent pages</span>
                            </div>
                            <div class="settings-item" role="menuitem" data-action="about" tabindex="0">
                                <i class="fas fa-info-circle"></i>
                                <span>About</span>
                            </div>
                            <div class="settings-item" role="menuitem" data-action="feedback" tabindex="0">
                                <i class="fas fa-comment-alt"></i>
                                <span>Send Feedback</span>
                            </div>
                            <div class="settings-item" role="menuitem" data-action="settings" tabindex="0">
                                <i class="fas fa-cog"></i>
                                <span>Setting</span>
                            </div>
                            
                            <!-- Separator -->
                            <div class="settings-separator"></div>
                            
                            <!-- Cache Management -->
                            <div class="settings-item" role="menuitem" data-action="clear-cache" tabindex="0">
                                <i class="fas fa-trash-alt"></i>
                                <span>Clear All Caches</span>
                            </div>
                        </div>
                    </div>
                </div>

                    <div class="welcome-header">
                        <h1 class="welcome-title">How can I assist you today?</h1>
                        <p class="welcome-subtitle">CGMSCL project focused on medical inventory, procurement, and warehouse management for medicines and medical supplies used in healthcare facility stock operations across Chhattisgarh government medical stores.</p>
                    </div>
                    
                    <!-- Microsoft Copilot-style Search Interface -->
                    <div class="copilot-search-container">
                    <!-- Floating suggestions above search box -->
                    <div class="floating-suggestions">
                        <button class="suggestion-pill" onclick="fillCopilotSearch('Generate a summary report on current asset performance, highlighting areas of improvement')" style="animation-delay: 0.1s;">Generate a summary report on current asset performance, highlighting areas of improvement</button>
                        <button class="suggestion-pill" onclick="fillCopilotSearch('Analyze supplier performance based on delivery times and quality')" style="animation-delay: 0.2s;">Analyze supplier performance based on delivery times and quality</button>
                        <button class="suggestion-pill" onclick="fillCopilotSearch('Calculate the average time-to-repair for each asset type')" style="animation-delay: 0.3s;">Calculate the average time-to-repair for each asset type</button>
                        <!-- Prompt Gallery Button next to suggestions -->
                        <button class="prompt-gallery-btn" onclick="openPromptsModal()" title="Prompt Gallery" style="animation-delay: 0.4s;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="3" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="3" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Search input area -->
                    <div class="copilot-search-box">
                        <input type="text" id="copilot-search-input" placeholder="Draft an email to about..." onkeydown="handleCopilotEnterKey(event)" />
                        <button class="add-attachment-btn" title="Add attachment">+</button>
                        <button class="mic-btn" id="copilot-mic-btn" title="Voice input" onclick="handleCopilotMicClick(event)">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 1C10.34 1 9 2.34 9 4V12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12V4C15 2.34 13.66 1 12 1Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M19 10V12C19 16.42 15.42 20 11 20H13C17.42 20 21 16.42 21 12V10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M12 20V24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8 24H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <button class="send-btn" id="copilot-send-btn" onclick="sendCopilotMessage()" title="Send message">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
                </div>
                
                <!-- Scrollable Content Section -->
                <div class="welcome-scrollable-content">
                    <!-- Main Prompt Cards (Tender Tracking + PO Tracking) -->
                    <div class="main-prompt-cards">
                        <!-- Tender Tracking Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Tender Tracking</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-tender-tracking')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Track tenders, rate contracts, and performance KPIs</p>
                            <div class="dropdown-content-main" id="dropdown-main-tender-tracking" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Show items whose RC expires soon (<90 days)')">Show items whose RC expires soon (&lt;90 days)</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Give me all of the items which have valid rate contracts')">Give me all of the items which have valid rate contracts</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Average bids per tender?')">Average bids per tender?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Categories with best RC coverage')">Categories with best RC coverage</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Categories with best RC coverage, also give me the Pareto chart for this as well')">Categories with best RC coverage, also give me the Pareto chart for this as well</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('EDL 2025 items vs non-EDL bids?')">EDL 2025 items vs non-EDL bids?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('List the worst performing tenders')">List the worst performing tenders</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('What is the average time taken for a tender from start to finish')">What is the average time taken for a tender from start to finish</div>
                            </div>
                        </div>
                        <!-- PO Tracking Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">PO Tracking</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-po-tracking')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Analyze purchase orders, supplier KPIs, and delivery performance</p>
                            <div class="dropdown-content-main" id="dropdown-main-po-tracking" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items have supply < 50% of PO quantity?')">Which items have supply < 50% of PO quantity?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which POs are delayed beyond delivery SLA?')">Which POs are delayed beyond delivery SLA?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which high-priority items have pending inward at WH?')">Which high-priority items have pending inward at WH?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which POs have partial supply (<50%)?')">Which POs have partial supply (<50%)?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items have been awarded and which are pending award?')">Which items have been awarded and which are pending award?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('For Item Oxytocin Injection IP , has PO been issued to the vendor?')">For Item Oxytocin Injection IP , has PO been issued to the vendor?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('What is the PO execution status of Item Oxytocin Injection IP?')">What is the PO execution status of Item Oxytocin Injection IP?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('What is the supply status of PO for Item Multivitamin + Multimineral Syrup 200 ml ?')">What is the supply status of PO for Item Multivitamin + Multimineral Syrup 200 ml ?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('PO-wise supply status (drug, quantity, percentage supplied).')">PO-wise supply status (drug, quantity, percentage supplied).</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('POs where partial supplies were made but balance overdue.')">POs where partial supplies were made but balance overdue.</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Vendors who have defaulted in timely supply.')">Vendors who have defaulted in timely supply.</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which POs are nearing expiry of delivery period?')">Which POs are nearing expiry of delivery period?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('PO-wise inward delays at WH.')">PO-wise inward delays at WH.</div>
                            </div>
                        </div>
                        <!-- Tender-level Monitoring Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Tender-level Monitoring</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-tender-level-monitoring')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Monitor tender status, delays, vendor participation, and award status</p>
                            <div class="dropdown-content-main" id="dropdown-main-tender-level-monitoring" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('What is the current status of Tender No. XYZ (stage-wise)?')">What is the current status of Tender No. XYZ (stage-wise)?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which tenders are delayed and may impact supply?')">Which tenders are delayed and may impact supply?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items in this tender received single-vendor bids?')">Which items in this tender received single-vendor bids?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Vendor participation summary item-wise for this tender, tender no. 164')">Vendor participation summary item-wise for this tender, tender no. 164</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Items where bidders were disqualified during PQ or technical evaluation.')">Items where bidders were disqualified during PQ or technical evaluation.</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items have abnormally high quotes compared to previous RC?')">Which items have abnormally high quotes compared to previous RC?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items have been awarded and which are pending award?')">Which items have been awarded and which are pending award?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('For Item Oxytocin Injection IP, has PO been issued to the vendor?')">For Item Oxytocin Injection IP, has PO been issued to the vendor?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items have supply < 50% of PO quantity?')">Which items have supply < 50% of PO quantity?</div>
                            </div>
                        </div>
                        <!-- Rate Contract (RC)  Critical Questions Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Rate Contract (RC)  Critical Questions</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-rate-contract-critical')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Monitor RC expiry, extensions, vendor watch, and transition requirements</p>
                            <div class="dropdown-content-main" id="dropdown-main-rate-contract-critical" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('When does the RC for Item X expire?')">When does the RC for Item X expire?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which RCs expire within 30/60/90 days?')">Which RCs expire within 30/60/90 days?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Items requiring immediate RC extension or fresh tendering.')">Items requiring immediate RC extension or fresh tendering.</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which RC vendors are under watch due to QC failures?')">Which RC vendors are under watch due to QC failures?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items need transition from old RC to new tender?')">Which items need transition from old RC to new tender?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which RC items have repeated supply delays?')">Which RC items have repeated supply delays?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Items needing emergency procurement due to RC-Tender gap.')">Items needing emergency procurement due to RC-Tender gap.</div>
                            </div>
                        </div>
                        <!-- Procurement Execution Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Procurement Execution (PO, Supply, Vendor Performance)</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-procurement-execution')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Track QC status, NSQ items, hold batches, and vendor performance</p>
                            <div class="dropdown-content-main" id="dropdown-main-procurement-execution" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Item-wise QC hold batches blocking supply.')">Item-wise QC hold batches blocking supply.</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Vendors whose QC failures are delaying supplies for tender/RC items.')">Vendors whose QC failures are delaying supplies for tender/RC items.</div>
                            </div>
                        </div>
                        <!-- High-Priority Exception & Alert Questions Prompt Card -->
                        <div class="prompt-card-main">
                            <div class="card-header-main">
                                <div class="card-icon"></div>
                                <h3 class="card-title">High-Priority Exception & Alert Questions</h3>
                                <button class="dropdown-toggle" aria-label="Toggle options" onclick="toggleMainCardDropdown(event, 'main-high-priority-exceptions')">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Identify critical shortages, stockout risks, and urgent procurement needs</p>
                            <div class="dropdown-content-main" id="dropdown-main-high-priority-exceptions" style="display: none;">
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items are in critical shortage despite an active tender/RC?')">Which items are in critical shortage despite an active tender/RC?</div>
                                <div class="dropdown-item-main" onclick="handleMainPromptClick('Which items are stuck due to tender delay + RC expiry overlap?')">Which items are stuck due to tender delay + RC expiry overlap?</div>
                            </div>
                        </div>
                    </div>

                <!-- Extended Prompt Cards (hidden by default) -->
                <div class="extended-prompt-cards hidden" id="extended-prompt-cards" style="display: none;">
                    <div class="extended-cards-grid">
                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Anomaly Detection</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Analyze and identify unusual patterns or behaviors</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me medicines expiring in 2025 that are below reorder level and from LifeLine Suppliers</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">which category has the most medicines expiring in 2025 and what is their total stock value</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me warehouses with medicines expiring in 2025, sorted by total expiring stock value</div>
                            </div>
                        </div>

                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Stock Analysis</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Investigate and analyze stock levels and patterns</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">tell me what medicines are going to be expired within 2025 year</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me medicines expiring in 2026</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me products with low stock</div>
                            </div>
                        </div>

                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Inventory Management</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Track and optimize inventory levels and distribution</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me warehouses with medicines expiring in 2025, sorted by total expiring stock value</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">which suppliers have medicines expiring in 2025 and what is the total value at risk</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">which products have multiple batches expiring in 2025 and what is the total stock across all batches</div>
                            </div>
                        </div>

                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Asset Management</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Optimize asset utilization and lifecycle management</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">which warehouses have the most medicines expiring in 2025</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me a bar graph of stock value of medicines expiring in 2025 by warehouse</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">what plants are in the system</div>
                            </div>
                        </div>

                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Visual Analytics</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Visualize data with charts and graphs</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me a bar chart of medicines expiring by month in 2025</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">create a bar chart showing expiring medicines by category in 2025</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">generate a pareto chart for medicines expiring in 2025 by stock value</div>
                            </div>
                        </div>

                        <div class="prompt-card-extended">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Data Summarization and Reporting</h3>
                                <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                    <i class="fa fa-chevron-down" style="color: #6B7280;"></i>
                                </button>
                            </div>
                            <p class="card-description">Generate comprehensive data summaries</p>
                            <div class="card-expanded-content">
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me summary of expiring medicines: count by category, total stock value, and average stock per medicine for 2025</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">show me medicines expiring in 2025 with their batch numbers, stock levels, and days until expiry</div>
                                <div class="prompt-option" onclick="insertPromptToSearch(this)">which products have multiple batches expiring in 2025 and what is the total stock across all batches</div>
                            </div>
                        </div>


                        <!-- Placeholder cards for 3x3 grid completion -->
                        <div class="prompt-card-extended placeholder-card" style="opacity: 0.3; pointer-events: none;">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Coming Soon</h3>
                    </div>
                            <p class="card-description">Additional features will be added here</p>
                        </div>

                        <div class="prompt-card-extended placeholder-card" style="opacity: 0.3; pointer-events: none;">
                            <div class="card-header-extended">
                                <div class="card-icon"></div>
                                <h3 class="card-title">Coming Soon</h3>
                            </div>
                            <p class="card-description">Additional features will be added here</p>
                </div>
            </div>

                    <!-- Keep original cards for compatibility -->
                
                <!-- Cards removed - now available in CGMSCL Prompt Gallery modal -->
                </div>
                </div>
            </div>

            <!-- Chat Area (hidden by default) -->
            <div class="chat-area has-header" id="chat-area" style="display: none;">
                <!-- Glassmorphism Header (appears on scroll) -->
                <div class="chat-glassmorphism-header" id="chat-glassmorphism-header">
                    <div class="chat-header-left">
                        <img src="/static/images/motherson2.png" alt="CGMSCL Logo" class="chat-header-logo">
                    </div>
                    <div class="chat-header-right">
                        <!-- Excel Download Button -->
                        <button class="excel-download-btn" id="excelDownloadButtonChat" aria-label="Download Excel Feedback" title="Download feedback as Excel file">
                            <img src="/static/images/excel.png" alt="Download Excel" style="width: 20px; height: 20px; object-fit: contain;">
                        </button>
                        
                        <button class="new-chat-btn" onclick="startNewChat()" aria-label="New Chat">
                            <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="size-5">
                                <mask id="mask0_chat" maskUnits="userSpaceOnUse" x="0" y="0" width="20" height="20" style="mask-type: alpha;">
                                    <path d="M19.7803 1.28033C20.0732 0.987435 20.0732 0.512561 19.7803 0.219669C19.4874 -0.0732238 19.0125 -0.0732228 18.7196 0.219671L8.71967 10.2197L8.25 11.75L9.78033 11.2803L19.7803 1.28033ZM4.25 1C2.45507 1 1 2.45508 1 4.25V15.75C1 17.5449 2.45507 19 4.25 19H15.75C17.5449 19 19 17.5449 19 15.75V7.75C19 7.33579 18.6642 7 18.25 7C17.8358 7 17.5 7.33579 17.5 7.75V15.75C17.5 16.7165 16.7165 17.5 15.75 17.5H4.25C3.2835 17.5 2.5 16.7165 2.5 15.75V4.25C2.5 3.2835 3.2835 2.5 4.25 2.5H12.25C12.6642 2.5 13 2.16421 13 1.75C13 1.33579 12.6642 1 12.25 1H4.25Z" fill="currentColor"></path>
                                </mask>
                                <g mask="url(#mask0_chat)">
                                    <rect width="24" height="24" transform="translate(-2 -2)" fill="currentColor"></rect>
                                </g>
                            </svg>
                        </button>
                        
                        <!-- Analysis Toggle Dropdown Button -->
                        <div class="analysis-toggle-dropdown">
                            <button class="analysis-toggle-btn" id="analysisToggleChat" onclick="toggleAnalysisMode()" aria-label="Toggle Analysis Mode">
                                <span class="toggle-text" id="analysisToggleTextChat">Analysis: OFF</span>
                                <span class="toggle-icon" id="analysisToggleIconChat"></span>
                            </button>
                        </div>
                        
                        <!-- <button class="chat-menu-btn" onclick="toggleChatMenu()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="1" fill="currentColor"/>
                                <circle cx="19" cy="12" r="1" fill="currentColor"/>
                                <circle cx="5" cy="12" r="1" fill="currentColor"/>
                            </svg>
                        </button> -->
                    </div>
                </div>
                <div class="chat-messages chat-container" id="chat-container">
                    <!-- Messages will be appended here -->
                </div>
                
                <!-- Floating Suggestions and Gallery Button Above Search Box -->
                <div class="floating-suggestions-container" data-floating="gallery-btn">
                    <div class="floating-suggestions-wrapper">
                        <button class="floating-gallery-btn" onclick="openPromptsModal()" title="Prompt Gallery" style="animation-delay: 0.4s;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="3" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="3" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Microsoft Copilot Style Chat Search Container -->
                <div class="chat-search-container">
                    <!-- Copilot-style input field -->
                    <input type="text" class="chat-search-input" id="user-input" placeholder="Type your message..." aria-label="Chat message input" autocomplete="off" spellcheck="true">
                    
                    <!-- Mic button -->
                    <button class="chat-button mic-button" type="button" aria-label="Voice input" title="Use voice input" id="mic-button">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2a3 3 0 0 1 3 3v6a3 3 0 0 1-6 0V5a3 3 0 0 1 3-3zM19 10v1a7 7 0 0 1-14 0v-1a1 1 0 0 1 2 0v1a5 5 0 0 0 10 0v-1a1 1 0 0 1 2 0z"/>
                            <path d="M12 18.5a1 1 0 0 1 0 2h-1a1 1 0 0 1 0-2h1z"/>
                        </svg>
                    </button>
                    
                    <!-- Text-to-speech button -->
                    <button class="chat-button tts-button" type="button" aria-label="Read response aloud" title="Read last response aloud" id="tts-button">
                        <svg id="tts-play-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                        <svg id="tts-stop-icon" style="display: none;" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 9v6h4l5 5V4L7 9H3z"/>
                            <rect x="14" y="7" width="2" height="10" fill="currentColor"/>
                            <rect x="17" y="7" width="2" height="10" fill="currentColor"/>
                        </svg>
                    </button>
                    
                    <!-- Send button -->
                    <button class="chat-button send-button" type="button" aria-label="Send message" title="Send message" id="send-button" onclick="enqueueMessage()">
                        <svg id="send-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="m21.426 11.095-17-8A.999.999 0 0 0 3.03 4.242L4.969 12 3.03 19.758a.998.998 0 0 0 1.396 1.147l17-8a1 1 0 0 0 0-1.81zM5.481 18.197l.839-3.357L12 12 6.32 9.16l-.839-3.357L18.651 12l-13.17 6.197z"/>
                        </svg>
                        <svg id="stop-icon" style="display: none;" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                            <rect x="9" y="9" width="6" height="6" fill="currentColor" rx="1.5" ry="1.5"/>
                        </svg>
                    </button>
        </div>
        
        <!-- AI Disclaimer -->
        <div class="ai-disclaimer">
            <p><span style="float: left;">v 1.0.2 <br> [30 Sep 25']<br> </span>This is AI generated content which may or may not be correct</p>
        </div>
        </div>
            </div>
        </div>

        <!-- Floating Prompt Gallery Button -->
        <button id="chat-prompts-fab"
                title="CGMSCL Prompt Gallery"
                class="prompt-gallery-floating-btn"
                onclick="openPromptsModal()"
                aria-label="Open CGMSCL Prompt Gallery">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none">
                <path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    d="M12 2l1.8 4.6L18 8l-4.2 2.1L12 15l-1.8-4.9L6 8l4.2-1.4L12 2zM6 18l1-2 2-1-1 2-2 1zm10 2l-1.2-2.2L13 16l1.2 2.2L16 20z"/>
            </svg>
        </button>

        <!-- Old floating button (now unused) -->
        <button id="prompts-fab" style="display: none;">
        </button>
    </div>
    <script>
        // Authentication removed - no login required

        // Cards Functionality

        function hideCardsWithScatter() {
            const welcomeScreen = document.getElementById('welcome-screen');
            const chatArea = document.getElementById('chat-area');
            
            // Switch to chat view immediately
            if (welcomeScreen && chatArea) {
                welcomeScreen.style.display = 'none';
                chatArea.style.display = 'flex';
                
                // Show floating button in chat area
                toggleFloatingButton(true);
            }
        }

        // Card click handlers - Updated for Tender Management System
        const cardQueries = {
            'predictive-maintenance': "Show me all active tenders with their submission deadlines",
            'data-reporting': "Generate a summary report of tender distribution across all categories with a Pareto chart",
            'failure-analysis': "List all items with no bids in Cover A that need re-tendering",
            'inventory-management': "Show items in EDL 2025 with their rate contract status",
            'performance-metrics': "Find all rate contracts expiring in the next 30 days",
            'optimization': "Show tenders with most extensions and analyze the reasons",
            'anomaly-detection': "Identify items with valid rate contracts but no recent tender activity",
            'asset-management': "Show tender timeline and bid participation for Drugs category",
            'maintenance-scheduling': "List all AYUSH drugs with their tender status and rate contract validity"
        };

        function handleCardClick(cardType) {
            const query = cardQueries[cardType];
            if (query) {
                // Hide cards with scatter animation
                hideCardsWithScatter();
                
                // Wait for animation to complete, then send query
                setTimeout(() => {
                    const userInput = document.getElementById('user-input');
                    if (userInput) {
                        userInput.value = query;
                        // Auto-send the query
                        if (typeof enqueueMessage === 'function') {
                            enqueueMessage();
                        }
                    }
                }, 300);
            }
        }

        // Copy to clipboard functionality
        function copyToClipboard(buttonElement) {
            const messageElement = buttonElement.closest('.message');
            const messageText = messageElement.querySelector('.message-text').innerText || messageElement.querySelector('.message-text').textContent;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(messageText).then(() => {
                    showNotification('Copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    fallbackCopyToClipboard(messageText);
                });
            } else {
                fallbackCopyToClipboard(messageText);
            }
        }

        // Toggle Analysis dropdown functionality
        function toggleAnalysisDropdown(buttonElement) {
            const dropdown = buttonElement.parentElement;
            const content = dropdown.querySelector('.analysis-dropdown-content');
            
            // Close all other dropdowns first
            document.querySelectorAll('.analysis-dropdown-content.show').forEach(openDropdown => {
                if (openDropdown !== content) {
                    openDropdown.classList.remove('show');
                }
            });
            
            // Toggle current dropdown
            content.classList.toggle('show');
            
            // Close dropdown when clicking outside
            if (content.classList.contains('show')) {
                const closeDropdown = (event) => {
                    if (!dropdown.contains(event.target)) {
                        content.classList.remove('show');
                        document.removeEventListener('click', closeDropdown);
                    }
                };
                // Use setTimeout to prevent immediate closure
                setTimeout(() => {
                    document.addEventListener('click', closeDropdown);
                }, 100);
            }
        }

        // Toggle Analysis Mode functionality
        function toggleAnalysisMode() {
            // Get current state
            const isCurrentlyEnabled = sessionStorage.getItem('analysisModeEnabled') === 'true';
            const newState = !isCurrentlyEnabled;
            
            // Save new state to sessionStorage
            sessionStorage.setItem('analysisModeEnabled', newState.toString());
            
            // Update both buttons to show new state
            updateAnalysisToggleButtons(newState);
            
            // Apply global visibility control to ALL analysis sections
            toggleAllAnalysisSections(newState);
        }

        // Update analysis toggle buttons appearance
        function updateAnalysisToggleButtons(isEnabled) {
            const homeButton = document.getElementById('analysisToggleHome');
            const chatButton = document.getElementById('analysisToggleChat');
            const homeText = document.getElementById('analysisToggleTextHome');
            const chatText = document.getElementById('analysisToggleTextChat');
            const homeIcon = document.getElementById('analysisToggleIconHome');
            const chatIcon = document.getElementById('analysisToggleIconChat');
            
            if (isEnabled) {
                // ON State - Green
                if (homeButton) {
                    homeButton.className = 'analysis-toggle-btn on';
                    homeText.textContent = 'Analysis: ON';
                    homeIcon.textContent = '';
                }
                if (chatButton) {
                    chatButton.className = 'analysis-toggle-btn on';
                    chatText.textContent = 'Analysis: ON';
                    chatIcon.textContent = '';
                }
            } else {
                // OFF State - Gray
                if (homeButton) {
                    homeButton.className = 'analysis-toggle-btn off';
                    homeText.textContent = 'Analysis: OFF';
                    homeIcon.textContent = '';
                }
                if (chatButton) {
                    chatButton.className = 'analysis-toggle-btn off';
                    chatText.textContent = 'Analysis: OFF';
                    chatIcon.textContent = '';
                }
            }
        }

        // Toggle ALL analysis sections globally
        function toggleAllAnalysisSections(show) {
            // Find all analysis dropdown containers
            const analysisContainers = document.querySelectorAll('.analysis-dropdown');
            
            analysisContainers.forEach(container => {
                if (show) {
                    container.style.display = 'block';
                } else {
                    container.style.display = 'none';
                }
            });
        }

        // Update analysis panel data
        function updateAnalysisPanelData() {
            const queryList = document.getElementById('analysisQueryList');
            const totalQueriesEl = document.getElementById('totalQueries');
            const sqlQueriesEl = document.getElementById('sqlQueries');
            
            // Get stored analysis data from sessionStorage
            const analysisData = JSON.parse(sessionStorage.getItem('analysisData') || '[]');
            
            // Update statistics
            const totalQueries = analysisData.length;
            const sqlQueries = analysisData.filter(item => item.sql_query).length;
            
            totalQueriesEl.textContent = totalQueries;
            sqlQueriesEl.textContent = sqlQueries;
            
            // Update query list
            if (analysisData.length === 0) {
                queryList.innerHTML = '<p class="analysis-empty-state">No analysis queries yet. Start a conversation to see analysis data here.</p>';
            } else {
                const queryItems = analysisData.slice(-5).reverse().map((item, index) => {
                    const timestamp = formatTimestampForDisplay(item.timestamp);
                    const hasSql = item.sql_query ? '' : '';
                    return `
                        <div class="analysis-query-item" style="padding: 8px 12px; margin-bottom: 8px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #1F7246
;">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span>${hasSql}</span>
                                <span style="font-size: 12px; color: #6b7280;">${timestamp}</span>
                            </div>
                            <div style="font-size: 13px; color: #374151; line-height: 1.4;">
                                ${item.query.substring(0, 100)}${item.query.length > 100 ? '...' : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                queryList.innerHTML = queryItems;
            }
        }

        // Store analysis data when a query is processed
        function storeAnalysisData(query, sqlQuery = null) {
            const analysisData = JSON.parse(sessionStorage.getItem('analysisData') || '[]');
            
            analysisData.push({
                query: query,
                sql_query: sqlQuery,
                timestamp: new Date().toISOString()
            });
            
            // Keep only last 20 queries to prevent storage bloat
            if (analysisData.length > 20) {
                analysisData.splice(0, analysisData.length - 20);
            }
            
            sessionStorage.setItem('analysisData', JSON.stringify(analysisData));
        }

        // Apply current analysis toggle state to newly rendered message
        function applyAnalysisToggleStateToNewMessage() {
            const isEnabled = sessionStorage.getItem('analysisModeEnabled') === 'true';
            toggleAllAnalysisSections(isEnabled);
        }

        // Initialize analysis toggle state on page load
        function initializeAnalysisToggle() {
            // Check if analysis mode should be enabled from sessionStorage
            const isEnabled = sessionStorage.getItem('analysisModeEnabled') === 'true';
            
            // Update button appearances
            updateAnalysisToggleButtons(isEnabled);
            
            // Apply initial state to all analysis sections
            toggleAllAnalysisSections(isEnabled);
        }

        // Fallback copy function
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showNotification('Copied to clipboard!', 'success');
            } catch (err) {
                console.error('Fallback: Could not copy text: ', err);
                showNotification('Failed to copy to clipboard', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        // Feedback system functions
        function giveFeedback(buttonElement, rating) {
            const messageElement = buttonElement.closest('.message');
            const messageText = messageElement.querySelector('.message-text').innerText || messageElement.querySelector('.message-text').textContent;
            
            // Get the query from chat history (find the previous user message)
            const messages = Array.from(document.querySelectorAll('.message'));
            const currentIndex = messages.indexOf(messageElement);
            let query = 'Unknown query';
            let sqlQuery = null;
            
            // Look for the previous user message
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (messages[i].classList.contains('user-message')) {
                    query = messages[i].querySelector('.message-text').innerText || messages[i].querySelector('.message-text').textContent;
                    break;
                }
            }
            
            // First try to get SQL query from the specific message element's sql-query-code
            const sqlQueryElement = messageElement.querySelector('.sql-query-code');
            if (sqlQueryElement) {
                sqlQuery = sqlQueryElement.textContent.trim();
                console.log('Extracted SQL query from current message element:', sqlQuery);
            }
            
            // If not found in DOM, try to get from chat history
            if (!sqlQuery) {
                const chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
                const currentMessageIndex = chatHistory.findIndex(msg => 
                    msg.text === messageText && msg.role === 'assistant'
                );
                if (currentMessageIndex !== -1) {
                    const message = chatHistory[currentMessageIndex];
                    if (message.sql_query) {
                        sqlQuery = message.sql_query;
                        console.log('Extracted SQL query from chat history:', sqlQuery);
                    }
                }
            }
            
            let queryType = null;
            
            // Update button states
            const thumbsUpBtn = messageElement.querySelector('.thumbs-up-btn');
            const thumbsDownBtn = messageElement.querySelector('.thumbs-down-btn');
            
            // Reset both buttons
            thumbsUpBtn.classList.remove('active');
            thumbsDownBtn.classList.remove('active');
            
            // Set active state for clicked button
            if (rating === 'Thumbs Up') {
                thumbsUpBtn.classList.add('active');
            } else if (rating === 'Thumbs Down') {
                thumbsDownBtn.classList.add('active');
            }
            
            // Show feedback modal for additional comments
            showFeedbackModal(query, messageText, rating, sqlQuery);
        }

        // Show feedback modal
        function showFeedbackModal(query, response, rating, sqlQuery = null) {
            // Remove existing modal if any
            const existingModal = document.querySelector('.feedback-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // If sqlQuery is not provided, try to extract it from the CURRENT message's sql-query-code class
            if (!sqlQuery) {
                // Find the most recent message element (the one being rated)
                const messages = Array.from(document.querySelectorAll('.message'));
                const currentMessage = messages[messages.length - 1]; // Get the last message
                
                if (currentMessage) {
                    const sqlQueryElement = currentMessage.querySelector('.sql-query-code');
                    if (sqlQueryElement) {
                        sqlQuery = sqlQueryElement.textContent.trim();
                        console.log('Extracted SQL query from current message:', sqlQuery);
                    }
                }
                
                // Fallback: try to find any sql-query-code element
                if (!sqlQuery) {
                    const sqlQueryElement = document.querySelector('.sql-query-code');
                    if (sqlQueryElement) {
                        sqlQuery = sqlQueryElement.textContent.trim();
                        console.log('Extracted SQL query from any message (fallback):', sqlQuery);
                    }
                }
            }
            
            const modal = document.createElement('div');
            modal.className = 'feedback-modal';
            modal.innerHTML = `
                <div class="feedback-modal-content">
                    <h3>Feedback: ${rating}</h3>
                    <p>Thank you for your feedback! Would you like to add any additional comments?</p>
                    <textarea id="feedback-comment" placeholder="Optional: Add your comments here..."></textarea>
                    <div class="feedback-modal-buttons">
                        <button class="cancel-btn" id="cancel-feedback-btn">Cancel</button>
                        <button class="submit-btn" id="submit-feedback-btn">Submit Feedback</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners for buttons
            const cancelBtn = modal.querySelector('#cancel-feedback-btn');
            const submitBtn = modal.querySelector('#submit-feedback-btn');
            
            cancelBtn.addEventListener('click', () => {
                closeFeedbackModal();
            });
            
            submitBtn.addEventListener('click', () => {
                // Disable button and show loading state
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submitting...';
                
                submitFeedback(query, response, rating, sqlQuery).finally(() => {
                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Feedback';
                });
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeFeedbackModal();
                }
            });
        }

        // Close feedback modal
        function closeFeedbackModal() {
            const modal = document.querySelector('.feedback-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Submit feedback
        // Download Excel feedback file
        async function downloadExcelFeedback() {
            try {
                const response = await fetch('/feedback/download-excel');
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'chatbot_feedback.xlsx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    console.log('Excel file downloaded successfully');
                } else {
                    const error = await response.json();
                    showNotification('Failed to download Excel file: ' + (error.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error downloading Excel file:', error);
                showNotification('Failed to download Excel file. Please try again.', 'error');
            }
        }

        async function submitFeedback(query, response, rating, sqlQuery = null) {
            const comment = document.getElementById('feedback-comment').value;
            
            // If sqlQuery is not provided, try to extract it from the CURRENT message
            if (!sqlQuery) {
                const messages = Array.from(document.querySelectorAll('.message'));
                const currentMessage = messages[messages.length - 1]; // Get the last message
                
                if (currentMessage) {
                    const sqlQueryElement = currentMessage.querySelector('.sql-query-code');
                    if (sqlQueryElement) {
                        sqlQuery = sqlQueryElement.textContent.trim();
                        console.log('Extracted SQL query from current message:', sqlQuery);
                    }
                }
                
                // Fallback: try to find any sql-query-code element
                if (!sqlQuery) {
                    const sqlQueryElement = document.querySelector('.sql-query-code');
                    if (sqlQueryElement) {
                        sqlQuery = sqlQueryElement.textContent.trim();
                        console.log('Extracted SQL query from any message (fallback):', sqlQuery);
                    }
                }
            }
            
            console.log('Submitting feedback:', { query, response, rating, comment, sqlQuery });
            
            try {
                // Use enhanced feedback system if available
                if (typeof submitEnhancedFeedback === 'function') {
                    console.log('Using enhanced feedback system');
                    await submitEnhancedFeedback(query, response, rating, comment, sqlQuery);
                    closeFeedbackModal();
                } else {
                    console.log('Using fallback feedback system');
                    // Fallback to basic feedback
                    const feedbackData = {
                        query: query,
                        response: response,
                        rating: rating,
                        comment: comment || null,
                        sql_query: sqlQuery || ""
                    };
                    
                    const response_obj = await fetch('/feedback', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(feedbackData)
                    });
                    
                    if (response_obj.ok) {
                        const result = await response_obj.json();
                        showNotification('Feedback submitted successfully!', 'success');
                        closeFeedbackModal();
                    } else {
                        const error = await response_obj.json();
                        showNotification('Failed to submit feedback: ' + (error.detail || 'Unknown error'), 'error');
                    }
                }
            } catch (error) {
                console.error('Error submitting feedback:', error);
                showNotification('Failed to submit feedback. Please try again.', 'error');
            }
        }

        // Enhanced feedback system functions
        let sessionId = null;
        let lastDownloadedFormat = null;
        let responseStartTime = null;

        // Generate session ID
        function generateSessionId() {
            if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                sessionStorage.setItem('sessionId', sessionId);
            }
            return sessionId;
        }

        // Track response time
        function startResponseTimer() {
            responseStartTime = performance.now();
        }

        function getResponseTime() {
            if (responseStartTime) {
                return (performance.now() - responseStartTime) / 1000; // Convert to seconds
            }
            return 0;
        }

        // Track downloaded file formats
        function trackDownload(format) {
            lastDownloadedFormat = format;
            localStorage.setItem('lastDownloadedFormat', format);
        }

        function getLastDownloadedFormat() {
            return localStorage.getItem('lastDownloadedFormat') || null;
        }

        // Enhanced feedback submission with tracking
        async function submitEnhancedFeedback(query, response, rating, comment = null, sqlQuery = null) {
            try {
                const feedbackData = {
                    query: query,
                    response: response,
                    rating: rating,
                    comment: comment,
                    sql_query: sqlQuery || "",
                    session_id: generateSessionId(),
                    response_time: getResponseTime(),
                    file_format_downloaded: getLastDownloadedFormat(),
                    query_type: detectQueryType(query)
                };
                
                const response_obj = await fetch('/feedback/enhanced', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(feedbackData)
                });
                
                if (response_obj.ok) {
                    const result = await response_obj.json();
                    showNotification('Enhanced feedback submitted successfully!', 'success');
                    return result;
                } else {
                    const error = await response_obj.json();
                    showNotification('Failed to submit enhanced feedback: ' + (error.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error submitting enhanced feedback:', error);
                showNotification('Failed to submit enhanced feedback. Please try again.', 'error');
            }
        }

        // Detect query type based on content
        function detectQueryType(query) {
            const lowerQuery = query.toLowerCase();
            
            if (lowerQuery.includes('sql') || lowerQuery.includes('query') || lowerQuery.includes('select') || 
                lowerQuery.includes('from') || lowerQuery.includes('where') || lowerQuery.includes('join')) {
                return 'SQL Query';
            } else if (lowerQuery.includes('chart') || lowerQuery.includes('graph') || lowerQuery.includes('plot') || 
                       lowerQuery.includes('visualize') || lowerQuery.includes('visualization')) {
                return 'Data Visualization';
            } else if (lowerQuery.includes('analyze') || lowerQuery.includes('analysis') || 
                       lowerQuery.includes('statistics') || lowerQuery.includes('summary')) {
                return 'Data Analysis';
            } else if (lowerQuery.includes('download') || lowerQuery.includes('export') || 
                       lowerQuery.includes('pdf') || lowerQuery.includes('file')) {
                return 'File Download';
            } else {
                return 'General Query';
            }
        }

        // Export feedback data
        async function exportFeedbackData(format = 'excel') {
            try {
                showNotification(`Exporting feedback data as ${format.toUpperCase()}...`, 'info');
                
                const response = await fetch(`/feedback/export?format_type=${format}&include_stats=true`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `feedback_export_${new Date().toISOString().replace(/[:.]/g, '-')}.${format === 'excel' ? 'xlsx' : format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    showNotification('Feedback data exported successfully!', 'success');
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting feedback:', error);
                showNotification('Failed to export feedback data.', 'error');
            }
        }

        // Get feedback analytics
        async function getFeedbackAnalytics() {
            try {
                const response = await fetch('/feedback/analytics');
                if (response.ok) {
                    const analytics = await response.json();
                    displayAnalytics(analytics);
                } else {
                    throw new Error('Failed to get analytics');
                }
            } catch (error) {
                console.error('Error getting analytics:', error);
                showNotification('Failed to get feedback analytics.', 'error');
            }
        }

        // Display analytics in a modal
        function displayAnalytics(analytics) {
            const modal = document.createElement('div');
            modal.className = 'analytics-modal';
            modal.innerHTML = `
                <div class="analytics-modal-content">
                    <h3>Feedback Analytics Dashboard</h3>
                    <div class="analytics-grid">
                        <div class="analytics-card">
                            <h4>Overall Statistics</h4>
                            <p>Total Entries: ${analytics.total_entries || 0}</p>
                            <p>Thumbs Up: ${analytics.thumbs_up || 0}</p>
                            <p>Thumbs Down: ${analytics.thumbs_down || 0}</p>
                            <p>Satisfaction Rate: ${analytics.satisfaction_rate ? analytics.satisfaction_rate.toFixed(1) : 0}%</p>
                        </div>
                        <div class="analytics-card">
                            <h4>Response Metrics</h4>
                            <p>Avg Response Time: ${analytics.average_response_time ? analytics.average_response_time.toFixed(2) : 0}s</p>
                            <p>Avg Response Length: ${analytics.average_response_length ? analytics.average_response_length.toFixed(0) : 0} chars</p>
                            <p>With Comments: ${analytics.with_comments || 0}</p>
                        </div>
                        <div class="analytics-card">
                            <h4>Download Statistics</h4>
                            ${Object.keys(analytics.download_stats || {}).length > 0 ? 
                                Object.entries(analytics.download_stats).map(([format, count]) => 
                                    `<p>${format}: ${count}</p>`
                                ).join('') : 
                                '<p>No downloads recorded</p>'
                            }
                        </div>
                        <div class="analytics-card">
                            <h4>Query Types</h4>
                            ${Object.keys(analytics.query_type_stats || {}).length > 0 ? 
                                Object.entries(analytics.query_type_stats).map(([type, count]) => 
                                    `<p>${type}: ${count}</p>`
                                ).join('') : 
                                '<p>No query type data</p>'
                            }
                        </div>
                    </div>
                    ${analytics.improvement_suggestions && analytics.improvement_suggestions.length > 0 ? 
                        `<div class="analytics-card">
                            <h4>Improvement Suggestions</h4>
                            <ul>
                                ${analytics.improvement_suggestions.map(suggestion => 
                                    `<li>${suggestion}</li>`
                                ).join('')}
                            </ul>
                        </div>` : ''
                    }
                    <div class="analytics-modal-buttons">
                        <button class="export-btn" onclick="exportFeedbackData('excel')">Export Excel</button>
                        <button class="export-btn" onclick="exportFeedbackData('csv')">Export CSV</button>
                        <button class="export-btn" onclick="exportFeedbackData('json')">Export JSON</button>
                        <button class="cancel-btn" onclick="closeAnalyticsModal()">Close</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeAnalyticsModal();
                }
            });
        }

        // Close analytics modal
        function closeAnalyticsModal() {
            const modal = document.querySelector('.analytics-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Enhanced download function with tracking
        async function downloadFileWithTracking(query, response, format) {
            try {
                showNotification(`Generating ${format.toUpperCase()} file...`, 'info');
                
                // Track the download
                trackDownload(format);
                
                const downloadData = {
                    response: response,
                    file_format: format
                };
                
                const response_obj = await fetch('/download-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(downloadData)
                });
                
                if (response_obj.ok) {
                    const blob = await response_obj.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `response_${new Date().toISOString().replace(/[:.]/g, '-')}.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    showNotification(`${format.toUpperCase()} file downloaded successfully!`, 'success');
                } else {
                    const error = await response_obj.json();
                    showNotification('Failed to download file: ' + (error.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error downloading file:', error);
                showNotification('Failed to download file. Please try again.', 'error');
            }
        }

        // Initialize enhanced features
        function initializeEnhancedFeatures() {
            generateSessionId();
        }

        // Call initialization when page loads
        document.addEventListener('DOMContentLoaded', initializeEnhancedFeatures);

        // Function to enable download button after charts are rendered
        function enableDownloadButtonAfterCharts(messageDiv) {
            console.log('enableDownloadButtonAfterCharts called');
            const downloadBtn = messageDiv.querySelector('.download-btn');
            if (!downloadBtn) {
                console.log('No download button found');
                return;
            }
            
            console.log('Download button found, checking for charts...');
            
            // Check if there are any charts in this message
            const chartContainers = messageDiv.querySelectorAll('[id^="chart-"], [id^="echarts-chart-"]');
            console.log('Chart containers found:', chartContainers.length);
            
            if (chartContainers.length === 0) {
                // No charts, enable immediately
                console.log('No charts found, enabling download button immediately');
                downloadBtn.disabled = false;
                downloadBtn.style.opacity = '1';
                downloadBtn.style.cursor = 'pointer';
                downloadBtn.title = 'Download file';
                console.log('Button state after immediate enabling:', { disabled: downloadBtn.disabled, opacity: downloadBtn.style.opacity, cursor: downloadBtn.style.cursor });
                return;
            }
            
            // Wait for charts to be fully rendered
            let attempts = 0;
            const maxAttempts = 20; // 10 seconds max wait
            
            const checkChartsReady = () => {
                attempts++;
                console.log(`Checking charts ready, attempt ${attempts}/${maxAttempts}`);
                
                let allChartsReady = true;
                chartContainers.forEach((container, index) => {
                    const chartInstance = echarts.getInstanceByDom(container);
                    console.log(`Chart ${index} (${container.id}):`, chartInstance ? 'ready' : 'not ready');
                    if (!chartInstance) {
                        allChartsReady = false;
                    }
                });
                
                if (allChartsReady || attempts >= maxAttempts) {
                    // Enable download button
                    console.log('All charts ready or max attempts reached, enabling download button');
                    downloadBtn.disabled = false;
                    downloadBtn.style.opacity = '1';
                    downloadBtn.style.cursor = 'pointer';
                    downloadBtn.title = 'Download file';
                    console.log('Download button enabled after chart rendering');
                    console.log('Button state after enabling:', { disabled: downloadBtn.disabled, opacity: downloadBtn.style.opacity, cursor: downloadBtn.style.cursor });
                } else {
                    // Check again in 500ms
                    console.log('Charts not ready yet, checking again in 500ms...');
                    setTimeout(checkChartsReady, 500);
                }
            };
            
            // Start checking after a short delay
            console.log('Starting chart readiness check in 1 second...');
            setTimeout(checkChartsReady, 1000);
            
            // Fallback: Enable button after 15 seconds regardless of chart status
            setTimeout(() => {
                if (downloadBtn.disabled) {
                    console.log('Fallback: Enabling download button after timeout');
                    downloadBtn.disabled = false;
                    downloadBtn.style.opacity = '1';
                    downloadBtn.style.cursor = 'pointer';
                    downloadBtn.title = 'Download file';
                    console.log('Button state after fallback enabling:', { disabled: downloadBtn.disabled, opacity: downloadBtn.style.opacity, cursor: downloadBtn.style.cursor });
                }
            }, 15000);
        }

        // Download system functions
        async function downloadPDFDirect(buttonElement) {
            console.log('downloadPDFDirect called, button disabled:', buttonElement.disabled);
            
            // Check if download button is disabled
            if (buttonElement.disabled) {
                console.log('Button is disabled, showing notification');
                showNotification('Please wait for charts to finish loading before downloading...', 'info');
                return;
            }
            
            console.log('Button is enabled, proceeding with download');
            
            const messageElement = buttonElement.closest('.message');
            const messageText = messageElement.querySelector('.message-text').innerText || messageElement.querySelector('.message-text').textContent;
            
            console.log('Message text length:', messageText ? messageText.length : 0);
            
            // Get the query from chat history
            const messages = Array.from(document.querySelectorAll('.message'));
            const currentIndex = messages.indexOf(messageElement);
            let query = 'Unknown query';
            
            // Look for the previous user message
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (messages[i].classList.contains('user-message')) {
                    query = messages[i].querySelector('.message-text').innerText || messages[i].querySelector('.message-text').textContent;
                    break;
                }
            }
            
            console.log('Query found:', query);
            
            // Capture chart data at download time
            let chartData = null;
            const chartContainer = messageElement.querySelector('[id^="chart-"]');
            if (chartContainer) {
                try {
                    console.log('Attempting to capture chart from container:', chartContainer.id);
                    
                    // Wait a moment to ensure chart is fully rendered
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const chartInstance = echarts.getInstanceByDom(chartContainer);
                    if (chartInstance) {
                        console.log('Chart instance found, generating image...');
                        chartData = chartInstance.getDataURL({
                            type: 'png',
                            pixelRatio: 2,
                            backgroundColor: '#ffffff',
                            excludeComponents: ['toolbox', 'brush']
                        });
                        console.log('Chart captured successfully, length:', chartData ? chartData.length : 0);
                    } else {
                        console.log('No chart instance found for container:', chartContainer.id);
                    }
                } catch (error) {
                    console.error('Error capturing chart data:', error);
                }
            } else {
                console.log('No chart container found in message');
            }
            
            console.log('Calling downloadFile with query, response, pdf, chartData');
            // Call the download function directly for PDF
            await downloadFile(query, messageText, 'pdf', chartData);
        }

        function showDownloadMenu(buttonElement) {
            // Check if download button is disabled
            if (buttonElement.disabled) {
                showNotification('Please wait for charts to finish loading before downloading...', 'info');
                return;
            }
            
            // Remove existing menu if any
            const existingMenu = document.querySelector('.download-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const messageElement = buttonElement.closest('.message');
            const messageText = messageElement.querySelector('.message-text').innerText || messageElement.querySelector('.message-text').textContent;
            
            // Get the query from chat history
            const messages = Array.from(document.querySelectorAll('.message'));
            const currentIndex = messages.indexOf(messageElement);
            let query = 'Unknown query';
            
            // Look for the previous user message
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (messages[i].classList.contains('user-message')) {
                    query = messages[i].querySelector('.message-text').innerText || messages[i].querySelector('.message-text').textContent;
                    break;
                }
            }
            
            // Store message element for later chart capture
            const chartContainer = messageElement.querySelector('[id^="chart-"]');
            
            const menu = document.createElement('div');
            menu.className = 'download-menu';
            
            // Only PDF download option
            const downloadOptions = [
                {
                    label: 'Download as PDF',
                    format: 'pdf',
                    icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14,2 14,8 20,8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>'
                }
            ];
            
            downloadOptions.forEach(option => {
                const item = document.createElement('div');
                item.className = 'download-menu-item';
                item.innerHTML = `
                    ${option.icon}
                    ${option.label}
                `;
                
                item.addEventListener('click', async () => {
                    // Capture chart data at download time
                    let chartData = null;
                    if (chartContainer) {
                        try {
                            console.log('Attempting to capture chart from container:', chartContainer.id);
                            
                            // Wait a moment to ensure chart is fully rendered
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            const chartInstance = echarts.getInstanceByDom(chartContainer);
                            if (chartInstance) {
                                console.log('Chart instance found, generating image...');
                                chartData = chartInstance.getDataURL({
                                    type: 'png',
                                    pixelRatio: 2,
                                    backgroundColor: '#ffffff',
                                    excludeComponents: ['toolbox', 'brush']
                                });
                                console.log('Chart captured successfully, length:', chartData ? chartData.length : 0);
                            } else {
                                console.log('No chart instance found for container:', chartContainer.id);
                            }
                        } catch (error) {
                            console.error('Error capturing chart data:', error);
                        }
                    } else {
                        console.log('No chart container found in message');
                    }
                    
                    await downloadFile(query, messageText, option.format, chartData);
                    menu.remove();
                });
                
                menu.appendChild(item);
            });
            
            // Position menu relative to button
            const buttonRect = buttonElement.getBoundingClientRect();
            menu.style.position = 'fixed';
            menu.style.top = (buttonRect.bottom + 5) + 'px';
            menu.style.left = (buttonRect.right - 180) + 'px';
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target) && e.target !== buttonElement) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 100);
        }

        // Download Excel file function
        async function downloadExcelFile(fileId) {
            try {
                console.log('downloadExcelFile called with fileId:', fileId);
                showNotification('Downloading Excel file...', 'info');
                
                const response = await fetch(`/download-excel/${fileId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to download Excel file: ${response.statusText}`);
                }
                
                // Get the blob from the response
                const blob = await response.blob();
                
                // Create a download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `CGMSCL_Query_Results_${new Date().toISOString().replace(/[:.]/g, '-')}.xlsx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showNotification('Excel file downloaded successfully!', 'success');
                console.log('Excel file downloaded successfully');
            } catch (error) {
                console.error('Error downloading Excel file:', error);
                showNotification('Failed to download Excel file: ' + error.message, 'error');
            }
        }

        // Download file function
        async function downloadFile(query, response, format, chartData = null) {
            try {
                console.log('downloadFile called with:', { query: query?.substring(0, 50), response: response?.substring(0, 50), format, chartData: chartData ? 'present' : 'null' });
                showNotification(`Generating PDF file...`, 'info');
                
                const downloadData = {
                    query: query,
                    response: response,
                    file_format: "pdf",
                    chart_data: chartData
                };
                
                console.log('Sending download request to /download-file');
                // Download PDF file
                const response_obj = await fetch('/download-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(downloadData)
                });
                
                console.log('Response status:', response_obj.status);
                
                if (response_obj.ok) {
                    console.log('Response OK, creating blob');
                    const blob = await response_obj.blob();
                    console.log('Blob created, size:', blob.size);
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `KPI_HR_Report_${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    showNotification(`PDF file downloaded successfully!`, 'success');
                    console.log('Download completed successfully');
                } else {
                    console.log('Response not OK, getting error details');
                    const error = await response_obj.json();
                    console.error('Download error:', error);
                    showNotification('Failed to download PDF: ' + (error.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error downloading PDF:', error);
                showNotification('Failed to download PDF. Please try again.', 'error');
            }
        }

        // Notification system
        function showNotification(message, type = 'info') {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => notification.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            // Hide notification after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showNotification('Copied to clipboard!', 'success');
            } catch (err) {
                console.error('Fallback: Could not copy text: ', err);
                showNotification('Failed to copy to clipboard', 'error');
            }
            
            document.body.removeChild(textArea);
        }


        // Dropdown functionality
        function toggleDropdown(event, dropdownId) {
            event.stopPropagation(); // Prevent card click

            const dropdown = document.getElementById('dropdown-' + dropdownId);
            const arrow = event.target.closest('.dropdown-toggle');
            const card = arrow.closest('.ai-card');

            if (dropdown && card) {
                // Check if current dropdown is already open
                const isCurrentlyOpen = card.classList.contains('active');
                
                // Close all dropdowns first - only target cards in the main grid
                const allCards = document.querySelectorAll('.cards-grid .ai-card');
                allCards.forEach(c => c.classList.remove('active'));
                
                // If current dropdown was not open, open it
                if (!isCurrentlyOpen) {
                    card.classList.add('active');
                }
            }
        }

        // Initialize dropdown states
        function initializeDropdowns() {
            const allCards = document.querySelectorAll('.cards-grid .ai-card');
            allCards.forEach(card => {
                card.classList.remove('active');
                const dropdown = card.querySelector('.dropdown-content');
                const arrow = card.querySelector('.dropdown-toggle');
                if (dropdown) dropdown.style.display = 'none';
                if (arrow) arrow.classList.remove('rotated');
            });
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeDropdowns();
        });

        function handlePromptClick(event, promptText) {
            event.stopPropagation();
            if (typeof promptText === 'string' && promptText.trim().length > 0) {
                pasteIntoChatInput(promptText.trim());
            }
        }

        function toggleMoreCategories() {
            const additionalCategories = document.getElementById('additional-categories');
            const showMoreButton = document.getElementById('show-more-button');
            const arrow = showMoreButton.querySelector('.show-more-arrow');

            if (additionalCategories) {
                if (additionalCategories.style.display === 'none' || additionalCategories.style.display === '') {
                    additionalCategories.style.display = 'grid';
                    additionalCategories.classList.add('show');
                    showMoreButton.querySelector('span').textContent = 'Show Less Categories';
                    if (arrow) arrow.classList.add('rotated');
                } else {
                    additionalCategories.style.display = 'none';
                    additionalCategories.classList.remove('show');
                    showMoreButton.querySelector('span').textContent = 'Show More Categories';
                    if (arrow) arrow.classList.remove('rotated');
                }
            }
        }

        // Function to add suggested prompts after a response using dynamic suggestions from chat response
        function addSuggestedPrompts(suggestions) {
            // Remove any existing suggested prompts
            const existingPrompts = document.querySelector('.suggested-prompts');
            if (existingPrompts) {
                existingPrompts.remove();
            }

            // Use the dynamic suggestions from the chat response
            if (suggestions && Array.isArray(suggestions) && suggestions.length > 0) {
                const suggestedPromptsDiv = document.createElement('div');
                suggestedPromptsDiv.className = 'suggested-inline';
                
                suggestedPromptsDiv.innerHTML = `
                    <div class="suggested-prompts-list">
                        ${suggestions.map(suggestion => 
                            `<button class="suggested-prompt-btn" onclick="handleSuggestedPromptClick('${suggestion.replace(/'/g, "\\'")}')">${suggestion}</button>`
                        ).join('')}
                        <button class="chat-prompt-gallery-btn" onclick="openPromptsModal()" title="Prompt Gallery">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="3" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="3" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="14" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="3" y="14" width="7" height="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                `;
                
                // Add to the last bot message (always at the end, after any charts)
                const lastBotMessage = document.querySelector('.bot-message:last-child');
                if (lastBotMessage) {
                    // Remove any existing suggestion prompts first
                    const existingSuggestions = lastBotMessage.querySelector('.suggested-inline');
                    if (existingSuggestions) {
                        existingSuggestions.remove();
                    }
                    
                    // Always append suggestions at the end of the bot message
                    lastBotMessage.appendChild(suggestedPromptsDiv);
                    scrollToBottom();
                }
            }
        }

        // Function to handle suggested prompt clicks
        function handleSuggestedPromptClick(promptText) {
            pasteIntoChatInput(promptText);
        }

        // Debug function to check DOM structure
        function debugDOMStructure() {
            console.log('=== DOM DEBUG ===');
            const allMessages = document.querySelectorAll('[class*="message"], [class*="bot"]');
            console.log('Found', allMessages.length, 'message elements:');
            allMessages.forEach((msg, i) => {
                console.log(`${i}: ${msg.className} - ${msg.tagName}`);
            });
            
            const chatContainer = document.querySelector('#chat-container');
            console.log('Chat container found:', !!chatContainer);
            if (chatContainer) {
                console.log('Chat container children:', chatContainer.children.length);
            }
            console.log('=== END DEBUG ===');
        }

        // Function to render ECharts charts (all chart types)
        function renderEChartsChart(chartConfig) {
            try {
                console.log('Rendering ECharts chart with config:', chartConfig);
                
                // Create chart container
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container echarts-chart';
                chartContainer.style.cssText = `
                    margin: 15px 0 10px 0;
                    padding: 15px;
                    background: #f8f9fa;
                    border-radius: 8px;
                    border: 1px solid #e9ecef;
                    width: 100%;
                    max-width: 100%;
                    position: relative;
                    height: 420px;
                    box-sizing: border-box;
                `;

                // Create chart header with download button
                const chartHeader = document.createElement('div');
                chartHeader.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 10px;
                    padding-bottom: 8px;
                    border-bottom: 1px solid #e9ecef;
                `;

                const chartTitle = document.createElement('div');
                chartTitle.style.cssText = `
                    font-weight: 600;
                    color: #495057;
                    font-size: 14px;
                `;
                chartTitle.textContent = chartConfig.title?.text || 'Chart';

                const downloadButton = document.createElement('button');
                downloadButton.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Download PDF with Chart
                `;
                downloadButton.style.cssText = `
                    display: none; /* Initially hidden until chart is ready */
                    align-items: center;
                    gap: 5px;
                    padding: 6px 12px;
                    background: #1F7246
;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                    margin-right: 4px;
                `;
                downloadButton.onmouseover = () => downloadButton.style.background = '#2D5016';
                downloadButton.onmouseout = () => downloadButton.style.background = '#1F7246';

                // Create Download Chart button
                const downloadChartButton = document.createElement('button');
                downloadChartButton.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21,15 16,10 5,21"/>
                    </svg>
                    Download Chart
                `;
                downloadChartButton.style.cssText = `
                    display: none; /* Initially hidden until chart is ready */
                    align-items: center;
                    gap: 5px;
                    padding: 6px 12px;
                    background: #1F7246
;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                `;
                downloadChartButton.onmouseover = () => downloadChartButton.style.background = '#2D5016';
                downloadChartButton.onmouseout = () => downloadChartButton.style.background = '#1F7246';

                chartHeader.appendChild(chartTitle);
                chartHeader.appendChild(downloadButton);
                chartHeader.appendChild(downloadChartButton);
                chartContainer.appendChild(chartHeader);

                // Create ECharts chart div
                const echartsDiv = document.createElement('div');
                echartsDiv.id = `echarts-chart-${Date.now()}`;
                echartsDiv.style.cssText = `
                    width: 100%;
                    height: 350px;
                    position: relative;
                `;
                chartContainer.appendChild(echartsDiv);

                // Find the appropriate container and insert chart before suggestion prompts
                const lastBotMessage = document.querySelector('.bot-message:last-child');
                const lastMessageBubble = document.querySelector('.message-bubble:last-child .message-content') ||
                                  document.querySelector('.bot-message:last-child') ||
                                  document.querySelector('.message:last-child');
                
                if (lastBotMessage) {
                    // Check if there are existing suggestion prompts
                    const existingSuggestions = lastBotMessage.querySelector('.suggested-inline');
                    
                    if (existingSuggestions) {
                        // Insert chart before the suggestion prompts
                        lastBotMessage.insertBefore(chartContainer, existingSuggestions);
                        console.log('ECharts chart container inserted before suggestion prompts');
                    } else if (lastMessageBubble) {
                        // No suggestions yet, append to message content
                        lastMessageBubble.appendChild(chartContainer);
                        console.log('ECharts chart container appended to message content');
                } else {
                        // Fallback: append to bot message
                        lastBotMessage.appendChild(chartContainer);
                        console.log('ECharts chart container appended to bot message (fallback)');
                    }
                } else {
                    console.error('Could not find suitable container for ECharts chart');
                    return;
                }

                // Check if ECharts is loaded
                if (typeof echarts === 'undefined') {
                    console.warn('ECharts is not loaded yet, waiting...');
                    echartsDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;">Loading chart...</div>';
                    
                    let attempts = 0;
                    const checkECharts = setInterval(() => {
                        attempts++;
                        if (typeof echarts !== 'undefined') {
                            clearInterval(checkECharts);
                            console.log('ECharts loaded successfully after', attempts * 100, 'ms');
                            createEChartsInstance();
                        } else if (attempts > 200) { // 20 seconds timeout
                            clearInterval(checkECharts);
                            console.error('ECharts failed to load after 20 seconds');
                            // Try to reload ECharts
                            const script = document.createElement('script');
                            script.src = 'https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js';
                            script.onload = () => {
                                console.log('ECharts reloaded successfully');
                                createEChartsInstance();
                            };
                            script.onerror = () => {
                                echartsDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #d32f2f;">Failed to load ECharts library. Please refresh the page.</div>';
                            };
                            document.head.appendChild(script);
                        }
                    }, 100);
                } else {
                    createEChartsInstance();
                }

                function createEChartsInstance() {
                    try {
                        // Validate chartConfig before proceeding
                        if (!chartConfig || typeof chartConfig !== 'object') {
                            console.error('Invalid chartConfig passed to createEChartsInstance:', chartConfig);
                            echartsDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #d32f2f;">Error: Invalid chart configuration</div>';
                            return;
                        }
                        
                        // Initialize ECharts instance
                        const chart = echarts.init(echartsDiv);
                        
                        // Remove type field from config before passing to ECharts
                        const echartsConfig = { ...chartConfig };
                        delete echartsConfig.type;
                        
                        // Validate and fix chart config structure
                        if (!echartsConfig.series || !Array.isArray(echartsConfig.series) || echartsConfig.series.length === 0) {
                            console.error('Invalid chart config: missing or empty series array', echartsConfig);
                            echartsDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #d32f2f;">Error: Invalid chart configuration - no data series found</div>';
                            return;
                        }
                        
                        // Filter out null/undefined elements first
                        echartsConfig.series = echartsConfig.series.filter(s => s != null && typeof s === 'object');
                        
                        if (echartsConfig.series.length === 0) {
                            console.error('Invalid chart config: all series elements are null/undefined');
                            echartsDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #d32f2f;">Error: Invalid chart configuration - no valid data series</div>';
                            return;
                        }
                        
                        // Ensure all series have required properties
                        echartsConfig.series = echartsConfig.series.map((s, idx) => {
                            // Double-check that s is a valid object (defensive programming)
                            if (!s || typeof s !== 'object') {
                                console.warn(`Series at index ${idx} is invalid, creating default series`);
                                return {
                                    name: `Series ${idx + 1}`,
                                    type: 'bar',
                                    data: []
                                };
                            }
                            
                            // Ensure name property exists and is a string
                            if (s.name === undefined || s.name === null || typeof s.name !== 'string') {
                                s.name = String(s.name || `Series ${idx + 1}`);
                            } else {
                                s.name = String(s.name);
                            }
                            
                            // Ensure type property exists
                            if (!s.type || typeof s.type !== 'string') {
                                s.type = s.type || 'bar';
                            }
                            
                            // Ensure data is an array
                            if (!Array.isArray(s.data)) {
                                s.data = [];
                            }
                            
                            // Ensure data values are valid numbers
                            // Also handle formatted numbers with commas (e.g., "165,627.00")
                            s.data = s.data.map((val, i) => {
                                // Convert value to string and strip commas if present
                                const asString = (val !== null && val !== undefined) ? String(val) : '';
                                const cleaned = asString.replace(/,/g, '');
                                const num = parseFloat(cleaned);
                                return isNaN(num) ? 0 : num;
                            });
                            
                            return s;
                        });
                        
                        // Comprehensive validation: Ensure all series have names and legend matches
                        if (echartsConfig.series && echartsConfig.series.length > 0) {
                            // First, ensure all series have valid names
                            echartsConfig.series = echartsConfig.series.map((s, idx) => {
                                if (!s || typeof s !== 'object') {
                                    return {
                                        name: `Series ${idx + 1}`,
                                        type: 'bar',
                                        data: []
                                    };
                                }
                                // Ensure name exists and is a valid string
                                if (!s.name || typeof s.name !== 'string' || s.name.trim() === '') {
                                    s.name = `Series ${idx + 1}`;
                                } else {
                                    // Ensure name is a proper string (convert if needed)
                                    s.name = String(s.name).trim();
                                }
                                return s;
                            });
                            
                            // Now rebuild legend data from series names
                            // Accept any non-empty string, including numeric strings like "2025"
                            const seriesNames = echartsConfig.series
                                .map((s, idx) => {
                                    // Defensive check: ensure s exists and has name property
                                    if (s && typeof s === 'object' && s.name !== undefined && s.name !== null) {
                                        const nameStr = String(s.name).trim();
                                        // Accept any non-empty string (including "0", "2025", etc.)
                                        if (nameStr !== '' && nameStr !== 'null' && nameStr !== 'undefined') {
                                            return nameStr;
                                        }
                                    }
                                    return `Series ${idx + 1}`;
                                })
                                .filter(n => n && n !== null && n !== undefined && n !== '' && n !== 'null' && n !== 'undefined');
                            
                            // Ensure legend exists and matches series
                            if (!echartsConfig.legend) {
                                echartsConfig.legend = {};
                            }
                            if (seriesNames.length > 0) {
                                echartsConfig.legend.data = seriesNames;
                                echartsConfig.legend.show = true;
                            } else {
                                echartsConfig.legend.show = false;
                                echartsConfig.legend.data = [];
                            }
                        } else if (!echartsConfig.legend) {
                            // No series, but ensure legend exists
                            echartsConfig.legend = {
                                show: false,
                                data: [],
                                top: 'bottom',
                                orient: 'horizontal'
                            };
                        }
                        
                        // Ensure xAxis and yAxis are properly defined
                        if (!echartsConfig.xAxis) {
                            echartsConfig.xAxis = { type: 'category', data: [] };
                        }
                        if (!echartsConfig.yAxis) {
                            echartsConfig.yAxis = { type: 'value' };
                        }
                        
                        // Set chart options with error handling
                        try {
                            console.log('Setting ECharts options with config:', JSON.stringify(echartsConfig, null, 2));
                            chart.setOption(echartsConfig, true); // true = notMerge, replace all options
                            console.log('ECharts chart rendered successfully');
                        } catch (error) {
                            console.error('Error setting ECharts options:', error);
                            console.error('Chart config that failed:', JSON.stringify(echartsConfig, null, 2));
                            echartsDiv.innerHTML = `<div style="text-align: center; padding: 50px; color: #d32f2f;">
                                <p>Error rendering chart: ${error.message}</p>
                                <p style="font-size: 12px; color: #666;">Check console for details</p>
                            </div>`;
                            return;
                        }
                        
                        // TRIGGER SYSTEM: Chart is ready, capture image and enable download
                        setTimeout(() => {
                            try {
                                console.log('Triggering chart capture and download button enable...');
                                
                                // Capture chart image immediately
                                const chartImageData = chart.getDataURL({
                                    type: 'png',
                                    pixelRatio: 2,
                                    backgroundColor: '#ffffff',
                                    excludeComponents: ['toolbox', 'brush']
                                });
                                
                                console.log('Chart image captured successfully, length:', chartImageData.length);
                                
                                // Store chart data in the message element for PDF download
                                const messageElement = chartContainer.closest('.message');
                                if (messageElement) {
                                    messageElement._capturedChartData = chartImageData;
                                    console.log('Chart data stored in message element');
                                }
                                
                                // Show download buttons
                                downloadButton.style.display = 'flex';
                                downloadChartButton.style.display = 'flex';
                                console.log('Download buttons enabled and shown');
                                
                            } catch (error) {
                                console.error('Error in trigger system:', error);
                                // Show buttons anyway
                                downloadButton.style.display = 'flex';
                                downloadChartButton.style.display = 'flex';
                            }
                        }, 1000); // Wait 1 second for chart to be fully rendered

                        // Add PDF download functionality using pre-captured chart data
                        downloadButton.onclick = async () => {
                            // Store original button text outside try-catch for error handling
                            const originalText = downloadButton.innerHTML;
                            try {
                                // Show loading state
                                downloadButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="3"></circle>
                                        <path d="M12 1v6m0 6v6"></path>
                                        <path d="m21 12-6-6m-6 6-6-6"></path>
                                    </svg>
                                    Generating PDF...
                                `;
                                downloadButton.disabled = true;
                                downloadButton.style.background = '#6c757d';
                                
                                // Get pre-captured chart data
                                const messageElement = chartContainer.closest('.message');
                                let chartData = messageElement ? messageElement._capturedChartData : null;
                                
                                // If no pre-captured data, try to capture it now
                                if (!chartData) {
                                    console.log('No pre-captured chart data, attempting to capture now...');
                                    try {
                                        const chart = echarts.getInstanceByDom(chartContainer);
                                        if (chart) {
                                            await new Promise(resolve => setTimeout(resolve, 500)); // Wait for chart to be ready
                                            chartData = chart.getDataURL({
                                                type: 'png',
                                                pixelRatio: 2,
                                                backgroundColor: '#ffffff',
                                                excludeComponents: ['toolbox', 'brush']
                                            });
                                            console.log('Chart data captured on-demand, length:', chartData ? chartData.length : 0);
                                        }
                                    } catch (error) {
                                        console.error('Failed to capture chart data:', error);
                                        // Continue without chart data
                                    }
                                }
                                
                                console.log('Using chart data for PDF, length:', chartData ? chartData.length : 0);
                                
                                // Get message text for PDF
                                const messageTextElement = messageElement.querySelector('.message-text');
                                const messageText = messageTextElement ? messageTextElement.innerText || messageTextElement.textContent : '';
                                
                                // Get query from chat history
                                const messages = Array.from(document.querySelectorAll('.message'));
                                const currentIndex = messages.indexOf(messageElement);
                                let query = 'Unknown query';
                                
                                // Look for the previous user message
                                for (let i = currentIndex - 1; i >= 0; i--) {
                                    if (messages[i].classList.contains('user-message')) {
                                        query = messages[i].querySelector('.message-text').innerText || messages[i].querySelector('.message-text').textContent;
                                        break;
                                    }
                                }
                                
                                // Download PDF with or without embedded chart
                                await downloadFile(query, messageText, 'pdf', chartData);
                                
                                // Show success state
                                downloadButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M20 6L9 17l-5-5"/>
                                    </svg>
                                    PDF Downloaded!
                                `;
                                downloadButton.style.background = '#1F7246';
                                
                                console.log('ECharts chart downloaded successfully');
                                
                                // Reset button after 2 seconds
                                setTimeout(() => {
                                    downloadButton.innerHTML = originalText;
                                    downloadButton.disabled = false;
                                    downloadButton.style.background = '#1F7246';
                                }, 2000);
                                
                            } catch (error) {
                                console.error('Error downloading ECharts chart:', error);
                                
                                // Show error state
                                downloadButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <line x1="15" y1="9" x2="9" y2="15"/>
                                        <line x1="9" y1="9" x2="15" y2="15"/>
                                    </svg>
                                    Failed
                                `;
                                downloadButton.style.background = '#dc3545';
                                
                                // Reset button after 3 seconds
                                setTimeout(() => {
                                    downloadButton.innerHTML = originalText;
                                    downloadButton.disabled = false;
                                    downloadButton.style.background = '#1F7246';
                                }, 3000);
                                
                                alert('Failed to download PDF. Please try again.');
                            }
                        };
                        
                        // Add Chart download functionality
                        downloadChartButton.onclick = async () => {
                            // Store original button text outside try-catch for error handling
                            const originalText = downloadChartButton.innerHTML;
                            try {
                                // Show loading state
                                downloadChartButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="3"></circle>
                                        <path d="M12 1v6m0 6v6"></path>
                                        <path d="m21 12-6-6m-6 6-6-6"></path>
                                    </svg>
                                    Downloading...
                                `;
                                downloadChartButton.disabled = true;
                                downloadChartButton.style.background = '#6c757d';
                                
                                // Get pre-captured chart data
                                const messageElement = chartContainer.closest('.message');
                                const chartData = messageElement ? messageElement._capturedChartData : null;
                                
                                if (!chartData) {
                                    throw new Error('No chart data available');
                                }
                                
                                console.log('Downloading chart image, data length:', chartData.length);
                                
                                // Generate filename with timestamp
                                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                                const filename = `chart-${timestamp}.png`;
                                
                                // Use the existing downloadChart function for ECharts
                                await downloadChart('echarts', echartsDiv.id, chart);
                                
                                // Show success state
                                downloadChartButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M20 6L9 17l-5-5"/>
                                    </svg>
                                    Downloaded!
                                `;
                                downloadChartButton.style.background = '#1F7246';
                                
                                console.log('Chart image downloaded successfully as:', filename);
                                
                                // Reset button after 2 seconds
                                setTimeout(() => {
                                    downloadChartButton.innerHTML = originalText;
                                    downloadChartButton.disabled = false;
                                    downloadChartButton.style.background = '#1F7246';
                                }, 2000);
                                
                            } catch (error) {
                                console.error('Error downloading chart image:', error);
                                
                                // Show error state
                                downloadChartButton.innerHTML = `
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <line x1="15" y1="9" x2="9" y2="15"/>
                                        <line x1="9" y1="9" x2="15" y2="15"/>
                                    </svg>
                                    Failed
                                `;
                                downloadChartButton.style.background = '#dc3545';
                                
                                // Reset button after 3 seconds
                                setTimeout(() => {
                                    downloadChartButton.innerHTML = originalText;
                                    downloadChartButton.disabled = false;
                                    downloadChartButton.style.background = '#1F7246';
                                }, 3000);
                                
                                alert('Failed to download chart image. Please try again.');
                            }
                        };
                        
                        // Make chart responsive
                        const resizeObserver = new ResizeObserver(() => {
                            chart.resize();
                        });
                        resizeObserver.observe(echartsDiv);
                        
                        // Also handle window resize
                        window.addEventListener('resize', () => {
                            chart.resize();
                        });
                        
                    } catch (error) {
                        console.error('Error creating ECharts instance:', error);
                        echartsDiv.innerHTML = `<div style="text-align: center; padding: 50px; color: #d32f2f;">Error rendering chart: ${error.message}</div>`;
                    }
                }

            } catch (error) {
                console.error('Error in renderEChartsChart:', error);
            }
        }

        // Function to convert Chart.js config to ECharts config
        function convertChartJsToECharts(chartJsConfig) {
            try {
                const chartType = chartJsConfig.type;
                const data = chartJsConfig.data;
                const options = chartJsConfig.options;
                
                // Extract basic information
                const labels = data.labels || [];
                const datasets = data.datasets || [];
                const title = options?.plugins?.title?.text || 'Chart';
                
                // Base ECharts configuration
                const echartsConfig = {
                    type: `echarts_${chartType}`,
                    title: {
                        text: title,
                        left: 'center',
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: chartType === 'pie' ? 'item' : 'axis'
                    },
                    legend: {
                        data: datasets.map(d => d.label),
                        top: 'bottom'
                    },
                    animation: true,
                    animationDuration: 1000
                };
                
                // Chart-specific conversion
                if (chartType === 'bar') {
                    echartsConfig.grid = {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    };
                    echartsConfig.xAxis = {
                        type: 'category',
                        data: labels
                    };
                    echartsConfig.yAxis = {
                        type: 'value'
                    };
                    echartsConfig.series = datasets.map(dataset => ({
                        name: dataset.label,
                        type: 'bar',
                        data: dataset.data,
                        itemStyle: {
                            color: dataset.backgroundColor?.[0] || '#5470c6'
                        }
                    }));
                } else if (chartType === 'line') {
                    echartsConfig.grid = {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    };
                    echartsConfig.xAxis = {
                        type: 'category',
                        data: labels
                    };
                    echartsConfig.yAxis = {
                        type: 'value'
                    };
                    echartsConfig.series = datasets.map(dataset => ({
                        name: dataset.label,
                        type: 'line',
                        data: dataset.data,
                        lineStyle: {
                            color: dataset.borderColor?.[0] || '#5470c6'
                        },
                        smooth: true
                    }));
                } else if (chartType === 'pie' || chartType === 'doughnut') {
                    const pieData = labels.map((label, index) => ({
                        name: label,
                        value: datasets[0]?.data[index] || 0
                    }));
                    
                    echartsConfig.series = [{
                        name: datasets[0]?.label || 'Data',
                        type: 'pie',
                        radius: chartType === 'doughnut' ? ['40%', '70%'] : '50%',
                        data: pieData,
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowOffsetX: 0,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }];
                }
                
                return echartsConfig;
            } catch (error) {
                console.error('Error converting Chart.js config to ECharts:', error);
                return chartJsConfig; // Return original if conversion fails
            }
        }

        // Function to render charts using ECharts (all chart types)
        function renderChart(chartConfig) {
            try {
                // Validate chartConfig exists and is an object
                if (!chartConfig || typeof chartConfig !== 'object') {
                    console.error('Invalid chart config: chartConfig is null, undefined, or not an object', chartConfig);
                    return;
                }
                
                console.log('Rendering chart with config:', chartConfig);
                
                // Ensure series exists and is an array before proceeding
                if (!chartConfig.series || !Array.isArray(chartConfig.series) || chartConfig.series.length === 0) {
                    console.error('Invalid chart config: missing or empty series array', chartConfig);
                    return;
                }
                
                // Filter out any null/undefined elements from series array
                chartConfig.series = chartConfig.series.filter(s => s != null && typeof s === 'object');
                
                if (chartConfig.series.length === 0) {
                    console.error('Invalid chart config: all series elements are null/undefined');
                    return;
                }
                
                // Check if this is an ECharts chart (all chart types now use ECharts)
                if (chartConfig.type && (chartConfig.type.startsWith('echarts_') || chartConfig.type === 'pareto')) {
                    console.log('Detected ECharts chart, using ECharts renderer');
                    renderEChartsChart(chartConfig);
                    return;
                }
                
                // For backward compatibility, convert legacy Chart.js configs to ECharts
                if (chartConfig.type && ['bar', 'line', 'pie', 'doughnut'].includes(chartConfig.type)) {
                    console.log('Converting legacy Chart.js config to ECharts');
                    const convertedConfig = convertChartJsToECharts(chartConfig);
                    renderEChartsChart(convertedConfig);
                    return;
                }
                
                // Fallback: render as ECharts anyway
                console.log('Fallback: rendering unknown chart type with ECharts');
                renderEChartsChart(chartConfig);
                
            } catch (error) {
                console.error('Error rendering chart:', error);
                console.error('Chart config that failed:', chartConfig);
                
                // Show error message instead of chart
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    margin: 20px 0;
                    padding: 15px;
                    background: #f8d7da;
                    color: #721c24;
                    border: 1px solid #f5c6cb;
                    border-radius: 4px;
                    font-size: 14px;
                `;
                errorDiv.textContent = 'Unable to render chart. The data visualization could not be displayed.';
                
                // Try to append error to message bubble first, then fallback
                let container = document.querySelector('.bot-message:last-child .message-bubble') ||
                               document.querySelector('.message:last-child .message-bubble') ||
                               document.querySelector('.bot-message:last-child') ||
                               document.querySelector('.message:last-child') ||
                               document.querySelector('.chat-messages') ||
                               document.querySelector('#chat-container');
                               
                if (container) {
                    container.appendChild(errorDiv);
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeCopilotInterface();
            
            // Initialize gallery prompt click handlers
            initializeGalleryPromptHandlers();
            
            // Initialize chat header functionality
            initializeChatHeader();
        });

        // Gallery Prompt Click Handlers - Close Gallery on Prompt Click
        function initializeGalleryPromptHandlers() {
            // Function to setup click handlers for all prompts
            function setupPromptClickHandlers() {
                // Find all prompt elements in the gallery
                const promptElements = document.querySelectorAll('.dropdown-item-main, .dropdown-item, .prompt-option, .card .prompt-item, .expandable-prompt, [data-prompt]');
                
                promptElements.forEach(promptElement => {
                    // Remove existing listeners to prevent duplicates
                    promptElement.removeEventListener('click', handlePromptClick);
                    
                    // Add click listener
                    promptElement.addEventListener('click', handlePromptClick);
                    
                    // Add visual feedback
                    promptElement.style.cursor = 'pointer';
                });
                
                console.log(`Setup click handlers for ${promptElements.length} prompt elements`);
            }
            
            // Function to handle prompt clicks
            function handlePromptClick(event) {
                event.preventDefault();
                event.stopPropagation();
                const el = event.currentTarget;
                const text = (el?.dataset?.prompt || el?.innerText || '').trim();
                if (text) {
                    pasteIntoChatInput(text);
                }
                closePromptGallery();
            }
            
            // Setup handlers when gallery opens
            document.addEventListener('click', function(event) {
                // Check if gallery button was clicked
                if (event.target.matches('.prompt-gallery-btn, .gallery-btn, .floating-gallery-btn, [data-gallery-open]')) {
                    console.log('Gallery button clicked, setting up prompt handlers...');
                    
                    // Wait for modal to render then setup handlers
                    setTimeout(() => {
                        setupPromptClickHandlers();
                    }, 300);
                }
            });
            
            // Also setup handlers when gallery content is dynamically added
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.addedNodes.length > 0) {
                        // Check if prompt gallery content was added
                        const hasGalleryContent = Array.from(mutation.addedNodes).some(node =>
                            node.nodeType === 1 && (
                                node.classList.contains('CGMSCL-prompt-gallery-modal') ||
                                node.querySelector('.dropdown-item-main') ||
                                node.querySelector('.prompt-option')
                            )
                        );
                        
                        if (hasGalleryContent) {
                            setTimeout(() => {
                                setupPromptClickHandlers();
                            }, 100);
                        }
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Initial setup
            setTimeout(() => {
                setupPromptClickHandlers();
            }, 1000);
        }

        // New Copilot Interface Functions
        function initializeCopilotInterface() {
            loadChatHistory();
            updateChatHistoryDisplay();
            
            // Show welcome screen initially
            document.getElementById('welcome-screen').style.display = 'flex';
            document.getElementById('chat-area').style.display = 'none';
            
            // Hide floating button on welcome screen
            toggleFloatingButton(false);
            
        }



        function startNewChat() {
            // Clear current chat
            chatHistory = [];
            localStorage.removeItem('chatHistory');
            
            // Store old session ID for cleanup
            const oldSessionId = window.currentSessionId;
            
            // Create new session via backend API
            fetch('/new-session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Use the new session ID from server
                    window.currentSessionId = data.session_id;
                    console.log('New session created:', data.session_id);
                    console.log('Session limits:', data.limits);
                    
                    // Update session info display if exists
                    updateSessionDisplay(data.limits);
                } else {
                    throw new Error('Failed to create new session');
                }
            })
            .catch(err => {
                console.warn('Failed to create new session, using fallback:', err);
                // Fallback: Generate session ID locally
                window.currentSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            });
            
            // Clear old server-side session history
            if (oldSessionId && typeof fetch !== 'undefined') {
                fetch(`/clear-session/${oldSessionId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                }).then(r => r.ok ? r.json() : Promise.reject('Failed to clear session'))
                  .then(data => {
                      console.log('Old server session cleared:', data);
                  })
                  .catch(err => console.warn('Failed to clear old server session:', err));
            }
            
            // Clear TTS state
            window.lastBotResponse = '';
            if (window.isTTSPlaying) {
                stopTTS();
            }
            
            // Show welcome screen
            document.getElementById('welcome-screen').style.display = 'flex';
            document.getElementById('chat-area').style.display = 'none';
            
            // Hide glassmorphism header
            const glassmorphismHeader = document.getElementById('chat-glassmorphism-header');
            if (glassmorphismHeader) {
                glassmorphismHeader.style.display = 'none';
            }
            
            // Hide floating button on welcome screen
            toggleFloatingButton(false);
            
            // Clear chat container
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = '';
            
            // Clear input fields
            document.getElementById('user-input').value = '';
            const copilotInput = document.getElementById('copilot-search-input');
            if (copilotInput) copilotInput.value = '';
            
            // Update history display
            updateChatHistoryDisplay();
            
            // Reset any processing state
            isProcessingQueue = false;
            isTyping = false;
            
            console.log('New chat started');
        }

        // Chat Header Glassmorphism Functions
        function initializeChatHeader() {
            const glassmorphismHeader = document.getElementById('chat-glassmorphism-header');
            
            if (!glassmorphismHeader) return;

            // Show header when chat is visible
            function showChatHeader() {
                const chatArea = document.getElementById('chat-area');
                if (chatArea && chatArea.style.display !== 'none') {
                    glassmorphismHeader.style.display = 'flex';
                } else {
                    glassmorphismHeader.style.display = 'none';
                }
            }

            // Check visibility on initialization
            showChatHeader();
            
            // Monitor chat area visibility changes
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                        showChatHeader();
                    }
                });
            });

            const chatArea = document.getElementById('chat-area');
            if (chatArea) {
                observer.observe(chatArea, { attributes: true, attributeFilter: ['style'] });
            }
        }

        function toggleChatMenu() {
            // Toggle chat menu functionality - can be expanded later
            console.log('Chat menu clicked');
            // You can add dropdown menu functionality here
        }

        // fillCenteredInput function removed - old search box functionality

        // Updated function to handle main card clicks (fill Copilot search)
        function handleMainCardClick(promptText) {
            fillCopilotSearch(promptText);
        }


        // Function to toggle dropdown for extended cards
        // Simple and robust dropdown functionality for extended cards
        function toggleCardDropdownById(event, cardId) {
            console.log(' Toggle dropdown called for ID:', cardId);
            
            // Prevent default behavior
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Find the dropdown and arrow elements
            const dropdown = document.getElementById('dropdown-' + cardId);
            const arrow = event ? event.target.closest('.dropdown-toggle') : document.querySelector(`[onclick*="toggleCardDropdown.*${cardId}"]`);
            
            console.log(' Dropdown found:', !!dropdown);
            console.log(' Arrow found:', !!arrow);
            
            if (!dropdown) {
                console.error(' Dropdown not found for:', cardId);
                return;
            }
            
            if (!arrow) {
                console.error(' Arrow not found for:', cardId);
                return;
            }
            
            // Check current state
            const isVisible = dropdown.style.display === 'block' || dropdown.style.display === '';
            console.log(' Currently visible:', isVisible);
            
            // Close ALL dropdowns first (not just extended ones)
            closeAllDropdowns();
            
                allArrows.forEach(arr => {
                if (arr !== arrow) {
                    arr.classList.remove('rotated');
                    const chevron = arr.querySelector('i');
                    if (chevron) {
                        chevron.className = 'fa fa-chevron-down';
                        chevron.style.color = '#6B7280';
                    }
                }
            });
            
            // Toggle current dropdown - only open if it wasn't visible before
            if (!isVisible) {
                // Open dropdown
                dropdown.style.display = 'block';
                dropdown.classList.add('expanded', 'show');
                arrow.classList.add('rotated');
                const chevron = arrow.querySelector('i');
                if (chevron) {
                    chevron.className = 'fa fa-chevron-up';
                    chevron.style.color = '#6B7280';
                }
                console.log(' Opened dropdown for:', cardId);
            }
            // Note: If it was visible, it's already closed by closeAllDropdowns()
        }

        // Unified function to close all dropdowns
        function closeAllDropdowns() {
            // Close main card dropdowns
            const mainDropdowns = document.querySelectorAll('.dropdown-content-main');
            const mainArrows = document.querySelectorAll('.card-header-main .dropdown-toggle');
            
            mainDropdowns.forEach(dd => dd.style.display = 'none');
            mainArrows.forEach(arr => {
                arr.classList.remove('rotated');
                const chevron = arr.querySelector('i');
                if (chevron) {
                    chevron.className = 'fa fa-chevron-down';
                    chevron.style.color = '#6B7280';
                }
            });
            
            // Close extended card dropdowns
            const extendedDropdowns = document.querySelectorAll('.dropdown-content-extended');
            const extendedArrows = document.querySelectorAll('.prompt-card-extended .dropdown-toggle');
            
            extendedDropdowns.forEach(dd => {
                dd.style.display = 'none';
                dd.classList.remove('expanded', 'show');
            });
            extendedArrows.forEach(arr => {
                arr.classList.remove('rotated');
                const chevron = arr.querySelector('i');
                if (chevron) chevron.className = 'fa fa-chevron-down';
            });
            
            // Close card expanded content dropdowns
            document.querySelectorAll('.card-expanded-content.expanded').forEach(content => {
                content.classList.remove('expanded');
                const button = content.closest('.prompt-card, .prompt-card-extended').querySelector('.dropdown-toggle');
                if (button) {
                    button.classList.remove('rotated');
                    const chevron = button.querySelector('i');
                    if (chevron) chevron.className = 'fa fa-chevron-down';
                }
            });
        }

        // Function to toggle dropdown for main cards
        function toggleMainCardDropdown(event, cardId) {
            event.stopPropagation();
            const dropdown = document.getElementById('dropdown-' + cardId);
            const button = event.currentTarget || event.target;
            if (!dropdown || !button) return;

            const isVisible = dropdown.classList.contains('show') || dropdown.style.display === 'block';
            const currentCard = button.closest('.prompt-card-main');

            // Reset all card positions first
            document.querySelectorAll('.prompt-card-main').forEach(card => {
                card.style.marginTop = '';
                card.style.transform = '';
                card.style.top = '';
                card.style.position = '';
                card.style.transition = 'top 0.3s ease, transform 0.3s ease';
            });

            // Close others
            document.querySelectorAll('.dropdown-content-main').forEach(el => {
                el.classList.remove('show');
                el.style.display = 'none';
            });
            document.querySelectorAll('.card-header-main .dropdown-toggle').forEach(t => {
                t.classList.remove('rotated');
                const chevron = t.querySelector('i');
                if (chevron) {
                    chevron.className = 'fa fa-chevron-down';
                    chevron.style.color = '#6B7280';
                }
            });

            // Toggle this one
            if (!isVisible) {
                dropdown.classList.add('show');
                dropdown.style.display = 'block';
                button.classList.add('rotated');
                const chevron = button.querySelector('i');
                if (chevron) {
                    chevron.className = 'fa fa-chevron-up';
                    chevron.style.color = '#6B7280';
                }

                // Find the card directly below this one in the grid
                if (currentCard) {
                    // Wait for dropdown to render, then calculate height
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            const allCards = Array.from(document.querySelectorAll('.main-prompt-cards .prompt-card-main'));
                            const currentIndex = allCards.indexOf(currentCard);
                            
                            // Calculate which column this card is in (0, 1, or 2)
                            const columnIndex = currentIndex % 3;
                            
                            // Find the card in the next row, same column
                            // Row 0: indices 0,1,2 | Row 1: indices 3,4,5
                            // So card below is at: currentIndex + 3
                            const cardBelowIndex = currentIndex + 3;
                            
                            if (cardBelowIndex < allCards.length) {
                                const cardBelow = allCards[cardBelowIndex];
                                
                                // Verify it's in the same column
                                const belowColumnIndex = cardBelowIndex % 3;
                                
                                if (belowColumnIndex === columnIndex) {
                                    // Get the current card's bottom position
                                    const currentCardRect = currentCard.getBoundingClientRect();
                                    const currentCardBottom = currentCardRect.bottom;
                                    
                                    // Get the card below's current top position
                                    const cardBelowRect = cardBelow.getBoundingClientRect();
                                    const cardBelowTop = cardBelowRect.top;
                                    
                                    // Calculate how much the card below needs to move
                                    // It should be positioned right after the expanded card
                                    const gridContainer = currentCard.closest('.main-prompt-cards');
                                    const containerRect = gridContainer.getBoundingClientRect();
                                    const gap = 20; // gap from CSS
                                    
                                    // Calculate the new position: currentCard bottom + gap
                                    const newTopPosition = currentCardBottom - containerRect.top + gap;
                                    const currentTopPosition = cardBelowTop - containerRect.top;
                                    const offsetNeeded = newTopPosition - currentTopPosition;
                                    
                                    if (offsetNeeded > 5) {
                                        // Use position relative with top to move only this card
                                        cardBelow.style.position = 'relative';
                                        cardBelow.style.top = offsetNeeded + 'px';
                                        cardBelow.style.transition = 'top 0.3s ease';
                                    }
                                }
                            }
                        });
                    });
                }
            }
        }

        // Function to paste text into chat input without sending
        function pasteIntoChatInput(text) {
            // Prefer visible and enabled inputs
            const candidates = [
                document.getElementById('user-input'),
                document.querySelector('.chat-search-input'),
                document.querySelector('.input-textarea'),
                document.getElementById('copilot-search-input'),
                document.querySelector('input[placeholder*="message" i]'),
                document.querySelector('textarea[placeholder*="message" i]'),
                document.querySelector('input[type="text"]')
            ].filter(Boolean);

            let target = candidates.find(el => el.offsetParent !== null && !el.disabled && !el.readOnly) || candidates[0];

            if (target) {
                target.value = text;
                target.focus();
                const val = target.value;
                if (typeof target.setSelectionRange === 'function') {
                    target.setSelectionRange(val.length, val.length);
                }
                // Fire events so any listeners update
                target.dispatchEvent(new Event('input', { bubbles: true }));
                target.dispatchEvent(new Event('change', { bubbles: true }));
                // brief visual feedback
                const originalBg = target.style.backgroundColor;
                target.style.backgroundColor = '#fff7ed';
                setTimeout(() => { target.style.backgroundColor = originalBg || 'transparent'; }, 250);
            }
        }

        // Function to handle main prompt clicks (copy to clipboard)
        function handleMainPromptClick(promptText) {
            pasteIntoChatInput(promptText);
        }

        // Update extended card function to fill Copilot search
        function handleExtendedCardClick(promptText) {
            pasteIntoChatInput(promptText);
        }

        // Function to copy prompt to clipboard
        function insertPromptToSearch(promptElement) {
            const promptText = promptElement.textContent.trim();
            pasteIntoChatInput(promptText);
        }

        // Legacy function for backward compatibility
        function insertPromptToSearchOld(promptElement) {
            const promptText = promptElement.textContent.trim();
            const searchInput = document.querySelector('input[placeholder*="message"]') ||
                               document.querySelector('.search-input') ||
                               document.querySelector('input[type="text"]') ||
                               document.querySelector('.copilot-search-box input');
            
            if (searchInput) {
                searchInput.value = promptText;
                searchInput.focus();
                
                // Trigger input event for any listeners
                const inputEvent = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(inputEvent);
                
                // Also try to fill the Copilot search if available
                if (typeof fillCopilotSearch === 'function') {
                    fillCopilotSearch(promptText);
                }
            }
        }

        // Function to insert prompt into chat search box and close gallery
        function insertPromptToGallery(promptElement) {
            const promptText = promptElement.textContent.trim();
            console.log('Prompt clicked:', promptText);
            
            const searchInput = document.querySelector('.chat-input') ||
                               document.querySelector('input[placeholder*="message"]') ||
                               document.querySelector('.search-input') ||
                               document.querySelector('#user-input') ||
                               document.querySelector('.input-textarea') ||
                               document.querySelector('textarea[placeholder*="message"]');
            
            if (searchInput) {
                searchInput.value = promptText;
                searchInput.focus();
                
                // Trigger input event
                const inputEvent = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(inputEvent);
                
                // Also trigger change event
                const changeEvent = new Event('change', { bubbles: true });
                searchInput.dispatchEvent(changeEvent);
                
                console.log('Prompt inserted into search input');
            } else {
                console.warn('Search input not found');
            }
            
            // Close gallery modal using the proper function
            console.log('Closing gallery modal...');
            closePromptGallery();
        }

        // Enhanced prompt data for all 7 See More cards
        const seeMoreCardPrompts = {
            'anomaly': [
                "Monitor system behavior and flag unusual patterns or activities",
                "Detect deviations from normal operational parameters", 
                "Generate alerts for suspicious or abnormal data points",
                "Analyze trends to identify potential security or operational risks",
                "Identify unusual patterns in sensor data that may indicate equipment failure",
                "Detect anomalies in maintenance records, such as unexpected repairs or high labor costs",
                "Analyze historical data to identify trends and potential issues before they occur"
            ],
            'failure': [
                "Investigate root causes of equipment or system failures",
                "Generate failure analysis reports with recommendations",
                "Identify failure patterns and preventive measures",
                "Create incident reports with timeline and impact assessment",
                "Identify potential failure causes for specific equipment using machine learning algorithms",
                "Predict the likelihood of component failure within the next 3 months",
                "Develop a predictive model to forecast equipment failures based on historical trends"
            ],
            'inventory': [
                "Optimize stock levels to minimize carrying costs while preventing stockouts",
                "Generate reorder recommendations based on usage patterns",
                "Track inventory turnover rates and identify slow-moving items",
                "Create inventory forecasts for seasonal demand fluctuations",
                "Suggest spare parts inventory levels for each asset type, considering usage patterns",
                "Recommend reordering of critical components before they become unavailable",
                "Provide an optimized inventory management plan to minimize stockouts and overstocking"
            ],
            'metrics': [
                "Generate weekly performance summary with key metrics and trends",
                "Compare current performance against historical benchmarks",
                "Create detailed analytics reports for management review",
                "Identify performance bottlenecks and improvement opportunities",
                "Calculate the average time-to-repair for each asset type",
                "Develop a benchmark for expected Mean Time Between Failures (MTBF) for critical equipment",
                "Create a dashboard showing key performance indicators (KPIs) for maintenance teams"
            ],
            'assets': [
                "Track asset utilization rates and optimize deployment strategies",
                "Generate asset lifecycle reports and replacement planning",
                "Monitor asset performance and maintenance requirements",
                "Create asset allocation recommendations for maximum efficiency",
                "Create an asset register with up-to-date information on condition, usage, and history",
                "Offer recommendations for maintenance scheduling based on equipment age and usage patterns",
                "Analyze data to identify areas where assets are underutilized or overused"
            ],
            'scheduling': [
                "Create optimized maintenance calendars considering resource availability",
                "Schedule preventive maintenance to minimize operational disruption",
                "Generate work orders and assign appropriate technicians",
                "Balance urgent repairs with planned maintenance activities",
                "Create a schedule for routine maintenance tasks, including frequency and timing",
                "Offer suggestions for optimizing maintenance schedules based on equipment type and usage patterns",
                "Develop a system for tracking and updating maintenance records"
            ]
        };
        // Function to populate dropdown content for all See More cards
        function populateCardDropdowns() {
            console.log(' Populating card dropdowns...');
            
            const cardTypes = ['anomaly', 'failure', 'inventory', 'metrics', 'assets', 'scheduling'];
            
            cardTypes.forEach(cardType => {
                const dropdown = document.getElementById('dropdown-' + cardType);
                
                if (dropdown) {
                    // Clear existing content
                    dropdown.innerHTML = '';
                    
                    // Get prompts for this card type
                    const prompts = seeMoreCardPrompts[cardType] || [];
                    
                    // Add all prompts for this card type
                    prompts.forEach(prompt => {
                        const promptElement = document.createElement('div');
                        promptElement.className = 'dropdown-item-extended';
                        promptElement.textContent = prompt;
                        promptElement.style.cursor = 'pointer';
                        promptElement.style.padding = '8px 12px';
                        promptElement.style.margin = '4px 0';
                        promptElement.style.background = 'white';
                        promptElement.style.border = '1px solid #f3f4f6';
                        promptElement.style.borderRadius = '6px';
                        promptElement.style.fontSize = '14px';
                        promptElement.style.color = '#374151';
                        promptElement.style.transition = 'all 0.2s ease';
                        
                        // Add hover effect
                        promptElement.addEventListener('mouseenter', function() {
                            this.style.background = '#f9fafb';
                            this.style.borderColor = '#1F7246';
                            this.style.color = '#1F7246';
                        });
                        
                        promptElement.addEventListener('mouseleave', function() {
                            this.style.background = 'white';
                            this.style.borderColor = '#f3f4f6';
                            this.style.color = '#374151';
                        });
                        
                        promptElement.onclick = () => {
                            console.log(' Prompt clicked:', prompt);
                            handleExtendedCardClick(prompt);
                        };
                        
                        dropdown.appendChild(promptElement);
                    });
                    
                    console.log(` Populated ${prompts.length} prompts for ${cardType}`);
                } else {
                    console.warn(` Dropdown not found for card type: ${cardType}`);
                }
            });
            
            // Also populate custom cards from global data structure
            populateCustomCards();
        }

        function populateCustomCards() {
            console.log(' Populating custom cards...');
            
            // Find custom cards in global data structure
            const customCards = globalPromptCards.filter(card => card.type === 'custom');
            
            customCards.forEach(cardData => {
                // Create a new card element for CGMSCL gallery
                const cardElement = createCGMSCLCardElement(cardData);
                
                // Find a suitable place to add it (e.g., in the CGMSCL gallery grid)
                const CGMSCLGrid = document.querySelector('.CGMSCL-prompt-gallery-modal .cards-grid');
                if (CGMSCLGrid) {
                    CGMSCLGrid.appendChild(cardElement);
                }
            });
            
            console.log(` Populated ${customCards.length} custom cards`);
        }

        function createCGMSCLCardElement(cardData) {
            const card = document.createElement('div');
            card.className = 'prompt-card';
            card.dataset.cardId = cardData.id;
            
            const promptsHtml = cardData.prompts.map(prompt => 
                `<div class="prompt-option" onclick="insertPromptToGallery(this)">${prompt}</div>`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header">
                    <div class="card-icon">
                        <i class="${cardData.icon}"></i>
                    </div>
                    <h3 class="card-title">${cardData.title}</h3>
                    <button class="dropdown-toggle" onclick="toggleCardDropdown(this)">
                        <i class="fa fa-chevron-down"></i>
                    </button>
                </div>
                <p class="card-description">${cardData.description}</p>
                <div class="card-expanded-content">
                    ${promptsHtml}
                </div>
            `;
            
            return card;
        }

        // Test function to verify dropdown elements exist
        function testDropdownElements() {
            console.log('=== TESTING DROPDOWN ELEMENTS ===');
            
            const cardTypes = ['anomaly', 'failure', 'inventory', 'metrics', 'assets', 'scheduling'];
            
            cardTypes.forEach(cardType => {
                const dropdown = document.getElementById('dropdown-' + cardType);
                const arrow = document.querySelector(`[onclick*="toggleCardDropdown.*${cardType}"]`);
                
                console.log(`Card: ${cardType}`);
                console.log(`  Dropdown found: ${!!dropdown}`);
                console.log(`  Arrow found: ${!!arrow}`);
                
                if (dropdown) {
                    console.log(`  Dropdown display: ${dropdown.style.display}`);
                    console.log(`  Dropdown children: ${dropdown.children.length}`);
                }
            });
            
            console.log('=== END TEST ===');
        }

        // Function to directly attach event listeners to dropdown arrows
        function attachDropdownListeners() {
            console.log(' Attaching dropdown listeners...');
            
            const cardTypes = ['anomaly', 'failure', 'inventory', 'metrics', 'assets', 'scheduling'];
            
            cardTypes.forEach(cardType => {
                const arrow = document.querySelector(`[onclick*="toggleCardDropdown.*${cardType}"]`);
                
                if (arrow) {
                    console.log(` Found arrow for ${cardType}`);
                    
                    // Remove any existing listeners
                    arrow.removeEventListener('click', handleArrowClick);
                    
                    // Add new click listener
                    arrow.addEventListener('click', function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        console.log(` Arrow clicked for ${cardType}`);
                        toggleCardDropdownById(event, cardType);
                    });
                    
                    // Also ensure onclick attribute is working
                    arrow.setAttribute('onclick', `toggleCardDropdownById(event, '${cardType}')`);
                    
                } else {
                    console.warn(` Arrow not found for ${cardType}`);
                }
            });
            
            console.log(' Dropdown listeners attached');
        }

        // Function to initialize all dropdown functionality
        function initializeAllCardDropdowns() {
            console.log('Initializing all card dropdowns...');
            
            // Test dropdown elements first
            testDropdownElements();
            
            // Populate dropdown content
            populateCardDropdowns();
            
            // Attach event listeners
            attachDropdownListeners();
            
            console.log('Dropdown initialization complete');
        }

        // Manual test function for specific dropdown
        function testDropdown(cardType) {
            console.log(` Testing dropdown for: ${cardType}`);
            const dropdown = document.getElementById('dropdown-' + cardType);
            const arrow = document.querySelector(`[onclick*="toggleCardDropdown.*${cardType}"]`);
            
            console.log(' Dropdown:', dropdown);
            console.log(' Arrow:', arrow);
            
            if (dropdown && arrow) {
                // Simulate click
                const event = new Event('click');
                event.target = arrow;
                toggleCardDropdownById(event, cardType);
            } else {
                console.error(' Elements not found for testing');
            }
        }

        // Function to test all dropdowns
        function testAllDropdowns() {
            console.log(' Testing all dropdowns...');
            const cardTypes = ['anomaly', 'failure', 'inventory', 'metrics', 'assets', 'scheduling'];
            
            cardTypes.forEach((cardType, index) => {
                setTimeout(() => {
                    console.log(`Testing ${cardType}...`);
                    testDropdown(cardType);
                }, index * 1000);
            });
        }

        // Simple arrow click handler
        function handleArrowClick(event) {
            event.preventDefault();
            event.stopPropagation();
            console.log(' Arrow clicked via event listener');
        }

        // Make test functions globally available
        window.testDropdownElements = testDropdownElements;
        window.toggleCardDropdown = toggleCardDropdown;
        window.testDropdown = testDropdown;
        window.testAllDropdowns = testAllDropdowns;
        window.populateCardDropdowns = populateCardDropdowns;
        window.attachDropdownListeners = attachDropdownListeners;

        // Enhanced dropdown click handler
        function handleDropdownClick(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const arrow = event.currentTarget;
            const card = arrow.closest('.prompt-card-extended, .prompt-card-main');
            
            if (!card) {
                console.warn('Card not found for dropdown click');
                return;
            }
            
            // Get card type from the arrow's onclick attribute or card structure
            let cardType = null;
            const onclickAttr = arrow.getAttribute('onclick');
            if (onclickAttr) {
                const match = onclickAttr.match(/toggleCardDropdown\([^,]+,\s*['"]([^'"]+)['"]/);
                if (match) {
                    cardType = match[1];
                }
            }
            
            if (cardType) {
                console.log('Handling dropdown click for card type:', cardType);
                toggleCardDropdown(event, cardType);
            } else {
                console.warn('Could not determine card type for dropdown click');
            }
        }

        // Function to control floating button visibility
        function toggleFloatingButton(show) {
            const floatingBtn = document.getElementById('chat-prompts-fab');
            if (floatingBtn) {
                floatingBtn.style.display = show ? 'flex' : 'none';
            }
        }

        // Microsoft Copilot Style Prompt Gallery Functions
        function openPromptsModal() {
            const modal = document.querySelector('.CGMSCL-prompt-gallery-modal');
            const backdrop = document.querySelector('.gallery-backdrop');
            
            // Show backdrop first
            if (backdrop) {
                backdrop.style.display = 'block';
            }
            
            // Show modal with animation
            if (modal) {
                modal.style.display = 'block';
                // Trigger animation after display
                requestAnimationFrame(() => {
                    modal.classList.add('show');
                });
            }
            
            // Generate prompt cards when modal opens
            generatePromptCards();
            
            // Initialize event listeners
            initializeGalleryEventListeners();
            
            // Setup click handlers for all prompts to close gallery
            setTimeout(() => {
                setupGalleryPromptClickHandlers();
            }, 200);
            
            // Initialize search functionality with longer delay
            setTimeout(() => {
                initializeSearchFunctionality();
                testSearch(); // Debug test
            }, 500);
        }

        function closePromptGallery() {
            const modal = document.querySelector('.CGMSCL-prompt-gallery-modal');
            const backdrop = document.querySelector('.gallery-backdrop');
            
            // Remove animation class
            if (modal) {
                modal.classList.remove('show');
                
                // Hide after animation completes
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }
            
            // Hide backdrop
            if (backdrop) {
                backdrop.style.display = 'none';
            }
        }

        // Search functionality for prompt gallery
        function searchPrompts(query) {
            try {
                console.log('Search called with query:', query); // Debug log
                const searchQuery = query.toLowerCase().trim();
                const clearBtn = document.getElementById('clear-search-btn');
                const promptCards = document.querySelectorAll('#promptsGridHost .prompt-card');
                const noResultsMsg = document.getElementById('no-results-message');
                const resultsCounter = document.getElementById('search-results-counter');
                let hasVisibleCards = false;
                let visibleCount = 0;
                
                console.log('Found', promptCards.length, 'prompt cards'); // Debug log

            // Show/hide clear button
            if (searchQuery.length > 0) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }

            // Remove existing no results message
            if (noResultsMsg) {
                noResultsMsg.remove();
            }

            // Clear previous highlights
            clearSearchHighlights();

            if (searchQuery.length === 0) {
                // Show all cards when search is empty
                promptCards.forEach(card => {
                    card.style.display = 'flex';
                    card.style.opacity = '1';
                    card.style.transform = 'none';
                });
                
                // Hide results counter
                if (resultsCounter) {
                    resultsCounter.style.display = 'none';
                }
                return;
            }

            // Filter cards based on search query
            promptCards.forEach((card, index) => {
                try {
                    const isVisible = isCardMatchingSearch(card, searchQuery);
                    console.log(`Card ${index + 1} visible:`, isVisible); // Debug
                    
                    if (isVisible) {
                        card.style.display = 'flex';
                        card.style.opacity = '1';
                        card.style.transform = 'none';
                        // Highlight matches
                        highlightSearchMatches(card, searchQuery);
                        hasVisibleCards = true;
                        visibleCount++;
                    } else {
                        card.style.display = 'none';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.95)';
                    }
                } catch (cardError) {
                    console.error(`Error processing card ${index + 1}:`, cardError);
                }
            });

            // Reorder matched cards to the top by relevance
            try {
                const promptsGrid = document.getElementById('promptsGridHost');
                if (promptsGrid) {
                    const matchedWithScores = [];
                    const unmatched = [];
                    promptCards.forEach(card => {
                        const isShown = card.style.display !== 'none';
                        if (isShown) {
                            // Use existing scoring utilities if available
                            let score = 0;
                            try {
                                const data = extractSearchData(card);
                                score = calculateMatchScore(searchQuery, data);
                            } catch (e) {
                                // Fallback: basic score using title match priority
                                const title = card.querySelector('.card-title')?.textContent?.toLowerCase() || '';
                                const description = card.querySelector('.card-description')?.textContent?.toLowerCase() || '';
                                score = (title.includes(searchQuery) ? 3 : 0) + (description.includes(searchQuery) ? 1 : 0);
                            }
                            matchedWithScores.push({ card, score });
                        } else {
                            unmatched.push(card);
                        }
                    });

                    // Stable sort: highest score first; stable by DOM order when equal
                    matchedWithScores.sort((a, b) => b.score - a.score);

                    // Append in new order (DOM move is cheap for detached nodes)
                    matchedWithScores.forEach(({ card }) => promptsGrid.appendChild(card));
                    unmatched.forEach(card => promptsGrid.appendChild(card));
                }
            } catch (reorderError) {
                console.warn('Failed to reorder search results:', reorderError);
            }

            // Show results counter or no results message
                // Show results counter or no results message
                if (hasVisibleCards && resultsCounter) {
                    const totalCards = promptCards.length;
                    resultsCounter.textContent = `Showing ${visibleCount} of ${totalCards} prompts`;
                    resultsCounter.style.display = 'block';
                } else if (!hasVisibleCards) {
                    if (resultsCounter) {
                        resultsCounter.style.display = 'none';
                    }
                    showNoResultsMessage(searchQuery);
                }
            } catch (error) {
                console.error('Error in searchPrompts:', error);
            }
        }        function isCardMatchingSearch(card, query) {
            try {
                // Get text content from different parts of the card
                const titleElement = card.querySelector('.card-title');
                const descriptionElement = card.querySelector('.card-description');
                
                const title = titleElement?.textContent?.toLowerCase() || '';
                const description = descriptionElement?.textContent?.toLowerCase() || '';
                
                // Get prompt options text (simplified)
                const promptOptionElements = card.querySelectorAll('.prompt-option');
                let promptOptions = '';
                promptOptionElements.forEach(option => {
                    if (option?.textContent) {
                        promptOptions += option.textContent.toLowerCase() + ' ';
                    }
                });

                const matches = title.includes(query) || 
                               description.includes(query) || 
                               promptOptions.includes(query);
                
                console.log('Card matching - Title:', title.substring(0, 20), 'Query:', query, 'Matches:', matches); // Debug log
                return matches;
            } catch (error) {
                console.error('Error in isCardMatchingSearch:', error);
                return false;
            }
        }

        function highlightSearchMatches(card, query) {
            // Highlight matches in title
            const title = card.querySelector('.card-title');
            if (title) {
                highlightTextInElement(title, query);
            }

            // Highlight matches in description
            const description = card.querySelector('.card-description');
            if (description) {
                highlightTextInElement(description, query);
            }

            // Highlight matches in prompt options
            const promptOptions = card.querySelectorAll('.prompt-option, .dropdown-item, .dropdown-item-main, .dropdown-item-extended');
            promptOptions.forEach(option => {
                highlightTextInElement(option, query);
            });
        }

        function highlightTextInElement(element, query) {
            if (!element || !query || !element.textContent) return;

            try {
                const originalText = element.textContent;
                // Highlight per-term to avoid spanning across words which can cause awkward wraps
                const terms = query
                    .split(/\s+/)
                    .map(t => t.trim())
                    .filter(t => t.length > 1);
                if (terms.length === 0) return;

                const pattern = terms
                    .map(t => `\\b${escapeRegExp(t)}\\b`)
                    .join('|');
                const regex = new RegExp(`(${pattern})`, 'gi');

                const highlightedText = originalText.replace(
                    regex,
                    '<span class="search-highlight">$1</span>'
                );
                
                if (highlightedText !== originalText) {
                    element.innerHTML = highlightedText;
                }
            } catch (error) {
                console.warn('Error highlighting text:', error);
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function clearSearchHighlights() {
            const highlighted = document.querySelectorAll('.search-highlight');
            highlighted.forEach(span => {
                const parent = span.parentNode;
                parent.replaceChild(document.createTextNode(span.textContent), span);
                parent.normalize();
            });
        }

        function clearSearch() {
            const searchInput = document.getElementById('prompt-search-input');
            const clearBtn = document.getElementById('clear-search-btn');
            const noResultsMsg = document.getElementById('no-results-message');
            const resultsCounter = document.getElementById('search-results-counter');

            // Clear input
            if (searchInput) {
                searchInput.value = '';
                searchInput.focus();
            }

            // Hide clear button
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }

            // Hide results counter
            if (resultsCounter) {
                resultsCounter.style.display = 'none';
            }

            // Remove no results message
            if (noResultsMsg) {
                noResultsMsg.remove();
            }

            // Clear highlights and show all cards
            clearSearchHighlights();
            const promptCards = document.querySelectorAll('#promptsGridHost .prompt-card');
            promptCards.forEach(card => {
                card.style.display = 'flex';
                card.style.opacity = '1';
                card.style.transform = 'none';
            });
        }

        function showNoResultsMessage(query) {
            const promptsGrid = document.getElementById('promptsGridHost');
            if (!promptsGrid) return;

            const noResultsDiv = document.createElement('div');
            noResultsDiv.id = 'no-results-message';
            noResultsDiv.style.cssText = `
                grid-column: 1 / -1;
                text-align: center;
                padding: 40px 20px;
                color: #6b7280;
                font-size: 16px;
                background: #f9fafb;
                border: 2px dashed #e5e7eb;
                border-radius: 12px;
                margin: 20px;
            `;
            noResultsDiv.innerHTML = `
                <i class="fas fa-search" style="font-size: 24px; margin-bottom: 12px; color: #9ca3af;"></i>
                <p style="margin: 0 0 8px 0; font-weight: 500;">No prompts found for "${query}"</p>
                <p style="margin: 0; font-size: 14px;">Try searching with different keywords or <button onclick="clearSearch()" style="color: #1F7246
; background: none; border: none; text-decoration: underline; cursor: pointer; font-size: 14px;">clear your search</button></p>
            `;

            promptsGrid.appendChild(noResultsDiv);
        }

        function handleSearchKeydown(event) {
            // Handle Escape key to clear search
            if (event.key === 'Escape') {
                clearSearch();
                event.preventDefault();
            }
            
            // Handle Enter key to focus on first visible card
            if (event.key === 'Enter') {
                const firstVisibleCard = document.querySelector('#promptsGridHost .prompt-card[style*="display: flex"], #promptsGridHost .prompt-card:not([style*="display: none"])');
                if (firstVisibleCard) {
                    const firstDropdownToggle = firstVisibleCard.querySelector('.dropdown-toggle');
                    if (firstDropdownToggle) {
                        firstDropdownToggle.focus();
                    }
                }
                event.preventDefault();
            }
        }

        // Initialize search functionality when modal opens
        function initializeSearchFunctionality() {
            const searchInput = document.getElementById('prompt-search-input');
            console.log('Initializing search functionality, input found:', !!searchInput); // Debug
            
            if (searchInput) {
                // Clear any previous search state
                searchInput.value = '';
                clearSearch();
                
                // Verify event listener is working
                searchInput.addEventListener('input', function(e) {
                    console.log('Search input detected:', e.target.value); // Debug
                    searchPrompts(e.target.value);
                });
                
                // Focus on search input when modal opens
                setTimeout(() => {
                    searchInput.focus();
                    console.log('Search input focused'); // Debug
                }, 100);
            }
        }

        // Test function to verify search works
        function testSearch() {
            console.log('Testing search functionality...');
            const cards = document.querySelectorAll('#promptsGridHost .prompt-card');
            console.log('Found cards:', cards.length);
            cards.forEach((card, index) => {
                const title = card.querySelector('.card-title')?.textContent || 'No title';
                console.log(`Card ${index + 1}:`, title);
            });
        }

        // Manual test function you can call from console
        window.debugSearch = function(query) {
            console.log('=== MANUAL SEARCH DEBUG ===');
            const searchQuery = (query || 'performance').toLowerCase();
            const cards = document.querySelectorAll('#promptsGridHost .prompt-card');
            console.log('Search query:', searchQuery);
            console.log('Found cards:', cards.length);
            
            cards.forEach((card, index) => {
                const title = card.querySelector('.card-title')?.textContent?.toLowerCase() || '';
                const matches = title.includes(searchQuery);
                console.log(`Card ${index + 1}: "${title}" - Matches: ${matches}`);
                
                // Apply visibility directly
                if (matches) {
                    card.style.display = 'flex';
                    card.style.opacity = '1';
                } else {
                    card.style.display = 'none';
                    card.style.opacity = '0';
                }
            });
        };

        // Setup click handlers for all prompts in the gallery to close it
        function setupGalleryPromptClickHandlers() {
            // Find all prompt elements in the gallery
            const promptElements = document.querySelectorAll('.prompt-option, .dropdown-item, .dropdown-item-main, .dropdown-item-extended');
            
            promptElements.forEach(promptElement => {
                // Remove existing listeners to prevent duplicates
                promptElement.removeEventListener('click', handleGalleryPromptClick);
                
                // Add click listener
                promptElement.addEventListener('click', handleGalleryPromptClick);
                
                // Add visual feedback
                promptElement.style.cursor = 'pointer';
            });
            
            console.log(`Setup gallery click handlers for ${promptElements.length} prompt elements`);
        }
        
        // Handle prompt clicks in the gallery
        function handleGalleryPromptClick(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const promptText = event.currentTarget.textContent.trim();
            console.log('Gallery prompt clicked:', promptText);
            
            // Insert prompt into search input
            const searchInput = document.querySelector('.chat-input') ||
                               document.querySelector('input[placeholder*="message"]') ||
                               document.querySelector('.search-input') ||
                               document.querySelector('#user-input') ||
                               document.querySelector('.input-textarea') ||
                               document.querySelector('textarea[placeholder*="message"]');
            
            if (searchInput) {
                searchInput.value = promptText;
                searchInput.focus();
                
                // Trigger input event
                const inputEvent = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(inputEvent);
                
                // Also trigger change event
                const changeEvent = new Event('change', { bubbles: true });
                searchInput.dispatchEvent(changeEvent);
                
                console.log('Prompt inserted into search input');
            }
            
            // Close the gallery modal
            console.log('Closing gallery modal...');
            closePromptGallery();
        }

        // CGMSCL Prompt Cards - Tender Tracking + PO Tracking buckets
        const promptCards = [
            {
                id: 'tender-tracking',
                title: 'Tender Tracking',
                description: 'Track tenders, rate contracts, and performance KPIs',
                icon: '',
                options: [
                    'Show items whose RC expires soon (<90 days)',
                    'Give me all of the items which have valid rate contracts',
                    'Average bids per tender?',
                    'Categories with best RC coverage',
                    'Categories with best RC coverage, also give me the Pareto chart for this as well',
                    'EDL 2025 items vs non-EDL bids?',
                    'List the worst performing tenders',
                    'What is the average time taken for a tender from start to finish',
                    'Which tenders are due for publication this month?'
                ]
            },
            {
                id: 'po-tracking',
                title: 'PO Tracking',
                description: 'Analyze purchase orders, supplier KPIs, and delivery performance',
                icon: '',
                options: [
                    'Which items have supply < 50% of PO quantity?',
                    'Which POs are delayed beyond delivery SLA?',
                    'Which high-priority items have pending inward at WH?',
                    'Which POs have partial supply (<50%)?',
                    'Which items have been awarded and which are pending award?',
                    'For Item Oxytocin Injection IP , has PO been issued to the vendor?',
                    'What is the PO execution status of Item Oxytocin Injection IP?',
                    'What is the supply status of PO for Item Multivitamin + Multimineral Syrup 200 ml ?',
                    'PO-wise supply status (drug, quantity, percentage supplied).',
                    'POs where partial supplies were made but balance overdue.',
                    'Vendors who have defaulted in timely supply.',
                    'Which POs are nearing expiry of delivery period?',
                    'PO-wise inward delays at WH.'
                ]
            },
            {
                id: 'tender-level-monitoring',
                title: 'Tender-level Monitoring',
                description: 'Monitor tender status, delays, vendor participation, and award status',
                icon: '',
                options: [
                    'What is the current status of Tender No. XYZ (stage-wise)?',
                    'Which tenders are delayed and may impact supply?',
                    'Which items in this tender received single-vendor bids?',
                    'Vendor participation summary item-wise for this tender, tender no. 164',
                    'Items where bidders were disqualified during PQ or technical evaluation.',
                    'Which items have abnormally high quotes compared to previous RC?',
                    'Which items have been awarded and which are pending award?',
                    'For Item Oxytocin Injection IP, has PO been issued to the vendor?',
                    'Which items have supply < 50% of PO quantity?'
                ]
            },
            {
                id: 'rate-contract-critical',
                title: 'Rate Contract (RC)  Critical Questions',
                description: 'Monitor RC expiry, extensions, vendor watch, and transition requirements',
                icon: '',
                options: [
                    'When does the RC for Item X expire?',
                    'Which RCs expire within 30/60/90 days?',
                    'Items requiring immediate RC extension or fresh tendering.',
                    'Which RC vendors are under watch due to QC failures?',
                    'Which items need transition from old RC to new tender?',
                    'Which RC items have repeated supply delays?',
                    'Items needing emergency procurement due to RC-Tender gap.'
                ]
            },
            {
                id: 'procurement-execution',
                title: 'Procurement Execution (PO, Supply, Vendor Performance)',
                description: 'Track QC status, NSQ items, hold batches, and vendor performance',
                icon: '',
                options: [
                    'Item-wise QC hold batches blocking supply.',
                    'Vendors whose QC failures are delaying supplies for tender/RC items.'
                ]
            },
            {
                id: 'high-priority-exceptions',
                title: 'High-Priority Exception & Alert Questions',
                description: 'Identify critical shortages, stockout risks, and urgent procurement needs',
                icon: '',
                options: [
                    'Which items are in critical shortage despite an active tender/RC?',
                    'Which items are stuck due to tender delay + RC expiry overlap?'
                ]
            }
        ];

        function generatePromptCards() {
            const grid = document.getElementById('promptsGridHost');
            if (!grid) return;

            grid.innerHTML = '';

            // Generate cards from existing promptCards array
            if (typeof promptCards !== 'undefined') {
                promptCards.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'prompt-card';
                    cardElement.dataset.card = card.id;

                    // Generate prompt options HTML
                    const optionsHTML = card.options.map(option => 
                        `<div class="prompt-option" onclick="insertPromptToGallery(this)">${option}</div>`
                    ).join('');

                    cardElement.innerHTML = `
                        <div class="card-header">
                            <div class="card-icon">${card.icon}</div>
                            <h3 class="card-title">${card.title}</h3>
                            <button class="dropdown-toggle" onclick="toggleCardDropdown(event, this)">
                                <i class="fa fa-chevron-down"></i>
                            </button>
                        </div>
                        <p class="card-description">${card.description}</p>
                        <div class="card-expanded-content">
                            ${optionsHTML}
                        </div>
                    `;

                    grid.appendChild(cardElement);
                });
            }

            // Also generate custom cards from globalPromptCards
            const customCards = globalPromptCards.filter(card => card.type === 'custom');
            customCards.forEach((cardData) => {
                const cardElement = createCGMSCLCardElement(cardData);
                grid.appendChild(cardElement);
            });

            // Initialize card dropdown functionality
            initializeCardDropdowns();
        }



        function initializeCardDropdowns() {
            const allCards = document.querySelectorAll('.prompt-card');
            
            allCards.forEach(card => {
                // Add dropdown toggle functionality to card click
                card.addEventListener('click', function(e) {
                    // Prevent clicks on dropdown toggle button from double-triggering
                    if (e.target.closest('.dropdown-toggle')) {
                        return;
                    }
                    
                    // Find the dropdown toggle button in this card
                    const dropdownToggle = card.querySelector('.dropdown-toggle');
                    if (dropdownToggle) {
                        toggleCardDropdown(event, dropdownToggle);
                    }
                });
            });
        }

        function toggleCardDropdown(eventOrButton, maybeButton) {
            // Support being called as toggleCardDropdown(event, this) and toggleCardDropdown(this)
            let event = null;
            let button = null;
            if (maybeButton) {
                event = eventOrButton;
                button = maybeButton;
            } else {
                button = eventOrButton;
            }
            if (event && typeof event.stopPropagation === 'function') event.stopPropagation();

            const card = button.closest('.prompt-card, .prompt-card-extended');
            const expandedContent = card.querySelector('.card-expanded-content');
            const chevron = button.querySelector('i');
            
            // Check current state before closing all dropdowns
            const wasExpanded = expandedContent.classList.contains('expanded');
            
            // Close ALL dropdowns first (main, extended, and expanded content)
            closeAllDropdowns();
            
            // Toggle expanded state - only open if it wasn't expanded before
            if (!wasExpanded) {
                expandedContent.classList.add('expanded');
                button.classList.add('rotated');
                chevron.className = 'fa fa-chevron-up';
            }
            // Note: If it was expanded, it's already closed by closeAllDropdowns()
        }

        function insertPrompt(promptElement) {
            event.stopPropagation();
            const promptText = promptElement.textContent.trim();
            
            // Insert into chat input
            const chatInput = document.querySelector('.chat-input') || 
                             document.querySelector('input[placeholder*="message"]') ||
                             document.getElementById('user-input');
            
            if (chatInput) {
                chatInput.value = promptText;
                chatInput.focus();
            }
            
            // Close the prompt gallery modal
            closePromptGallery();
            
            // Auto-send the message if in chat mode
            const userInput = document.getElementById('user-input');
            if (userInput && userInput.offsetParent !== null) {
                setTimeout(() => {
                    const sendButton = document.getElementById('send-button');
                    if (sendButton) {
                        sendButton.click();
                    }
                }, 100);
            }
        }

        // Note: Previously disabled stub functions removed to enable working searchPrompts(query)

        function extractSearchData(card) {
            const title = card.querySelector('.card-title')?.textContent.toLowerCase() || '';
            const description = card.querySelector('.card-description')?.textContent.toLowerCase() || '';
            
            // Extract all prompt options
            const promptOptions = Array.from(card.querySelectorAll('.prompt-option, .dropdown-item, .dropdown-item-main, .dropdown-item-extended'))
                .map(option => option.textContent.toLowerCase())
                .join(' ');
            
            // Extract tags/keywords from card classes
            const tags = Array.from(card.classList)
                .filter(cls => cls.includes('prompt') || cls.includes('card'))
                .join(' ');
            
            return {
                title,
                description,
                promptOptions,
                tags,
                fullText: `${title} ${description} ${promptOptions} ${tags}`.trim()
            };
        }

        function calculateMatchScore(query, searchData) {
            if (!query) return 0;
            
            let score = 0;
            const { title, description, promptOptions, fullText } = searchData;
            
            // Exact title match (highest priority)
            if (title === query) score += 100;
            else if (title.includes(query)) score += 50;
            
            // Title starts with query
            if (title.startsWith(query)) score += 30;
            
            // Description match
            if (description.includes(query)) score += 25;
            
            // Prompt options match
            if (promptOptions.includes(query)) score += 20;
            
            // Word boundary matches (more precise)
            const wordBoundaryRegex = new RegExp(`\\b${query}\\b`, 'gi');
            if (wordBoundaryRegex.test(fullText)) score += 15;
            
            // Partial word matches
            const partialRegex = new RegExp(query, 'gi');
            const matches = fullText.match(partialRegex);
            if (matches) score += matches.length * 5;
            
            // Bonus for shorter, more specific queries
            if (query.length <= 3) score += 10;
            
            return score;
        }

        function highlightSearchTerms(card, query) {
            if (!query) return;
            
            const elements = [
                card.querySelector('.card-title'),
                card.querySelector('.card-description')
            ].filter(Boolean);
            
            elements.forEach(element => {
                // Only set data-original once
                if (!element.getAttribute('data-original')) {
                    element.setAttribute('data-original', element.textContent);
                }
                const originalText = element.getAttribute('data-original');
                element.innerHTML = highlightText(originalText, query);
            });
        }


        function highlightText(text) { return text; }
        // Note: Deprecated stub removed to avoid overriding the real clearSearch()

        function updateSearchStats(visibleCount, totalCount) {
            // Create or update search stats display
            let statsElement = document.querySelector('.search-stats');
            if (!statsElement) {
                statsElement = document.createElement('div');
                statsElement.className = 'search-stats';
                statsElement.style.cssText = `
                    position: absolute;
                    top: 50px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    z-index: 1001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.querySelector('.CGMSCL-prompt-gallery-modal').appendChild(statsElement);
            }
            // Always hidden since search removed
            statsElement.style.opacity = '0';
        }

        // Deprecated: legacy UI helper retained under a different name to avoid overriding main showNoResultsMessage(query)
        function showNoResultsMessageDeprecated(show) {
            let noResultsDiv = document.querySelector('.no-results-message');
            
            if (show && !noResultsDiv) {
                noResultsDiv = document.createElement('div');
                noResultsDiv.className = 'no-results-message';
                noResultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #6b7280;">
                        <i class="fa fa-search" style="font-size: 48px; margin-bottom: 16px; color: #d1d5db;"></i>
                        <h3 style="margin: 0 0 8px 0; color: #374151;">No prompts found</h3>
                        <p style="margin: 0;">Try adjusting your search terms</p>
                    </div>
                `;
                document.querySelector('.prompts-grid').appendChild(noResultsDiv);
            } else if (!show && noResultsDiv) {
                noResultsDiv.remove();
            }
        }

        function initializeGalleryEventListeners() {
            // Backdrop click to close modal
            const backdrop = document.querySelector('.gallery-backdrop');
            if (backdrop) {
                backdrop.addEventListener('click', closePromptGallery);
            }

            // Add keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                const searchInput = document.querySelector('.prompt-search-input');
                
                // Ctrl/Cmd + F to focus search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    if (searchInput) {
                        searchInput.focus();
                    }
                }
                
                // Escape to clear search
                if (e.key === 'Escape' && document.activeElement === searchInput) {
                    clearSearch();
                }
            });
        }

        // Settings Dropdown Functions
        function toggleSettingsDropdown() {
            const dropdown = document.getElementById('settingsDropdown');
            const button = document.querySelector('.settings-btn');
            
            dropdown.classList.toggle('show');
            button.classList.toggle('active');
            
            // Close dropdown when clicking outside
            if (dropdown.classList.contains('show')) {
                document.addEventListener('click', closeSettingsOnOutsideClick);
            } else {
                document.removeEventListener('click', closeSettingsOnOutsideClick);
            }
        }

        function closeSettingsOnOutsideClick(event) {
            const dropdown = document.getElementById('settingsDropdown');
            const button = document.querySelector('.settings-btn');
            
            // Don't close if clicking on dropdown options
            if (event.target.closest('.dropdown-option')) {
                return;
            }
            
            if (!event.target.closest('.settings-dropdown')) {
                dropdown.classList.remove('show');
                button.classList.remove('active');
                document.removeEventListener('click', closeSettingsOnOutsideClick);
            }
        }

        // Global data structure for prompt cards (landing page)
        let globalPromptCards = [
            // Tender Tracking card, shared conceptually with Prompt Gallery bucket
            {
                id: 'tender-tracking-main',
                type: 'main',
                icon: '',
                title: 'Tender Tracking',
                description: 'Track tenders, rate contracts, and performance KPIs',
                prompts: [
                    'Show items whose RC expires soon (<90 days)',
                    'Give me all of the items which have valid rate contracts',
                    'Average bids per tender?',
                    'Categories with best RC coverage',
                    'Categories with best RC coverage, also give me the Pareto chart for this as well',
                    'EDL 2025 items vs non-EDL bids?',
                    'List the worst performing tenders',
                    'What is the average time taken for a tender from start to finish',
                    'Which tenders are due for publication this month?'
                ]
            },
            // PO Tracking card for purchase order analytics
            {
                id: 'po-tracking-main',
                type: 'main',
                icon: '',
                title: 'PO Tracking',
                description: 'Analyze purchase orders, supplier KPIs, and delivery performance',
                prompts: [
                    'Which items have supply < 50% of PO quantity?',
                    'Which POs are delayed beyond delivery SLA?',
                    'Which high-priority items have pending inward at WH?',
                    'Which POs have partial supply (<50%)?',
                    'Which items have been awarded and which are pending award?',
                    'For Item Oxytocin Injection IP , has PO been issued to the vendor?',
                    'What is the PO execution status of Item Oxytocin Injection IP?',
                    'What is the supply status of PO for Item Multivitamin + Multimineral Syrup 200 ml ?',
                    'PO-wise supply status (drug, quantity, percentage supplied).',
                    'POs where partial supplies were made but balance overdue.',
                    'Vendors who have defaulted in timely supply.',
                    'Which POs are nearing expiry of delivery period?',
                    'PO-wise inward delays at WH.'
                ]
            },
            // Tender-level Monitoring card
            {
                id: 'tender-level-monitoring-main',
                type: 'main',
                icon: '',
                title: 'Tender-level Monitoring',
                description: 'Monitor tender status, delays, vendor participation, and award status',
                prompts: [
                    'What is the current status of Tender No. XYZ (stage-wise)?',
                    'Which tenders are delayed and may impact supply?',
                    'Which items in this tender received single-vendor bids?',
                    'Vendor participation summary item-wise for this tender, tender no. 164',
                    'Items where bidders were disqualified during PQ or technical evaluation.',
                    'Which items have abnormally high quotes compared to previous RC?',
                    'Which items have been awarded and which are pending award?',
                    'For Item Oxytocin Injection IP, has PO been issued to the vendor?',
                    'Which items have supply < 50% of PO quantity?'
                ]
            },
            // Rate Contract (RC)  Critical Questions card
            {
                id: 'rate-contract-critical-main',
                type: 'main',
                icon: '',
                title: 'Rate Contract (RC)  Critical Questions',
                description: 'Monitor RC expiry, extensions, vendor watch, and transition requirements',
                prompts: [
                    'When does the RC for Item X expire?',
                    'Which RCs expire within 30/60/90 days?',
                    'Items requiring immediate RC extension or fresh tendering.',
                    'Which RC vendors are under watch due to QC failures?',
                    'Which items need transition from old RC to new tender?',
                    'Which RC items have repeated supply delays?',
                    'Items needing emergency procurement due to RC-Tender gap.'
                ]
            },
            // Procurement Execution card
            {
                id: 'procurement-execution-main',
                type: 'main',
                icon: '',
                title: 'Procurement Execution (PO, Supply, Vendor Performance)',
                description: 'Track QC status, NSQ items, hold batches, and vendor performance',
                prompts: [
                    'Item-wise QC hold batches blocking supply.',
                    'Vendors whose QC failures are delaying supplies for tender/RC items.'
                ]
            },
            // High-Priority Exception & Alert Questions card
            {
                id: 'high-priority-exceptions-main',
                type: 'main',
                icon: '',
                title: 'High-Priority Exception & Alert Questions',
                description: 'Identify critical shortages, stockout risks, and urgent procurement needs',
                prompts: [
                    'Which items are in critical shortage despite an active tender/RC?',
                    'Which items are stuck due to tender delay + RC expiry overlap?'
                ]
            }
        ];

        // Add New Prompt Functionality
        function addNewPrompt() {
            // Close main page settings dropdown if it exists
            const mainSettingsDropdown = document.querySelector('.settings-menu[aria-hidden="false"]');
            if (mainSettingsDropdown) {
                const settingsBtn = document.querySelector('.settings-btn i.fa-ellipsis-v')?.closest('.settings-btn');
                if (settingsBtn) {
                    settingsBtn.setAttribute('aria-expanded', 'false');
                    mainSettingsDropdown.setAttribute('aria-hidden', 'true');
                }
            }
            
            // Close CGMSCL gallery dropdown if it exists
            const CGMSCLDropdown = document.getElementById('settingsDropdown');
            if (CGMSCLDropdown && CGMSCLDropdown.classList.contains('show')) {
                toggleSettingsDropdown();
            }
            
            // Create modal for adding new prompt
            const addModal = document.createElement('div');
            addModal.className = 'add-prompt-modal';
            addModal.innerHTML = `
                <div class="modal-backdrop" onclick="closeAddModal()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>Add New Prompt</h3>
                            <button type="button" class="modal-close" onclick="closeAddModal()">&times;</button>
                        </div>
                        <form onsubmit="saveNewPrompt(event)">
                            <div class="form-group">
                                <label>Title:</label>
                                <input type="text" id="newPromptTitle" required>
                            </div>
                            <div class="form-group">
                                <label>Description:</label>
                                <textarea id="newPromptDescription" required></textarea>
                            </div>
                            <div class="form-group">
                                <label>Prompt Options (one per line):</label>
                                <textarea id="newPromptOptions" placeholder="Enter each prompt option on a new line" rows="4"></textarea>
                                <small>Enter each prompt option on a separate line. If left empty, the description will be used as the single prompt.</small>
                            </div>
                            <div class="form-group">
                                <label>Icon (Font Awesome class):</label>
                                <input type="text" id="newPromptIcon" placeholder="fa fa-lightbulb">
                            </div>
                            <div class="form-actions">
                                <button type="button" onclick="closeAddModal()">Cancel</button>
                                <button type="submit">Add Prompt</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            document.body.appendChild(addModal);
        }

        function saveNewPrompt(event) {
            event.preventDefault();
            
            const title = document.getElementById('newPromptTitle').value;
            const description = document.getElementById('newPromptDescription').value;
            const icon = document.getElementById('newPromptIcon').value || 'fa fa-star';
            const promptOptionsText = document.getElementById('newPromptOptions').value;
            
            // Parse prompt options from textarea (one per line)
            let options = [];
            if (promptOptionsText.trim()) {
                options = promptOptionsText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
            }
            
            // If no options provided, use description as single option
            if (options.length === 0) {
                options = [description];
            }
            
            // Create new card data
            const newCardData = {
                id: `custom-${Date.now()}`,
                type: 'custom',
                icon: icon,
                title: title,
                description: description,
                prompts: options
            };
            
            // Add to global data structure
            globalPromptCards.push(newCardData);
            
            // Add card to all three locations
            addCardToAllLocations(newCardData);
            
            closeAddModal();
            showNotification(`Added: ${title}`, 'success');
        }

        function addCardToAllLocations(cardData) {
            // 1. Add to main page (as extended card since it's custom)
            addCardToExtendedPage(cardData);
            
            // 2. Add to CGMSCL gallery
            addCardToCGMSCLGallery(cardData);
            
            // 3. Add to regular prompts grid (if exists)
            addCardToPromptsGrid(cardData);
        }

        function addCardToExtendedPage(cardData) {
            const extendedCardsContainer = document.querySelector('.extended-cards-grid');
            if (extendedCardsContainer) {
                const newCard = createExtendedCardElement(cardData);
                extendedCardsContainer.appendChild(newCard);
            }
        }

        function addCardToCGMSCLGallery(cardData) {
            // Add card to CGMSCL gallery if it's currently open
            const CGMSCLModal = document.getElementById('promptsModal');
            if (CGMSCLModal && CGMSCLModal.open) {
                // Find the CGMSCL gallery grid or create a container for custom cards
                let CGMSCLGrid = document.querySelector('.CGMSCL-prompt-gallery-modal .cards-grid');
                
                if (!CGMSCLGrid) {
                    // Create a grid container if it doesn't exist
                    CGMSCLGrid = document.createElement('div');
                    CGMSCLGrid.className = 'cards-grid';
                    CGMSCLGrid.style.cssText = `
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                        gap: 16px;
                        padding: 20px;
                    `;
                    
                    // Add it to the modal content
                    const modalContent = CGMSCLModal.querySelector('.gallery-content') || CGMSCLModal;
                    modalContent.appendChild(CGMSCLGrid);
                }
                
                // Create and add the card
                const newCard = createCGMSCLCardElement(cardData);
                CGMSCLGrid.appendChild(newCard);
                
                console.log(`Card ${cardData.title} added to CGMSCL gallery`);
            } else {
                console.log(`Card ${cardData.title} added to CGMSCL gallery data (will appear when gallery opens)`);
            }
        }

        function addCardToPromptsGrid(cardData) {
            const promptsGrid = document.querySelector('.prompts-grid');
            if (promptsGrid) {
                const newCard = createPromptsGridCardElement(cardData);
                promptsGrid.appendChild(newCard);
            }
        }

        function createExtendedCardElement(cardData) {
            const card = document.createElement('div');
            card.className = 'prompt-card-extended';
            card.dataset.cardId = cardData.id;
            
            const promptsHtml = cardData.prompts.map(prompt => 
                `<div class="prompt-option" onclick="handleExtendedPromptClick('${prompt.replace(/'/g, "\\'")}')">${prompt}</div>`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header-extended">
                    <div class="card-icon">
                        <i class="${cardData.icon}"></i>
                    </div>
                    <h3 class="card-title">${cardData.title}</h3>
                    <button class="dropdown-toggle" onclick="toggleCardDropdown(this)">
                        <i class="fa fa-chevron-down"></i>
                    </button>
                </div>
                <p class="card-description">${cardData.description}</p>
                <div class="card-expanded-content">
                    ${promptsHtml}
                </div>
            `;
            
            return card;
        }

        function createPromptsGridCardElement(cardData) {
            const card = document.createElement('div');
            card.className = 'prompt-card';
            card.dataset.cardId = cardData.id;
            
            const promptsHtml = cardData.prompts.map(prompt => 
                `<div class="prompt-option" onclick="insertPromptToGallery(this)">${prompt}</div>`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header">
                    <div class="card-icon">
                        <i class="${cardData.icon}"></i>
                    </div>
                    <h3 class="card-title">${cardData.title}</h3>
                    <button class="dropdown-toggle" onclick="toggleCardDropdown(this)">
                        <i class="fa fa-chevron-down"></i>
                    </button>
                </div>
                <p class="card-description">${cardData.description}</p>
                <div class="card-expanded-content">
                    ${promptsHtml}
                </div>
            `;
            
            return card;
        }

        function closeAddModal() {
            const modal = document.querySelector('.add-prompt-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Edit Prompt Functionality
        let editingCard = null;

        function editPrompt() {
            // Close settings dropdown if it exists (for main settings)
            const mainSettingsDropdown = document.querySelector('.settings-menu[aria-hidden="false"]');
            if (mainSettingsDropdown) {
                const settingsBtn = document.querySelector('.settings-btn');
                if (settingsBtn) {
                    settingsBtn.setAttribute('aria-expanded', 'false');
                    mainSettingsDropdown.setAttribute('aria-hidden', 'true');
                }
            }
            
            // Also close CGMSCL gallery dropdown if it exists
            toggleSettingsDropdown();
            
            // Enable edit mode for all prompt cards (main and extended)
            const allCards = document.querySelectorAll('.prompt-card, .prompt-card-main, .prompt-card-extended');
            allCards.forEach(card => {
                card.classList.add('edit-mode');
                card.onclick = () => openEditModal(card);
            });
            
            showNotification('Select a prompt card to edit', 'info');
            
            // Add cancel edit mode button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel Edit Mode';
            cancelBtn.className = 'cancel-edit-btn';
            cancelBtn.onclick = cancelEditMode;
            document.querySelector('.gallery-header').appendChild(cancelBtn);
        }

        function openEditModal(card) {
            editingCard = card;
            const title = card.querySelector('.card-title').textContent;
            const description = card.querySelector('.card-description').textContent;
            // Collect prompt options for any card type
            let optionNodes = Array.from(card.querySelectorAll('.card-expanded-content .prompt-option'));
            if (optionNodes.length === 0) {
                // Fallback for main cards that use dropdown content
                optionNodes = Array.from(card.querySelectorAll('.dropdown-content-main .dropdown-item-main'));
            }
            const options = optionNodes.map(node => node.textContent.trim());
            
            const editModal = document.createElement('div');
            editModal.className = 'edit-prompt-modal';
            editModal.innerHTML = `
                <div class="modal-backdrop" onclick="closeEditModal()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>Edit Prompt</h3>
                            <button type="button" class="modal-close" onclick="closeEditModal()">&times;</button>
                        </div>
                        <form onsubmit="saveEditedPrompt(event)">
                            <div class="form-group">
                                <label>Title:</label>
                                <input type="text" id="editPromptTitle" value="${title}" required>
                            </div>
                            <div class="form-group">
                                <label>Description:</label>
                                <textarea id="editPromptDescription" required>${description}</textarea>
                            </div>
                            <div class="form-group">
                                <label>Prompts:</label>
                                <div id="editPromptList">
                                    ${options.map((opt, idx) => `
                                        <div class="prompt-edit-row">
                                            <input type="text" class="editPromptOption" data-index="${idx}" value="${opt.replace(/"/g, '&quot;')}">
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div class="form-actions">
                                <button type="button" onclick="closeEditModal()">Cancel</button>
                                <button type="submit">Save Changes</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            document.body.appendChild(editModal);
        }

        function saveEditedPrompt(event) {
            event.preventDefault();
            
            const newTitle = document.getElementById('editPromptTitle').value;
            const newDescription = document.getElementById('editPromptDescription').value;
            const optionInputs = Array.from(document.querySelectorAll('.editPromptOption'));
            
            if (editingCard) {
                editingCard.querySelector('.card-title').textContent = newTitle;
                editingCard.querySelector('.card-description').textContent = newDescription;
                // Update prompt options text depending on card structure
                let optionNodes = Array.from(editingCard.querySelectorAll('.card-expanded-content .prompt-option'));
                if (optionNodes.length > 0) {
                    // Extended/grid cards
                    optionInputs.forEach((input, i) => {
                        if (optionNodes[i]) {
                            optionNodes[i].textContent = input.value.trim();
                        }
                    });
                } else {
                    // Main cards with dropdown content
                    optionNodes = Array.from(editingCard.querySelectorAll('.dropdown-content-main .dropdown-item-main'));
                    optionInputs.forEach((input, i) => {
                        if (optionNodes[i]) {
                            const newText = input.value.trim();
                            optionNodes[i].textContent = newText;
                            // Update onclick to pass the new text
                            const escaped = newText.replace(/'/g, "\\'");
                            optionNodes[i].setAttribute('onclick', `handleMainPromptClick('${escaped}')`);
                        }
                    });
                }
            }
            
            closeEditModal();
            cancelEditMode();
            showNotification('Prompt updated successfully!', 'success');
        }

        function closeEditModal() {
            const modal = document.querySelector('.edit-prompt-modal');
            if (modal) modal.remove();
        }

        function cancelEditMode() {
            const allCards = document.querySelectorAll('.prompt-card, .prompt-card-main, .prompt-card-extended');
            allCards.forEach(card => {
                card.classList.remove('edit-mode');
                card.onclick = null;
            });
            
            const cancelBtn = document.querySelector('.cancel-edit-btn');
            if (cancelBtn) cancelBtn.remove();
        }


        // Delete Prompt Functionality
        function deletePrompt() {
            // Close settings dropdown if it exists (for main settings)
            const mainSettingsDropdown = document.querySelector('.settings-menu[aria-hidden="false"]');
            if (mainSettingsDropdown) {
                const settingsBtn = document.querySelector('.settings-btn');
                if (settingsBtn) {
                    settingsBtn.setAttribute('aria-expanded', 'false');
                    mainSettingsDropdown.setAttribute('aria-hidden', 'true');
                }
            }
            
            // Also close CGMSCL gallery dropdown if it exists
            toggleSettingsDropdown();
            
            // Enable delete mode for all prompt cards (main and extended)
            const allCards = document.querySelectorAll('.prompt-card, .prompt-card-main, .prompt-card-extended');
            allCards.forEach(card => {
                card.classList.add('delete-mode');
                card.onclick = () => confirmDelete(card);
            });
            
            showNotification('Select a prompt card to delete', 'warning');
            
            // Add cancel delete mode button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel Delete Mode';
            cancelBtn.className = 'cancel-delete-btn';
            cancelBtn.onclick = cancelDeleteMode;
            document.querySelector('.gallery-header').appendChild(cancelBtn);
        }

        function confirmDelete(card) {
            const title = card.querySelector('.card-title').textContent;
            
            if (confirm(`Are you sure you want to delete "${title}"? This action cannot be undone.`)) {
                card.remove();
                cancelDeleteMode();
                showNotification('Prompt deleted successfully!', 'success');
            }
        }

        function cancelDeleteMode() {
            const allCards = document.querySelectorAll('.prompt-card');
            allCards.forEach(card => {
                card.classList.remove('delete-mode');
                card.onclick = null;
            });
            
            const cancelBtn = document.querySelector('.cancel-delete-btn');
            if (cancelBtn) cancelBtn.remove();
        }


        // sendFromCenteredInput function removed - old search box functionality

        function toggleMorePrompts() {
            const extendedCards = document.getElementById('extended-prompt-cards');
            const seeMoreBtn = document.getElementById('see-more-btn');
            const arrow = seeMoreBtn.querySelector('i');
            
            if (extendedCards.classList.contains('hidden') || extendedCards.style.display === 'none') {
                // Show cards with smooth transition
                extendedCards.style.display = 'block';
                seeMoreBtn.querySelector('span').textContent = 'See less';
                if (arrow) {
                    arrow.className = 'fa fa-chevron-up';
                    arrow.style.color = '#6B7280';
                }
                
                // Trigger smooth reveal animation
                setTimeout(() => {
                    extendedCards.classList.remove('hidden');
                    
                    // Remove Coming Soon cards after cards are displayed
                    removeComingSoonCards();
                    
                    // Initialize dropdown functionality for the newly shown cards
                    setTimeout(() => {
                        initializeAllCardDropdowns();
                        attachDropdownListeners();
                    }, 100);
                }, 10);
                
            } else {
                // Hide cards with smooth transition
                extendedCards.classList.add('hidden');
                seeMoreBtn.querySelector('span').textContent = 'See more';
                if (arrow) {
                    arrow.className = 'fa fa-chevron-down';
                    arrow.style.color = '#6B7280';
                }
                
                // Hide completely after animation
                setTimeout(() => {
                    extendedCards.style.display = 'none';
                }, 400);
            }
        }

        // Function to remove Coming Soon cards
        function removeComingSoonCards() {
            // Select all cards in the extended grid
            const allCards = document.querySelectorAll('.extended-cards-grid .prompt-card-extended');
            
            allCards.forEach(card => {
                // Check for Coming Soon text in title
                const titleElement = card.querySelector('.card-title, h3');
                const contentElement = card.querySelector('.card-description, p');
                
                // Check if card contains "Coming Soon" text
                const hasComingSoonTitle = titleElement && titleElement.textContent.includes('Coming Soon');
                const hasComingSoonContent = contentElement && (
                    contentElement.textContent.includes('Additional features will be added') ||
                    contentElement.textContent.includes('be added here')
                );
                
                // Check if card has placeholder styling
                const isPlaceholder = card.classList.contains('placeholder-card') ||
                                     card.classList.contains('placeholder') ||
                                     card.hasAttribute('data-placeholder');
                
                // Hide the card if it matches any criteria
                if (hasComingSoonTitle || hasComingSoonContent || isPlaceholder) {
                    card.style.display = 'none';
                    console.log('Hidden Coming Soon card:', titleElement?.textContent || 'Unknown');
                }
            });
            
            console.log('Coming Soon cards removed from extended grid');
        }

        function loadChatHistory() {
            try {
                const stored = localStorage.getItem('allChatHistory');
                if (stored) {
                    window.allChatHistory = JSON.parse(stored);
                } else {
                    window.allChatHistory = [];
                }
            } catch (e) {
                console.warn('Failed to load chat history:', e);
                window.allChatHistory = [];
            }
        }

        function saveChatToHistory() {
            if (!chatHistory || chatHistory.length === 0) return;
            
            // Reuse current local chat id if exists; otherwise create one
            if (!window.currentLocalChatId) {
                window.currentLocalChatId = Date.now();
            }
            const chatSession = {
                id: window.currentLocalChatId,
                timestamp: new Date().toISOString(),
                title: generateChatTitle(chatHistory),
                messages: [...chatHistory]
            };
            
            if (!window.allChatHistory) window.allChatHistory = [];
            window.allChatHistory.unshift(chatSession);
            
            // Keep only last 20 chats
            if (window.allChatHistory.length > 20) {
                window.allChatHistory = window.allChatHistory.slice(0, 20);
            }
            
            localStorage.setItem('allChatHistory', JSON.stringify(window.allChatHistory));
            updateChatHistoryDisplay();
        }

        function generateChatTitle(messages) {
            const firstUserMessage = messages.find(m => m.role === 'user');
            if (firstUserMessage) {
                const text = firstUserMessage.text;
                return text.length > 50 ? text.substring(0, 50) + '...' : text;
            }
            return 'New Chat';
        }

        function updateChatHistoryDisplay() {
            // Sidebar removed - chat history display no longer needed
            return;
        }

        function updateSessionDisplay(limits) {
            // Update session info display if element exists
            const sessionInfo = document.getElementById('session-info');
            if (sessionInfo && limits) {
                sessionInfo.innerHTML = `
                    <div class="session-stats">
                        <span class="session-limit">Queries: 0/${limits.max_queries}</span>
                        <span class="session-id" title="${window.currentSessionId}">Session: ${window.currentSessionId.slice(-8)}</span>
                    </div>
                `;
            }
        }

        function updateSessionStats(queryCount, maxQueries) {
            const sessionInfo = document.getElementById('session-info');
            if (sessionInfo) {
                const limitSpan = sessionInfo.querySelector('.session-limit');
                if (limitSpan) {
                    limitSpan.textContent = `Queries: ${queryCount}/${maxQueries}`;
                    
                    // Add warning styling if approaching limit
                    if (queryCount >= maxQueries - 1) {
                        limitSpan.classList.add('session-limit-warning');
                    } else if (queryCount >= maxQueries - 2) {
                        limitSpan.classList.add('session-limit-caution');
                    } else {
                        limitSpan.classList.remove('session-limit-warning', 'session-limit-caution');
                    }
                }
            }
        }

        function updateSessionStatsFromResponse(data) {
            // Check if response contains session limit information
            if (data.responses && data.responses[0] && data.responses[0].includes('Session Query Limit Reached')) {
                // Session limit reached, show warning
                const sessionInfo = document.getElementById('session-info');
                if (sessionInfo) {
                    sessionInfo.style.display = 'block';
                    const limitSpan = sessionInfo.querySelector('.session-limit');
                    if (limitSpan) {
                        limitSpan.textContent = 'Queries: 7/7 (LIMIT REACHED)';
                        limitSpan.classList.add('session-limit-warning');
                    }
                }
                return;
            }
            
            // Fetch current session stats from server
            if (window.currentSessionId) {
                fetch(`/session-stats/${window.currentSessionId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.session_stats.exists) {
                        const stats = data.session_stats;
                        updateSessionStats(stats.query_count, 7); // Max 7 queries
                        
                        // Show session info if not already visible
                        const sessionInfo = document.getElementById('session-info');
                        if (sessionInfo) {
                            sessionInfo.style.display = 'block';
                        }
                    }
                })
                .catch(err => {
                    console.warn('Failed to fetch session stats:', err);
                });
            }
        }

        async function loadServerChatSession(sessionId) {
            try {
                const token = localStorage.getItem('authToken');
                if (!token) throw new Error('Not authenticated');
                const res = await fetch(`/chat/session/${sessionId}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!res.ok) throw new Error(`Failed to load session ${sessionId}`);
                const data = await res.json();
                // Map server messages to UI format
                chatHistory = (data.messages || []).map(m => ({
                    role: m.role,
                    text: m.content,
                    timestamp: m.created_at
                }));
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                // Use this server session id for subsequent sends
                window.currentSessionId = data.session_id || sessionId;
                // Switch to chat view
                document.getElementById('welcome-screen').style.display = 'none';
                document.getElementById('chat-area').style.display = 'flex';
                // Show glassmorphism header
                const glassmorphismHeader = document.getElementById('chat-glassmorphism-header');
                if (glassmorphismHeader) {
                    glassmorphismHeader.style.display = 'flex';
                }
                toggleFloatingButton(true);
                // Render
                const chatContainer = document.getElementById('chat-container');
                chatContainer.innerHTML = '';
                chatHistory.forEach(message => renderMessage(message));
                scrollToBottom();
            } catch (e) {
                console.error(e);
                displayError('Failed to load chat session');
            }
        }

        // Old centered input event listeners removed

        // Global variables
        window.recognition = null;

        // Global variable to store IP-based timezone info
        let ipTimezoneInfo = null;

        // Timezone conversion utility functions
        function convertISTToLocalTime(istTimestamp) {
            try {
                // Parse the timestamp - handle both ISO strings and IST formatted strings
                let date;
                
                if (typeof istTimestamp === 'string') {
                    // Check if it's an ISO string
                    if (istTimestamp.includes('T') || istTimestamp.includes('Z')) {
                        date = new Date(istTimestamp);
                    } else {
                        // Assume it's IST format and parse accordingly
                        // IST is UTC+5:30
                        date = new Date(istTimestamp + '+05:30');
                    }
                } else {
                    date = new Date(istTimestamp);
                }
                
                // Check if date is valid
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', istTimestamp);
                    return istTimestamp; // Return original if invalid
                }
                
                // Use IP-based timezone if available, otherwise fallback to browser timezone
                if (ipTimezoneInfo && ipTimezoneInfo.success) {
                    // Convert to IP-based timezone
                    const utcTime = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
                    const ipTime = new Date(utcTime.getTime() + (parseInt(ipTimezoneInfo.timezone_offset) * 3600000));
                    
                    return ipTime.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                } else {
                    // Fallback to browser timezone
                    return date.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
            } catch (error) {
                console.error('Error converting timestamp:', error);
                return istTimestamp; // Return original on error
            }
        }

        // Global configuration for time display
        window.timeDisplayConfig = {
            use12Hour: true, // Default to 12-hour format
            showTimezone: true,
            showLanguage: false
        };

        // Enhanced time display function with timezone and language information
        function getLocalTimeString(use12Hour = null) {
            try {
                // Use global config if no parameter provided
                const format12Hour = use12Hour !== null ? use12Hour : window.timeDisplayConfig.use12Hour;
                
                // Detect timezone using Intl.DateTimeFormat
                const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                
                // Get user's language from navigator
                const userLanguage = navigator.language || 'en-US';
                
                // Format options for time display
                const options = {
                    timeZone: timeZone,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: format12Hour,
                    timeZoneName: 'short'
                };
                
                // Format the current time
                const now = new Date();
                const timeString = now.toLocaleString(userLanguage, options);
                
                // Get timezone abbreviation separately for more reliable display
                const timeZoneOptions = {
                    timeZone: timeZone,
                    timeZoneName: 'short'
                };
                const timeZoneAbbr = new Intl.DateTimeFormat(userLanguage, timeZoneOptions)
                    .formatToParts(now)
                    .find(part => part.type === 'timeZoneName')?.value || 'UTC';
                
                // Build the enhanced time string
                let enhancedTimeString = timeString;
                
                // Add IANA timezone information if enabled
                if (window.timeDisplayConfig.showTimezone) {
                    if (timeZone && timeZone !== 'UTC') {
                        enhancedTimeString += ` in ${timeZone}`;
                    } else if (!timeZone) {
                        enhancedTimeString += ' in UTC (Time zone not detected, using UTC)';
                    } else {
                        enhancedTimeString += ' in UTC';
                    }
                }
                
                // Add language hint if enabled
                if (window.timeDisplayConfig.showLanguage) {
                    enhancedTimeString += ` (Language: ${userLanguage})`;
                }
                
                return enhancedTimeString;
                
            } catch (error) {
                console.warn('Error in getLocalTimeString:', error);
                
                // Fallback to basic time display
                try {
                    const now = new Date();
                    const fallbackTime = now.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: format12Hour
                    });
                    return `${fallbackTime} UTC (Language: en-US) - Error: ${error.message}`;
                } catch (fallbackError) {
                    return `Time display error: ${error.message}`;
                }
            }
        }

        function formatTimestampForDisplay(timestamp) {
            // Use the enhanced time display for current messages
            // For historical timestamps, convert them to local time first
            try {
                let date;
                
                if (typeof timestamp === 'string') {
                    if (timestamp.includes('T') || timestamp.includes('Z')) {
                        date = new Date(timestamp);
                    } else {
                        date = new Date(timestamp + '+05:30');
                    }
                } else {
                    date = new Date(timestamp);
                }
                
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', timestamp);
                    return getLocalTimeString(); // Return current time if invalid
                }
                
                // For historical messages, show the converted time with enhanced format
                const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const userLanguage = navigator.language || 'en-US';
                
                const options = {
                    timeZone: timeZone,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: window.timeDisplayConfig.use12Hour,
                    timeZoneName: 'short'
                };
                
                const timeString = date.toLocaleString(userLanguage, options);
                const timeZoneAbbr = new Intl.DateTimeFormat(userLanguage, { timeZone, timeZoneName: 'short' })
                    .formatToParts(date)
                    .find(part => part.type === 'timeZoneName')?.value || 'UTC';
                
                let enhancedTimeString = timeString;
                
                // Add IANA timezone information if enabled
                if (window.timeDisplayConfig.showTimezone) {
                    if (timeZone && timeZone !== 'UTC') {
                        enhancedTimeString += ` in ${timeZone}`;
                    } else {
                        enhancedTimeString += ' in UTC';
                    }
                }
                
                // Add language hint if enabled
                if (window.timeDisplayConfig.showLanguage) {
                    enhancedTimeString += ` (Language: ${userLanguage})`;
                }
                
                return enhancedTimeString;
                
            } catch (error) {
                console.warn('Error formatting timestamp:', error);
                return getLocalTimeString(); // Fallback to current time
            }
        }

        // Utility function to toggle time format and update all timestamps
        function toggleTimeFormat(use12Hour = null) {
            try {
                if (use12Hour !== null) {
                    window.timeDisplayConfig.use12Hour = use12Hour;
                } else {
                    window.timeDisplayConfig.use12Hour = !window.timeDisplayConfig.use12Hour;
                }
                
                // Update all existing timestamps
                updateAllTimestamps();
                
                console.log(`Time format switched to ${window.timeDisplayConfig.use12Hour ? '12-hour' : '24-hour'} format`);
                
            } catch (error) {
                console.warn('Error toggling time format:', error);
            }
        }

        // Utility function to toggle timezone display
        function toggleTimezoneDisplay(show = null) {
            try {
                if (show !== null) {
                    window.timeDisplayConfig.showTimezone = show;
                } else {
                    window.timeDisplayConfig.showTimezone = !window.timeDisplayConfig.showTimezone;
                }
                
                // Update all existing timestamps
                updateAllTimestamps();
                
                console.log(`Timezone display ${window.timeDisplayConfig.showTimezone ? 'enabled' : 'disabled'}`);
                
            } catch (error) {
                console.warn('Error toggling timezone display:', error);
            }
        }

        // Utility function to toggle language display
        function toggleLanguageDisplay(show = null) {
            try {
                if (show !== null) {
                    window.timeDisplayConfig.showLanguage = show;
                } else {
                    window.timeDisplayConfig.showLanguage = !window.timeDisplayConfig.showLanguage;
                }
                
                // Update all existing timestamps
                updateAllTimestamps();
                
                console.log(`Language display ${window.timeDisplayConfig.showLanguage ? 'enabled' : 'disabled'}`);
                
            } catch (error) {
                console.warn('Error toggling language display:', error);
            }
        }

        // Function to update all existing timestamps with enhanced format
        function updateAllTimestamps() {
            try {
                const timestampElements = document.querySelectorAll('.timestamp');
                timestampElements.forEach(element => {
                    // Get the current timestamp text
                    const currentText = element.textContent;
                    
                    // Try to extract the original timestamp from the message data
                    const messageElement = element.closest('.message');
                    if (messageElement) {
                        // Look for the message in chatHistory to get the original timestamp
                        const messageIndex = Array.from(messageElement.parentNode.children).indexOf(messageElement);
                        if (chatHistory && chatHistory[messageIndex]) {
                            const originalTimestamp = chatHistory[messageIndex].timestamp;
                            element.textContent = formatTimestampForDisplay(originalTimestamp);
                        } else {
                            // If we can't find the original timestamp, use current time
                            element.textContent = getLocalTimeString();
                        }
                    }
                });
            } catch (error) {
                console.warn('Error updating timestamps:', error);
            }
        }

        // Function to initialize enhanced time display
        function initializeEnhancedTimeDisplay() {
            try {
                // Update all existing timestamps
                updateAllTimestamps();
                
                // Log the detected timezone and language for debugging
                const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const userLanguage = navigator.language || 'en-US';
                console.log('Enhanced time display initialized:');
                console.log('- Timezone:', timeZone);
                console.log('- Language:', userLanguage);
                console.log('- Sample time:', getLocalTimeString());
                
            } catch (error) {
                console.warn('Error initializing enhanced time display:', error);
            }
        }

        // Test function for enhanced time display (can be called from browser console)
        function testEnhancedTimeDisplay() {
            console.log('=== Enhanced Time Display Test ===');
            
            try {
                // Test current time display
                console.log('Current time (12-hour):', getLocalTimeString(true));
                console.log('Current time (24-hour):', getLocalTimeString(false));
                
                // Test with different timestamps
                const testTimestamps = [
                    new Date().toISOString(),
                    '2024-01-15T09:26:01+05:30',
                    '2024-01-15T09:26:01Z',
                    '2024-01-15T09:26:01'
                ];
                
                console.log('\nTesting timestamp formatting:');
                testTimestamps.forEach((timestamp, index) => {
                    console.log(`Test ${index + 1}: ${timestamp} -> ${formatTimestampForDisplay(timestamp)}`);
                });
                
                // Test browser capabilities
                console.log('\nBrowser capabilities:');
                console.log('- Intl.DateTimeFormat supported:', typeof Intl !== 'undefined' && typeof Intl.DateTimeFormat !== 'undefined');
                console.log('- navigator.language:', navigator.language);
                console.log('- Detected timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
                
                // Test configuration
                console.log('\nCurrent configuration:');
                console.log('- 12-hour format:', window.timeDisplayConfig.use12Hour);
                console.log('- Show timezone:', window.timeDisplayConfig.showTimezone);
                console.log('- Show language:', window.timeDisplayConfig.showLanguage);
                
                // Test utility functions
                console.log('\nTesting utility functions:');
                console.log('- toggleTimeFormat() - switches between 12/24 hour');
                console.log('- toggleTimezoneDisplay() - toggles timezone info');
                console.log('- toggleLanguageDisplay() - toggles language info');
                
                console.log('\n=== Test completed successfully ===');
                console.log('Try calling: toggleTimeFormat(), toggleTimezoneDisplay(), toggleLanguageDisplay()');
                
            } catch (error) {
                console.error('Test failed:', error);
            }
        }

        // Function to fetch IP-based timezone information
        async function fetchIPTTimezone() {
            try {
                const response = await fetch('/timezone');
                if (response.ok) {
                    ipTimezoneInfo = await response.json();
                    console.log('IP timezone info:', ipTimezoneInfo);
                    
                    // Update existing timestamps after getting IP timezone
                    convertExistingISTTimestamps();
                    
                    return ipTimezoneInfo;
                } else {
                    console.warn('Failed to fetch IP timezone, using browser timezone');
                    return null;
                }
            } catch (error) {
                console.error('Error fetching IP timezone:', error);
                return null;
            }
        }

        // Test function for timezone conversion (can be called from browser console)
        function testTimezoneConversion() {
            console.log('Testing timezone conversion...');
            console.log('IP timezone info:', ipTimezoneInfo);
            
            // Test with current time
            const now = new Date().toISOString();
            console.log('Current ISO time:', now);
            console.log('Converted to IP timezone:', formatTimestampForDisplay(now));
            
            // Test with IST time (example: 09:26:01 IST)
            const istTime = '2024-01-15T09:26:01+05:30';
            console.log('IST time:', istTime);
            console.log('Converted to IP timezone:', formatTimestampForDisplay(istTime));
            
            // Test with different timezone scenarios
            const testTimes = [
                '2024-01-15T09:26:01+05:30', // IST
                '2024-01-15T09:26:01Z',      // UTC
                '2024-01-15T09:26:01',      // Local assumption
                new Date().toISOString()     // Current time
            ];
            
            testTimes.forEach((time, index) => {
                console.log(`Test ${index + 1}: ${time} -> ${formatTimestampForDisplay(time)}`);
            });
            
            console.log('Timezone conversion test completed.');
        }

        // Function to test IP timezone detection
        async function testIPTTimezone() {
            console.log('Testing IP timezone detection...');
            const result = await fetchIPTTimezone();
            console.log('IP timezone result:', result);
            
            if (result && result.success) {
                console.log(`Detected timezone: ${result.timezone} (${result.timezone_offset})`);
                console.log(`Location: ${result.city}, ${result.country_name}`);
                console.log(`Current time: ${result.current_time}`);
            } else {
                console.log('Failed to detect IP timezone');
            }
        }

        // Function to convert existing IST timestamps on the page
        function convertExistingISTTimestamps() {
            const timestampElements = document.querySelectorAll('.timestamp');
            timestampElements.forEach(element => {
                const text = element.textContent;
                // Check if the text contains IST pattern like "09:26:01 IST"
                const istPattern = /(\d{2}:\d{2}:\d{2})\s*IST/i;
                const match = text.match(istPattern);
                
                if (match) {
                    const timePart = match[1];
                    // Create a date object assuming today's date with the time
                    const today = new Date();
                    const [hours, minutes, seconds] = timePart.split(':');
                    const istDate = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 
                                           parseInt(hours), parseInt(minutes), parseInt(seconds));
                    
                    // Convert IST to UTC (subtract 5:30)
                    const utcDate = new Date(istDate.getTime() - (5.5 * 60 * 60 * 1000));
                    
                    // Use IP-based timezone if available, otherwise browser timezone
                    let localTime;
                    if (ipTimezoneInfo && ipTimezoneInfo.success) {
                        // Convert to IP-based timezone
                        const ipTime = new Date(utcDate.getTime() + (parseInt(ipTimezoneInfo.timezone_offset) * 3600000));
                        localTime = ipTime.toLocaleTimeString('en-US', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                    } else {
                        // Fallback to browser timezone
                        localTime = utcDate.toLocaleTimeString('en-US', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                    }
                    
                    element.textContent = localTime;
                }
            });
        }

        // Auto-convert existing timestamps when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize enhanced time display
            initializeEnhancedTimeDisplay();
            
            // Fetch IP timezone first, then convert timestamps
            await fetchIPTTimezone();
            
            // Small delay to ensure all elements are rendered
            setTimeout(convertExistingISTTimestamps, 100);
        });
        window.isWebSpeechSupported = false;
        window.isRecording = false; // Use single state variable for consistency
        window.isProcessingQueue = false;
        window.isTyping = false;
        window.sheetsModeEnabled = false;
        window.currentPreviewMessageElement = null;
        window.queryQueue = [];
        window.chatHistory = [];
        // Generate new session ID on each page load for fresh session
        window.currentSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Initialize session display
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize session display with default values
            updateSessionDisplay({ max_queries: 7, max_messages: 14 });
        });
        window.currentLocalChatId = null;
        window.serverChatSessions = [];
        window.lastInputWasSpeech = false;
        window.mediaRecorder = null;
        window.audioChunks = [];
        window.chatContainer = document.getElementById('chat-container');
        
        // Text-to-speech variables
        window.currentTTSAudio = null;
        window.isTTSPlaying = false;
        window.lastBotResponse = '';
        window.isTTSIntentionallyStopped = false;
        // PocketSphinx.js implementation for cross-browser speech recognition
        window.pocketSphinxRecognizer = null;
        window.isRecording = false;
        window.finalTranscript = '';
        window.interimTranscript = '';
        window.speechTimeout = null;
        window.silenceTimeout = null; // Timeout for detecting silence
        window.isPocketSphinxSupported = false;
        window.audioContext = null;
        window.mediaStream = null;
        window.scriptProcessor = null;

        // Initialize PocketSphinx.js
        async function initializePocketSphinx() {
            try {
                console.log('Initializing PocketSphinx.js...');
                
                // Check if PocketSphinx is available
                if (typeof PocketSphinx === 'undefined') {
                    console.error('PocketSphinx.js not loaded');
                    return false;
                }

                // For now, use a simplified initialization approach
                // In a production environment, you would host the model files
                console.log('PocketSphinx library detected, attempting initialization...');
                
                // Try to create a basic recognizer instance
                // Note: This might fail if models aren't available, which is expected
                try {
                    window.pocketSphinxRecognizer = new PocketSphinx.Recognizer();
                    
                    // Set up event handlers
                    window.pocketSphinxRecognizer.on('result', (text) => {
                        console.log('PocketSphinx result:', text);
                        handleSpeechResult(text, true); // true indicates final result
                    });

                    window.pocketSphinxRecognizer.on('partialResult', (text) => {
                        console.log('PocketSphinx partial result:', text);
                        handleSpeechResult(text, false); // false indicates interim result
                    });

                    window.pocketSphinxRecognizer.on('error', (error) => {
                        console.error('PocketSphinx error:', error);
                        handleSpeechError(error);
                    });

                    window.isPocketSphinxSupported = true;
                    console.log('PocketSphinx.js initialized successfully');
                    return true;
                    
                } catch (modelError) {
                    console.warn('PocketSphinx models not available, will use Web Speech API fallback:', modelError);
                    window.isPocketSphinxSupported = false;
                    return false;
                }

            } catch (error) {
                console.error('Failed to initialize PocketSphinx.js:', error);
                window.isPocketSphinxSupported = false;
                return false;
            }
        }

        // Fallback to Web Speech API if PocketSphinx fails
        async function initializeWebSpeechFallback() {
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition) {
                    window.recognition = new SpeechRecognition();
                    window.recognition.continuous = true;
                    window.recognition.lang = 'en-US';
                    window.recognition.interimResults = true;
                    window.recognition.maxAlternatives = 1;
                    
                    window.recognition.onstart = () => {
                        console.log('Web Speech recognition started (fallback)');
                        handleSpeechStart();
                    };

                    window.recognition.onend = () => {
                        console.log('Web Speech recognition ended (fallback)');
                        // Always reset the recording state when recognition ends
                        // This ensures proper state management even if manually stopped
                        if (window.isRecording) {
                            handleSpeechEnd();
                        } else {
                            // If isRecording is false but recognition ended, ensure recognition is aborted
                            // This prevents "already started" errors on next click
                            try {
                                if (window.recognition) {
                                    window.recognition.abort();
                                }
                            } catch (e) {
                                // Ignore errors - recognition might already be stopped
                            }
                        }
                    };

                    window.recognition.onresult = (event) => {
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript;
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            handleSpeechResult(finalTranscript, true);
                        }
                        if (interimTranscript) {
                            handleSpeechResult(interimTranscript, false);
                        }
                    };

                    window.recognition.onerror = (event) => {
                        console.error('Web Speech recognition error (fallback):', event.error);
                        handleSpeechError(event.error);
                    };

                    window.isWebSpeechSupported = true;
                    console.log('Web Speech API fallback initialized');
                    return true;
                }
            } catch (e) {
                console.warn('Web Speech API not supported:', e);
                window.isWebSpeechSupported = false;
            }
            return false;
        }

        // Common speech result handler
        function handleSpeechResult(text, isFinal) {
            // Don't process results if recording was manually stopped
            if (!window.isRecording) {
                console.log('Ignoring speech result - recording stopped');
                return;
            }
            
            // Reset silence timeout when we receive any speech input
            if (window.silenceTimeout) {
                clearTimeout(window.silenceTimeout);
                window.silenceTimeout = null;
            }
            
            if (isFinal) {
                window.finalTranscript = text;
                window.interimTranscript = '';
            } else {
                window.interimTranscript = text;
            }
            
            // Update input field
            const combinedTranscript = (window.finalTranscript + ' ' + window.interimTranscript).trim();
            const userInput = document.getElementById('user-input');
            if (userInput) {
                userInput.value = combinedTranscript;
            }
            
            // Handle final results - only auto-submit if still recording
            if (isFinal && text.trim() && window.isRecording) {
                window.lastInputWasSpeech = true;
                
                // Clear any existing timeout
                if (window.speechTimeout) {
                    clearTimeout(window.speechTimeout);
                }
                
                // Auto-submit after a brief delay, but only if still recording
                window.speechTimeout = setTimeout(() => {
                    if (userInput && userInput.value.trim() && window.isRecording) {
                        enqueueMessage();
                        handleSpeechEnd(); // End recording after auto-submit
                    }
                }, 500);
            } else if (window.isRecording) {
                // Set silence timeout to auto-stop after 3 seconds of silence
                window.silenceTimeout = setTimeout(() => {
                    if (window.isRecording) {
                        console.log('Auto-stopping due to silence');
                        toggleSpeechRecognition(); // This will stop the recording
                    }
                }, 3000);
            }
        }

        // Common speech start handler
        function handleSpeechStart() {
            window.isRecording = true;
            window.finalTranscript = '';
            window.interimTranscript = '';
            
            // Clear any existing timeouts
            if (window.speechTimeout) {
                clearTimeout(window.speechTimeout);
                window.speechTimeout = null;
            }
            if (window.silenceTimeout) {
                clearTimeout(window.silenceTimeout);
                window.silenceTimeout = null;
            }
            
            const micButton = document.getElementById('mic-button');
            if (micButton) {
                micButton.classList.add('recording');
                micButton.title = 'Stop voice input - Listening...';
            }
            
            console.log('Voice input started - listening for speech...');
        }

        // Common speech end handler
        function handleSpeechEnd() {
            window.isRecording = false;
            
            // Clear all timeouts
            if (window.speechTimeout) {
                clearTimeout(window.speechTimeout);
                window.speechTimeout = null;
            }
            if (window.silenceTimeout) {
                clearTimeout(window.silenceTimeout);
                window.silenceTimeout = null;
            }
            
            const micButton = document.getElementById('mic-button');
            if (micButton) {
                micButton.classList.remove('recording');
                micButton.title = 'Use voice input';
            }
            
            console.log('Voice input ended');
        }

        // Common speech error handler
        function handleSpeechError(error) {
            window.isRecording = false;
            
            // Clear all timeouts
            if (window.speechTimeout) {
                clearTimeout(window.speechTimeout);
                window.speechTimeout = null;
            }
            if (window.silenceTimeout) {
                clearTimeout(window.silenceTimeout);
                window.silenceTimeout = null;
            }
            
            // Ensure recognition is properly aborted on error to prevent state issues
            if (window.isWebSpeechSupported && window.recognition) {
                try {
                    window.recognition.abort();
                } catch (e) {
                    // Ignore errors - recognition might already be stopped
                }
            }
            
            const micButton = document.getElementById('mic-button');
            if (micButton) {
                micButton.classList.remove('recording');
                micButton.title = 'Use voice input';
            }
            
            // Don't show error for 'no-speech' or 'aborted'
            if (error !== 'no-speech' && error !== 'aborted') {
                displayError(`Speech recognition error: ${error}`);
            }
            
            console.log('Voice input error:', error);
        }

        // Initialize speech recognition on page load
        (async () => {
            // Try PocketSphinx first, fallback to Web Speech API
            const pocketSphinxSuccess = await initializePocketSphinx();
            if (!pocketSphinxSuccess) {
                console.log('PocketSphinx failed, trying Web Speech API fallback...');
                await initializeWebSpeechFallback();
            }
        })();

        // Enhanced function to toggle speech recognition
        async function toggleSpeechRecognition() {
            const micButton = document.getElementById('mic-button');
            
            // Check if any speech recognition is supported
            if (!window.isPocketSphinxSupported && !window.isWebSpeechSupported) {
                displayError('Speech recognition is not supported in your browser. Please use a modern browser.');
                return;
            }

            if (window.isRecording) {
                // Stop recognition immediately
                console.log('Stopping speech recognition...');
                
                // Clear any pending timeouts
                if (window.speechTimeout) {
                    clearTimeout(window.speechTimeout);
                    window.speechTimeout = null;
                    console.log('Cleared speech timeout');
                }
                if (window.silenceTimeout) {
                    clearTimeout(window.silenceTimeout);
                    window.silenceTimeout = null;
                    console.log('Cleared silence timeout');
                }
                
                // Force stop all recognition methods
                try {
                    if (window.isPocketSphinxSupported && window.pocketSphinxRecognizer) {
                        await stopPocketSphinxRecognition();
                    }
                    if (window.isWebSpeechSupported && window.recognition) {
                        window.recognition.stop();
                        window.recognition.abort(); // Force abort to prevent further processing
                    }
                    // Also stop MediaRecorder if it's running
                    if (typeof mediaRecorder !== 'undefined' && mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                } catch (error) {
                    console.error('Error stopping speech recognition:', error);
                }
                
                // Force UI reset
                handleSpeechEnd();
                console.log('Speech recognition stopped');
                return;
            }

            try {
                // Clear previous transcripts
                window.finalTranscript = '';
                window.interimTranscript = '';
                
                // Start recognition with preferred method
                if (window.isPocketSphinxSupported && window.pocketSphinxRecognizer) {
                    await startPocketSphinxRecognition();
                } else if (window.isWebSpeechSupported && window.recognition) {
                    // Ensure recognition is properly stopped/aborted before starting
                    // This prevents "recognition has already started" errors
                    try {
                        window.recognition.stop();
                    } catch (e) {
                        // Ignore errors if already stopped
                    }
                    try {
                        window.recognition.abort();
                    } catch (e) {
                        // Ignore errors if already aborted
                    }
                    
                    // Small delay to ensure recognition object is fully reset
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Now start recognition
                    window.recognition.start();
                } else {
                    throw new Error('No speech recognition method available');
                }
                
            } catch (error) {
                console.error('Failed to start speech recognition:', error);
                handleSpeechEnd(); // Reset UI state
                
                // Handle InvalidStateError specifically - recognition might already be started
                if (error.name === 'InvalidStateError') {
                    console.log('Recognition already started, attempting to reset...');
                    try {
                        if (window.isWebSpeechSupported && window.recognition) {
                            window.recognition.abort();
                            // Wait a bit and try again
                            await new Promise(resolve => setTimeout(resolve, 200));
                            window.recognition.start();
                            return; // Successfully restarted
                        }
                    } catch (retryError) {
                        console.error('Failed to reset recognition:', retryError);
                        displayError('Speech recognition is already active. Please wait a moment and try again.');
                    }
                } else if (error.name === 'NotAllowedError') {
                    displayError('Microphone access denied. Please allow microphone access and try again.');
                } else {
                    displayError('Failed to start speech recognition. Please try again.');
                }
            }
        }

        // Start PocketSphinx recognition with audio capture
        async function startPocketSphinxRecognition() {
            try {
                console.log('Starting PocketSphinx recognition...');
                
                // Get microphone access
                window.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });

                // Create audio context
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                const source = window.audioContext.createMediaStreamSource(window.mediaStream);
                
                // Create script processor for audio processing
                const bufferSize = 4096;
                window.scriptProcessor = window.audioContext.createScriptProcessor(bufferSize, 1, 1);
                
                window.scriptProcessor.onaudioprocess = (event) => {
                    if (window.pocketSphinxRecognizer && window.isRecording) {
                        const inputBuffer = event.inputBuffer.getChannelData(0);
                        // Convert Float32Array to Int16Array for PocketSphinx
                        const pcmData = new Int16Array(inputBuffer.length);
                        for (let i = 0; i < inputBuffer.length; i++) {
                            pcmData[i] = Math.max(-1, Math.min(1, inputBuffer[i])) * 0x7FFF;
                        }
                        
                        // Send audio data to PocketSphinx
                        window.pocketSphinxRecognizer.addAudio(pcmData);
                    }
                };

                // Connect audio processing chain
                source.connect(window.scriptProcessor);
                window.scriptProcessor.connect(window.audioContext.destination);

                // Start recognition
                window.pocketSphinxRecognizer.start();
                handleSpeechStart();
                
                console.log('PocketSphinx recognition started successfully');
                
            } catch (error) {
                console.error('Error starting PocketSphinx recognition:', error);
                throw error;
            }
        }

        // Stop PocketSphinx recognition and clean up resources
        async function stopPocketSphinxRecognition() {
            try {
                console.log('Stopping PocketSphinx recognition...');
                
                if (window.pocketSphinxRecognizer) {
                    window.pocketSphinxRecognizer.stop();
                }
                
                // Clean up audio resources
                if (window.scriptProcessor) {
                    window.scriptProcessor.disconnect();
                    window.scriptProcessor = null;
                }
                
                if (window.audioContext && window.audioContext.state !== 'closed') {
                    await window.audioContext.close();
                    window.audioContext = null;
                }
                
                if (window.mediaStream) {
                    window.mediaStream.getTracks().forEach(track => track.stop());
                    window.mediaStream = null;
                }
                
                handleSpeechEnd();
                console.log('PocketSphinx recognition stopped successfully');
                
            } catch (error) {
                console.error('Error stopping PocketSphinx recognition:', error);
                throw error;
            }
        }

        // Text-to-speech functionality
        async function toggleTextToSpeech() {
            const ttsButton = document.getElementById('tts-button');
            const playIcon = document.getElementById('tts-play-icon');
            const stopIcon = document.getElementById('tts-stop-icon');
            
            if (window.isTTSPlaying) {
                // Stop current playback
                stopTTS();
                return;
            }
            
            // Get the last bot response text
            let textToSpeak = window.lastBotResponse;
            
            // If no stored response, try to get from the last bot message in the chat
            if (!textToSpeak) {
                const botMessages = document.querySelectorAll('.message.bot .message-content');
                if (botMessages.length > 0) {
                    const lastBotMessage = botMessages[botMessages.length - 1];
                    textToSpeak = lastBotMessage.textContent || lastBotMessage.innerText;
                }
            }
            
            if (!textToSpeak || textToSpeak.trim() === '') {
                displayError('No response available to read aloud. Please send a message first.');
                return;
            }
            
            // Clean up the text (remove markdown, extra whitespace, etc.)
            textToSpeak = cleanTextForTTS(textToSpeak);
            
            try {
                // Update button state
                window.isTTSPlaying = true;
                ttsButton.classList.add('playing');
                ttsButton.title = 'Stop reading aloud';
                playIcon.style.display = 'none';
                stopIcon.style.display = 'block';
                
                // Try Web Speech API first (built-in browser TTS)
                if (window.speechSynthesis) {
                    await playWithWebSpeechAPI(textToSpeak);
                } else {
                    // Fallback to server-side TTS
                    await playWithServerTTS(textToSpeak);
                }
                
            } catch (error) {
                console.error('TTS Error:', error);
                // Only show error if it's not an intentional interruption
                if (!window.isTTSIntentionallyStopped && 
                    !error.message.includes('interrupted') && 
                    !error.message.includes('canceled')) {
                    displayError('Failed to read response aloud: ' + error.message);
                }
                stopTTS();
            }
        }
        
        function cleanTextForTTS(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
                .replace(/\*(.*?)\*/g, '$1')     // Remove italic markdown
                .replace(/`(.*?)`/g, '$1')       // Remove code markdown
                .replace(/#{1,6}\s/g, '')        // Remove headers
                .replace(/\n{2,}/g, '. ')        // Replace multiple newlines with period
                .replace(/\n/g, '. ')            // Replace single newlines with period
                .replace(/\s{2,}/g, ' ')         // Replace multiple spaces with single space
                .replace(/([.!?])\s*([.!?])/g, '$1 $2') // Fix multiple punctuation
                .trim();
        }
        
        async function playWithWebSpeechAPI(text) {
            return new Promise((resolve, reject) => {
                if (!window.speechSynthesis) {
                    reject(new Error('Web Speech API not supported'));
                    return;
                }
                
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Function to configure voice with proper error handling
                let retryCount = 0;
                const maxRetries = 10;
                
                const configureVoice = () => {
                    try {
                        // Configure voice settings for a pleasant female voice
                        const voices = window.speechSynthesis.getVoices();
                        
                        // If voices are not loaded yet, wait and retry
                        if (!voices || voices.length === 0) {
                            retryCount++;
                            if (retryCount < maxRetries) {
                                // Try listening for voiceschanged event
                                const onVoicesChanged = () => {
                                    window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
                                    configureVoice();
                                };
                                window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
                                
                                // Also set a timeout as fallback
                                setTimeout(() => {
                                    window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
                                    configureVoice();
                                }, 100);
                            } else {
                                // Max retries reached, proceed without voice selection
                                console.warn('Could not load voices, proceeding with default voice');
                                utterance.rate = 0.9;
                                utterance.pitch = 1.1;
                                utterance.volume = 0.8;
                                window.speechSynthesis.speak(utterance);
                            }
                            return;
                        }
                        
                        // Try to find a female voice
                        let selectedVoice = null;
                        for (const voice of voices) {
                            // Add null check to prevent "Cannot read properties of undefined" error
                            if (voice && voice.name && voice.name.toLowerCase) {
                                if (voice.name.toLowerCase().includes('female') || 
                                    voice.name.toLowerCase().includes('woman') ||
                                    voice.name.toLowerCase().includes('zira') ||
                                    voice.name.toLowerCase().includes('hazel') ||
                                    voice.name.toLowerCase().includes('samantha')) {
                                    selectedVoice = voice;
                                    break;
                                }
                            }
                        }
                        
                        // If no female voice found, try to get a pleasant voice
                        if (!selectedVoice && voices.length > 0) {
                            selectedVoice = voices.find(voice => voice && voice.lang && voice.lang.startsWith('en')) || 
                                           voices.find(voice => voice && voice.name) || 
                                           voices[0];
                        }
                        
                        if (selectedVoice) {
                            utterance.voice = selectedVoice;
                        }
                        
                        // Configure speech parameters for a pleasant experience
                        utterance.rate = 0.9;    // Slightly slower for clarity
                        utterance.pitch = 1.1;   // Slightly higher pitch for female voice
                        utterance.volume = 0.8;  // Not too loud
                        
                        // Start speaking
                        window.speechSynthesis.speak(utterance);
                        
                    } catch (error) {
                        console.error('Error configuring voice:', error);
                        // Fallback: just speak without voice configuration
                        utterance.rate = 0.9;
                        utterance.pitch = 1.1;
                        utterance.volume = 0.8;
                        window.speechSynthesis.speak(utterance);
                    }
                };
                
                // Start voice configuration
                configureVoice();
                
                utterance.onstart = () => {
                    console.log('TTS started');
                };
                
                utterance.onend = () => {
                    console.log('TTS ended');
                    stopTTS();
                    resolve();
                };
                
                utterance.onerror = (event) => {
                    console.error('TTS error:', event);
                    // Don't show error for intentional interruptions
                    if (window.isTTSIntentionallyStopped || event.error === 'interrupted' || event.error === 'canceled') {
                        resolve(); // Resolve normally for intentional stops
                    } else {
                        reject(new Error('Speech synthesis failed: ' + event.error));
                    }
                    stopTTS();
                };
                
                window.currentTTSUtterance = utterance;
            });
        }
        
        async function playWithServerTTS(text) {
            try {
                const response = await fetch('/text-to-speech', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: 'female',
                        rate: 180,
                        volume: 0.8
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server TTS failed: ${response.status}`);
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                const audio = new Audio(audioUrl);
                window.currentTTSAudio = audio;
                
                audio.onplay = () => {
                    console.log('Server TTS started');
                };
                
                audio.onended = () => {
                    console.log('Server TTS ended');
                    URL.revokeObjectURL(audioUrl);
                    stopTTS();
                };
                
                audio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    URL.revokeObjectURL(audioUrl);
                    stopTTS();
                    throw new Error('Audio playback failed');
                };
                
                await audio.play();
                
            } catch (error) {
                console.error('Server TTS error:', error);
                throw error;
            }
        }
        
        function stopTTS() {
            // Set flag to indicate intentional stop (prevents error messages)
            window.isTTSIntentionallyStopped = true;
            
            // Stop Web Speech API
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            
            // Stop audio playback
            if (window.currentTTSAudio) {
                window.currentTTSAudio.pause();
                window.currentTTSAudio.currentTime = 0;
                window.currentTTSAudio = null;
            }
            
            // Reset button state
            window.isTTSPlaying = false;
            const ttsButton = document.getElementById('tts-button');
            const playIcon = document.getElementById('tts-play-icon');
            const stopIcon = document.getElementById('tts-stop-icon');
            
            if (ttsButton) {
                ttsButton.classList.remove('playing');
                ttsButton.title = 'Read last response aloud';
            }
            
            if (playIcon) playIcon.style.display = 'block';
            if (stopIcon) stopIcon.style.display = 'none';
            
            // Clear the intentional stop flag after a brief delay
            setTimeout(() => {
                window.isTTSIntentionallyStopped = false;
            }, 100);
        }

        // Add event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Send button click handler
            const sendButton = document.getElementById('send-button');
            if (sendButton) {
                sendButton.addEventListener('click', () => {
                    window.lastInputWasSpeech = false;
                    const userInput = document.getElementById('user-input');
                    if (userInput.value.trim()) {
                        enqueueMessage();
                    }
                });
            }

            // Mic button click handler
            const micButton = document.getElementById('mic-button');
            if (micButton) {
                micButton.addEventListener('click', toggleSpeechRecognition);
            }

            // TTS button click handler
            const ttsButton = document.getElementById('tts-button');
            if (ttsButton) {
                ttsButton.addEventListener('click', toggleTextToSpeech);
            }

            // Input field enter key handler
            const userInput = document.getElementById('user-input');
            if (userInput) {
                userInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        window.lastInputWasSpeech = false;
                        if (userInput.value.trim()) {
                            enqueueMessage();
                        }
                    }
                });
            }
        });

        // ... rest of the existing code ...

        // Initialize Web Speech API with better browser detection
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isWebSpeechSupported = false;

        // Fix: Ensure isProcessingQueue is declared before any function uses it
        let isProcessingQueue = false;
        let isTyping = false;
        let sheetsModeEnabled = false;
        let currentPreviewMessageElement = null;
        let queryQueue = [];
        let chatHistory = [];
        let currentAbortController = null; // Add abort controller for request cancellation
        let isRequestAborted = false; // Flag to track if current request was aborted
        const chatContainer = document.getElementById('chat-container');
    

        try {
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.lang = 'en-IN'; // Switch to 'hi-IN' for Hindi
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;
                isWebSpeechSupported = true;
            }
        } catch (e) {
            console.warn('Web Speech API not supported:', e);
            isWebSpeechSupported = false;
        }

        let lastInputWasSpeech = false;

        // MediaRecorder setup for server-side STT fallback
        let mediaRecorder = null;
        let audioChunks = [];

        // Check for MediaRecorder support
        const isMediaRecorderSupported = !!(navigator.mediaDevices && window.MediaRecorder);

        // Function to stream audio from the backend
        async function streamAudio(text, history) {
            

            try {
                const token = localStorage.getItem('authToken');
                const response = await fetch("/stream_audio", {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ 
                        text,
                        history: history || []
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }

                const data = await response.json();
                if (data.status === "success" && data.audio) {
                    // playAudio(data.audio);
                } else {
                    throw new Error('Invalid audio data received from server');
                }
            } catch (error) {
                console.error('Audio streaming error:', error);
                throw error;
            }
        }

        // Initialize mute button state
        const muteButton = document.getElementById('mute-button');
        updateMuteButton();

        // Stop audio stream
        function stopAudioStream() {
            if (sourceNode) {
                sourceNode.stop();
                sourceNode.disconnect();
                sourceNode = null;
            }
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            isStreaming = false;
            if (audioContext.state === 'running') {
                audioContext.suspend();
            }
            const muteButton = document.getElementById('mute-button');
            muteButton.classList.remove('glowing');
        }

        

        // Define HEADERS for the Excel sheet, mirroring backend
        const headers = [
            "Sr. No.",
            "Description of the Contract",
            "Name of the first Party",
            "Name of the second Party",
            "Date of Request",
            "Purpose",
            "Agreement Commencement date",
            "Duration of the Agreement",
            "Department Responsibility",
            "Internal Status",
            "Signed Copy RECEIVED on IVALUA (Y/N)",
            "Uploaded on IVALUA"
        ];

        // Query queue to manage sequential processing
        
        let typingTimeout = null; // Store typing timeout

        // Auto-scroll to bottom
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Configure marked options with custom renderer for links and tables
        const renderer = new marked.Renderer();
        
        // Override link rendering to always open in new tab
        renderer.link = function(href, title, text) {
            let link = '<a href="' + href + '" target="_blank" rel="noopener noreferrer"';
            if (title) {
                link += ' title="' + title + '"';
            }
            link += '>' + text + '</a>';
            return link;
        };
        
        // Enhanced table rendering to add proper CSS classes and scrollable container
        renderer.table = function(header, body) {
            return '<div class="table-scroll-container" data-scroll-container>\n'
                + '<table class="markdown-table">\n'
                + '<thead>\n'
                + header
                + '</thead>\n'
                + '<tbody>\n'
                + body
                + '</tbody>\n'
                + '</table>\n'
                + '</div>\n';
        };
        
        // Override table header rendering
        renderer.tablerow = function(content) {
            return '<tr>\n' + content + '</tr>\n';
        };
        
        // Override table cell rendering for headers
        renderer.tablecell = function(content, flags) {
            const type = flags.header ? 'th' : 'td';
            const className = flags.header ? 'table-header' : 'table-cell';
            const align = flags.align ? ` style="text-align: ${flags.align}"` : '';
            return `<${type} class="${className}"${align}>${content}</${type}>\n`;
        };
        
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false,
            sanitize: false,
            smartLists: true,
            smartypants: true,
            xhtml: false,
            tables: true,
            renderer: renderer
        });

        // Enhanced table scroll container functionality
        function initializeTableScrollContainers() {
            // First, wrap any unwrapped tables in message bubbles
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                const unwrappedTables = bubble.querySelectorAll('table:not(.table-scroll-container table)');
                unwrappedTables.forEach(table => {
                    // Check if table is already wrapped
                    if (table.parentElement && !table.parentElement.classList.contains('table-scroll-container')) {
                        // Check if table overflows
                        const tableWidth = table.scrollWidth;
                        const containerWidth = bubble.clientWidth || window.innerWidth * 0.8;
                        
                        // Only wrap if table is wider than container
                        if (tableWidth > containerWidth || tableWidth > 600) {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'table-scroll-container';
                            wrapper.setAttribute('data-scroll-container', 'true');
                            table.parentNode.insertBefore(wrapper, table);
                            wrapper.appendChild(table);
                        }
                    }
                });
            });
            
            // Now initialize scroll containers
            const scrollContainers = document.querySelectorAll('.table-scroll-container[data-scroll-container]');
            
            scrollContainers.forEach(container => {
                // Add scroll event listener for visual indicators
                container.addEventListener('scroll', function() {
                    updateScrollIndicators(this);
                });
                
                // Initial check for scroll indicators
                updateScrollIndicators(container);
                
                // Add resize observer to handle dynamic content changes
                if (window.ResizeObserver) {
                    const resizeObserver = new ResizeObserver(() => {
                        updateScrollIndicators(container);
                    });
                    resizeObserver.observe(container);
                }
            });
        }

        function updateScrollIndicators(container) {
            const scrollLeft = container.scrollLeft;
            const scrollWidth = container.scrollWidth;
            const clientWidth = container.clientWidth;
            
            // Remove existing indicator classes
            container.classList.remove('scrollable-left', 'scrollable-right');
            
            // Add appropriate indicator classes
            if (scrollLeft > 0) {
                container.classList.add('scrollable-left');
            }
            
            if (scrollLeft < scrollWidth - clientWidth) {
                container.classList.add('scrollable-right');
            }
        }

        // Initialize table scroll containers when DOM is ready
        function initializeTableScrollContainersOnReady() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeTableScrollContainers);
            } else {
                initializeTableScrollContainers();
            }
        }

        // Enhanced table preprocessing function
        function preprocessTableText(text) {
            // Check if text contains pipe-separated table data
            const lines = text.split('\n');
            let inTable = false;
            let tableLines = [];
            let processedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Detect table start (line with pipes and not just separators)
                if (line.includes('|') && !line.match(/^[\s\|\-\:]+$/) && !inTable) {
                    inTable = true;
                    tableLines = [line];
                }
                // Continue collecting table lines
                else if (inTable) {
                    if (line.match(/^[\s\|\-\:]+$/)) {
                        // This is a separator line, add it to table
                        tableLines.push(line);
                    } else if (line.includes('|')) {
                        // This is a data line, add it to table
                        tableLines.push(line);
                    } else if (line === '') {
                        // Empty line might end the table
                        if (tableLines.length > 1) {
                            // Process the collected table
                            const tableMarkdown = tableLines.join('\n');
                            processedLines.push(tableMarkdown);
                            tableLines = [];
                            inTable = false;
                        }
                    } else {
                        // Non-table line ends the table
                        if (tableLines.length > 1) {
                            // Process the collected table
                            const tableMarkdown = tableLines.join('\n');
                            processedLines.push(tableMarkdown);
                            tableLines = [];
                        }
                        inTable = false;
                        processedLines.push(line);
                    }
                }
                // Regular line
                else {
                    processedLines.push(line);
                }
            }
            
            // Handle table at end of text
            if (inTable && tableLines.length > 1) {
                const tableMarkdown = tableLines.join('\n');
                processedLines.push(tableMarkdown);
            }
            
            return processedLines.join('\n');
        }

        // Removed complex preprocessMarkdownText function - using simple approach instead

        // Removed complex postprocessMarkdownHTML function - using simple approach instead

        // Removed complex fixTableStructure function - using simple approach instead

        // Function to create sources HTML directly from source data
        function createSourcesHTML(sources) {
            console.log('=== createSourcesHTML called ===');
            console.log('sources parameter:', sources);
            console.log('sources type:', typeof sources);
            console.log('sources is array:', Array.isArray(sources));
            console.log('sources length:', sources ? sources.length : 'undefined');
            
            if (!sources || sources.length === 0) {
                console.log('No sources provided or empty sources array');
                return '';
            }
            
            let sourcesHTML = '<div class="sources"><h4> Sources:</h4><ul>';
            
            sources.forEach((source, index) => {
                const filename = source.filename || 'Unknown';
                const pageInfo = source.page_info || '';
                const link = source.link;
                
                console.log(`Processing source ${index + 1}:`, {
                    original: source,
                    filename,
                    pageInfo,
                    link,
                    linkType: typeof link,
                    linkTruthy: !!link
                });
                
                if (link && link.trim() && link !== 'undefined' && link !== 'null') {
                    console.log(`Creating clickable link for source ${index + 1}`);
                    sourcesHTML += `<li class="numbered-source">
                        <strong>${index + 1}.</strong> 
                        <a href="${link}" target="_blank" rel="noopener noreferrer" class="source-link">
                             ${filename}${pageInfo}
                        </a>
                    </li>`;
                } else {
                    console.log(`Creating non-clickable source for source ${index + 1} (no valid link)`);
                    sourcesHTML += `<li class="numbered-source">
                        <strong>${index + 1}.</strong> 
                         ${filename}${pageInfo} (Link not available)
                    </li>`;
                }
            });
            
            sourcesHTML += '</ul></div>';
            console.log('Final generated sources HTML:', sourcesHTML);
            console.log('=== createSourcesHTML complete ===');
            return sourcesHTML;
        }

        // Function to format SQL query with proper indentation and line breaks
        function formatSQLQuery(sqlQuery) {
            if (!sqlQuery || sqlQuery.trim() === '') {
                return '';
            }
            
            // Clean up the query first - normalize whitespace
            let formatted = sqlQuery.trim().replace(/\s+/g, ' ');
            
            // Step 1: Handle SELECT clause - split fields onto separate lines
            formatted = formatted.replace(/SELECT\s+/gi, 'SELECT\n    ');
            formatted = formatted.replace(/,\s*/g, ',\n    ');
            
            // Step 2: Add line breaks after major SQL keywords
            formatted = formatted.replace(/\bFROM\b/gi, '\nFROM ');
            formatted = formatted.replace(/\bWHERE\b/gi, '\nWHERE ');
            formatted = formatted.replace(/\bLEFT JOIN\b/gi, '\nLEFT JOIN ');
            formatted = formatted.replace(/\bRIGHT JOIN\b/gi, '\nRIGHT JOIN ');
            formatted = formatted.replace(/\bINNER JOIN\b/gi, '\nINNER JOIN ');
            formatted = formatted.replace(/\bOUTER JOIN\b/gi, '\nOUTER JOIN ');
            formatted = formatted.replace(/\bGROUP BY\b/gi, '\nGROUP BY\n    ');
            formatted = formatted.replace(/\bORDER BY\b/gi, '\nORDER BY\n    ');
            formatted = formatted.replace(/\bHAVING\b/gi, '\nHAVING ');
            formatted = formatted.replace(/\bUNION\b/gi, '\nUNION ');
            
            // Step 3: Handle JOIN conditions - split ON onto new line
            formatted = formatted.replace(/\s+ON\s+/gi, '\n    ON ');
            
            // Step 4: Handle WHERE conditions - split AND/OR onto new lines
            formatted = formatted.replace(/\s+AND\s+/gi, '\n    AND ');
            formatted = formatted.replace(/\s+OR\s+/gi, '\n    OR ');
            
            // Step 5: Split GROUP BY fields onto separate lines
            formatted = formatted.replace(/GROUP BY\s+/gi, 'GROUP BY\n    ');
            formatted = formatted.replace(/GROUP BY\n    ([^,\n]+),\s*/g, 'GROUP BY\n    $1,\n    ');
            
            // Step 6: Split ORDER BY fields onto separate lines
            formatted = formatted.replace(/ORDER BY\s+/gi, 'ORDER BY\n    ');
            formatted = formatted.replace(/ORDER BY\n    ([^,\n]+),\s*/g, 'ORDER BY\n    $1,\n    ');
            
            // Clean up extra whitespace and normalize line breaks
            const lines = formatted.split('\n');
            let result = [];
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                // Determine indentation level based on SQL keyword
                let indent = '';
                if (line.match(/^\b(SELECT|FROM|WHERE|LEFT JOIN|RIGHT JOIN|INNER JOIN|OUTER JOIN|GROUP BY|ORDER BY|HAVING|UNION)\b/i)) {
                    indent = '';
                } else if (line.match(/^\b(AND|OR|ON)\b/i)) {
                    indent = '    ';
                } else {
                    indent = '    ';
                }
                
                result.push(indent + line);
            }
            
            return result.join('\n');
        }

        // Function to create Analysis dropdown HTML
        function createAnalysisDropdownHTML(sqlQuery) {
            console.log('=== createAnalysisDropdownHTML called ===');
            console.log('SQL Query:', sqlQuery);
            
            if (!sqlQuery || sqlQuery.trim() === '') {
                console.log('No SQL query provided');
                return '';
            }
            
            // Always create the dropdown HTML - visibility will be controlled globally
            
            // Format the SQL query with proper indentation
            const formattedQuery = formatSQLQuery(sqlQuery);
            
            // Escape HTML characters in the formatted SQL query
            const escapedQuery = formattedQuery
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            
            const dropdownHTML = `
                <div class="analysis-dropdown">
                    <button class="analysis-dropdown-btn" onclick="toggleAnalysisDropdown(this)">
                        Analysis
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6,9 12,15 18,9"></polyline>
                        </svg>
                    </button>
                    <div class="analysis-dropdown-content">
                        <div class="analysis-dropdown-header">
                             SQL Query Used
                        </div>
                        <div class="analysis-dropdown-body">
                            <pre class="sql-query-code">${escapedQuery}</pre>
                        </div>
                        <div class="analysis-dropdown-footer">
                            This query was executed to fetch the data displayed below
                        </div>
                    </div>
                </div>
            `;
            
            console.log('Generated Analysis dropdown HTML');
            console.log('=== createAnalysisDropdownHTML complete ===');
            return dropdownHTML;
        }

        // Render a message without typing animation (for user messages and history)
        function renderMessage(message) {
            // Check if request was aborted before rendering
            if (isRequestAborted && message.role === 'assistant') {
                console.log('Request was aborted, skipping assistant message rendering');
                return;
            }
            
            const div = document.createElement('div');
            div.className = `message ${message.role === 'assistant' ? 'bot' : message.role}-message`;
            
            div.innerHTML = `
                ${message.role === 'assistant' ? '<!-- <img src="https://ui-avatars.com/api/?name=Bot&background=5A5A5A&color=e5e7eb&size=40" class="avatar bot-avatar" alt="Bot Avatar"> -->' : ''}
                <div class="message-bubble">
                    <span class="message-text"></span>
                    <div class="timestamp">${formatTimestampForDisplay(message.timestamp)}</div>
                    ${message.role === 'assistant' ? `
                    <div class="message-actions">
                        <button class="action-btn copy-btn" onclick="copyToClipboard(this)" title="Copy to clipboard">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                        <button class="action-btn thumbs-up-btn" onclick="giveFeedback(this, 'Thumbs Up')" title="Thumbs up">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M7 10v12"></path>
                                <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h3.73a2 2 0 0 1 1.92 2.56z"></path>
                            </svg>
                        </button>
                        <button class="action-btn thumbs-down-btn" onclick="giveFeedback(this, 'Thumbs Down')" title="Thumbs down">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 14V2"></path>
                                <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22H8.27a2 2 0 0 1-1.92-2.56z"></path>
                            </svg>
                        </button>
                        <button class="action-btn download-btn" onclick="downloadPDFDirect(this)" title="Download file" disabled style="opacity: 0.5; cursor: pointer;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7,10 12,15 17,10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                        ${message.excel_download && message.excel_file_id ? `
                        <button class="excel-download-btn" onclick="downloadExcelFile('${message.excel_file_id}')" title="Download Excel file">
                            <img src="/static/images/excel.png" alt="Download Excel" style="width: 20px; height: 20px; object-fit: contain;">
                        </button>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
                ${message.role === 'user' ? '<!-- <img src="https://ui-avatars.com/api/?name=User&background=FF6200&color=fff&size=40" class="avatar" alt="User Avatar"> -->' : ''}
            `;
            chatContainer.appendChild(div);
            scrollToBottom();

            // Enable download button after charts are rendered
            enableDownloadButtonAfterCharts(div);

            const messageTextElement = div.querySelector('.message-text');

            // Render content based on type and presence of SharePoint link
            if (message.role === 'assistant') {
                if (message.text.includes('View in SharePoint')) {
                    messageTextElement.innerHTML = message.text; // Directly set HTML for the link
                } else {
                    // Enhanced markdown processing - convert escaped newlines and preprocess tables
                    let processedText = message.text.replace(/\\n/g, '\n').replace(/\\r/g, '\r');
                    
                    // Preprocess table text to ensure proper markdown table formatting
                    processedText = preprocessTableText(processedText);
                    
                    // Add Analysis dropdown if SQL query is available (before content)
                    let htmlContent = '';
                    if (message.sql_query) {
                        htmlContent += createAnalysisDropdownHTML(message.sql_query);
                    }
                    
                    // Parse as Markdown using marked.js directly
                    console.log('Original text:', message.text);
                    console.log('Processed text:', processedText);
                    htmlContent += marked.parse(processedText);
                    console.log('Generated HTML:', htmlContent);
                    
                    // Add sources HTML directly if available
                    if (message.sources && message.sources.length > 0) {
                        htmlContent += createSourcesHTML(message.sources);
                    }
                    
                    messageTextElement.innerHTML = htmlContent;
                    
                    // Initialize table scroll containers for newly rendered content
                    initializeTableScrollContainers();
                    
                    // After setting HTML, scan and render any chart definitions
                    renderChartsInElement(messageTextElement);
                }
            } else { // User message
                messageTextElement.textContent = message.text; // User messages are plain text
            }
            
            // Typeset LaTeX in the new message
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                MathJax.typesetPromise([div]).catch((err) => console.error('MathJax typesetting failed:', err));
            }
        }

        // Render a message with typing animation and optional simultaneous audio
        async function typeMessage(message, audioText, sanitizedHistory, callback) {
            console.log('typeMessage called with message.text:', message.text);
            console.log('typeMessage called with audioText:', audioText);
            
            // Check if request was aborted before rendering
            if (isRequestAborted) {
                console.log('Request was aborted, skipping message rendering');
                if (callback) callback();
                return;
            }
            
            const div = document.createElement('div');
            div.className = `message bot-message`;
            div.innerHTML = `
                ${message.role === 'assistant' ? '<!-- <img src="https://ui-avatars.com/api/?name=Bot&background=5A5A5A&color=e5e7eb&size=40" class="avatar bot-avatar" alt="Bot Avatar"> -->' : ''}
                <div class="message-bubble">
                    <span class="message-text"></span>
                    <div class="timestamp">${formatTimestampForDisplay(message.timestamp)}</div>
                    ${message.role === 'assistant' ? `
                    <div class="message-actions">
                        <button class="action-btn copy-btn" onclick="copyToClipboard(this)" title="Copy to clipboard">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                        <button class="action-btn thumbs-up-btn" onclick="giveFeedback(this, 'Thumbs Up')" title="Thumbs up">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M7 10v12"></path>
                                <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h3.73a2 2 0 0 1 1.92 2.56z"></path>
                            </svg>
                        </button>
                        <button class="action-btn thumbs-down-btn" onclick="giveFeedback(this, 'Thumbs Down')" title="Thumbs down">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 14V2"></path>
                                <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22H8.27a2 2 0 0 1-1.92-2.56z"></path>
                            </svg>
                        </button>
                        <button class="action-btn download-btn" onclick="downloadPDFDirect(this)" title="Download file" disabled style="opacity: 0.5; cursor: pointer;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7,10 12,15 17,10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                        ${message.excel_download && message.excel_file_id ? `
                        <button class="excel-download-btn" onclick="downloadExcelFile('${message.excel_file_id}')" title="Download Excel file">
                            <img src="/static/images/excel.png" alt="Download Excel" style="width: 20px; height: 20px; object-fit: contain;">
                        </button>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
            `;
            chatContainer.appendChild(div);
            scrollToBottom();

            // Enable download button after charts are rendered
            enableDownloadButtonAfterCharts(div);

            // Debug: Check if action buttons were added
            const actionButtons = div.querySelectorAll('.action-btn');
            console.log('Action buttons added:', actionButtons.length);
            if (actionButtons.length > 0) {
                console.log('Action buttons found:', actionButtons);
            }

            const messageTextElement = div.querySelector('.message-text');

            // Show loading animation if this is a voice response
            if (lastInputWasSpeech) {
                const loader = displayLoader();
                try {
                    await streamAudio(audioText, sanitizedHistory);
                    removeElement(loader);
                } catch (error) {
                    removeElement(loader);
                    displayError('Error generating voice response: ' + error.message);
                }
            }

            // Render the entire message at once, without typing animation
            // Enhanced markdown processing - convert escaped newlines and preprocess tables
            let processedText = message.text.replace(/\\n/g, '\n').replace(/\\r/g, '\r');
            
            // Preprocess table text to ensure proper markdown table formatting
            processedText = preprocessTableText(processedText);
            
            // Add Analysis dropdown if SQL query is available (before content)
            let htmlContent = '';
            if (message.sql_query) {
                htmlContent += createAnalysisDropdownHTML(message.sql_query);
            }
            
            // Parse as Markdown using marked.js directly
            htmlContent += marked.parse(processedText);
            
            // Add sources HTML directly if available
            if (message.sources && message.sources.length > 0) {
                htmlContent += createSourcesHTML(message.sources);
            }
            
            messageTextElement.innerHTML = htmlContent;
            
            // Initialize table scroll containers for newly rendered content
            initializeTableScrollContainers();
            
            renderChartsInElement(messageTextElement);
            
            // Note: Download button enabling is now handled by the chart trigger system
            
            // Add download button if docx_base64 is present
            if (message.docx_base64) {
                const downloadButton = createDocxDownloadButton(message.docx_base64);
                div.querySelector('.message-bubble').appendChild(downloadButton);
            }

            // Typeset LaTeX expressions in the rendered message
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                MathJax.typesetPromise([div]).catch((err) => console.error('MathJax typesetting failed:', err));
            }
            
            if (callback) {
                callback();
            }
        }

        function createDocxDownloadButton(docx_base64) {
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download DOCX';
            downloadButton.className = 'download-button'; // Add a class for styling
            downloadButton.style.marginTop = '10px';
            downloadButton.style.padding = '5px 10px';
            downloadButton.style.border = '1px solid #ccc';
            downloadButton.style.borderRadius = '5px';
            downloadButton.style.cursor = 'pointer';

            downloadButton.onclick = () => {
                try {
                    const byteCharacters = atob(docx_base64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], {type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'});
                    
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'response.docx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error downloading DOCX:', error);
                    alert('Failed to download DOCX file.');
                }
            };
            return downloadButton;
        }

        function displayError(message) {
            console.error(message);
            const div = document.createElement('div');
            div.className = 'error-message';
            
            // Add browser-specific guidance
            let browserMessage = message;
            if (message.includes('network') || message.includes('not supported')) {
                browserMessage += '\n\nBrowser Compatibility:\n' +
                    ' Chrome: Full support\n' +
                    ' Edge: Full support\n' +
                    ' Firefox: Partial support\n' +
                    ' Safari: Limited support\n' +
                    ' Arc: Limited support\n\n' +
                    'For best experience, please use Chrome or Edge.';
            }
            
            div.textContent = browserMessage;
            chatContainer.appendChild(div);
            scrollToBottom();
        }

        // Display loader
        function displayLoader() {
            const div = document.createElement('div');
            div.className = 'loader';
            div.id = `loader-${Date.now()}`;
            chatContainer.appendChild(div);
            scrollToBottom();
            return div;
        }

        // Display typing indicator
        function displayTypingIndicator() {
            const div = document.createElement('div');
            div.className = 'typing-indicator';
            div.id = `typing-indicator-${Date.now()}`;
            div.innerHTML = '<span></span><span></span><span></span>';
            chatContainer.appendChild(div);
            scrollToBottom();
            return div;
        }

        // Remove loader or typing indicator
        function removeElement(element) {
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }

        // Variable to hold the current preview message element
       

        function toggleSheetsMode() {
            sheetsModeEnabled = !sheetsModeEnabled;
            const inputTextarea = document.getElementById('user-input');
            
            // Sheets button was removed with sidebar - no UI feedback
            inputTextarea.placeholder = sheetsModeEnabled ? 
                "Enter contract details in natural language..." : 
                "Type your message...";
            
            // Hide/remove the preview table when switching modes
            if (currentPreviewMessageElement) {
                removeElement(currentPreviewMessageElement);
                currentPreviewMessageElement = null;
            }
        }
        
        // Make toggleSheetsMode available globally
        window.toggleSheetsMode = toggleSheetsMode;

        // Utility: stop all current UI activity (loaders/typing) and reset send button
        function stopAllActivity() {
            try {
                isProcessingQueue = false;
                isTyping = false;
                isRequestAborted = true; // Set flag to prevent any rendering
                clearTimeout(typingTimeout);
                
                // Abort any ongoing fetch requests
                if (currentAbortController) {
                    currentAbortController.abort();
                    currentAbortController = null;
                }
            } catch (e) {}

            // Remove ALL loaders and typing indicators
            document.querySelectorAll('.loader').forEach(el => removeElement(el));
            document.querySelectorAll('.typing-indicator').forEach(el => removeElement(el));

            // Reset send button visuals
            const sendButton = document.getElementById('send-button');
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');
            if (sendButton) sendButton.classList.remove('processing', 'glowing');
            if (sendIcon) sendIcon.style.display = 'block';
            if (stopIcon) stopIcon.style.display = 'none';
        }

        // Modify the enqueueMessage function to handle sheets mode
        async function enqueueMessage() {
            const input = document.getElementById('user-input');
            const text = input.value.trim();
            const sendButton = document.getElementById('send-button');
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');
            
            // Hide welcome screen on first message if it's still visible
            const welcomeScreen = document.getElementById('welcome-screen');
            const chatArea = document.getElementById('chat-area');
            if (welcomeScreen && welcomeScreen.style.display !== 'none') {
                welcomeScreen.style.display = 'none';
                chatArea.style.display = 'flex';
            }

            // If currently processing (queue, typing, or UI shows stop state), treat this click as STOP
            if (isProcessingQueue || isTyping || (sendButton && sendButton.classList.contains('processing'))) {
                queryQueue = [];
                stopAllActivity();
                // Hide/remove the preview table if interrupting
                if (currentPreviewMessageElement) {
                    removeElement(currentPreviewMessageElement);
                    currentPreviewMessageElement = null;
                }
                return;
            }

            if (!text) return;

            if (sheetsModeEnabled) {
                // Handle sheets mode
                try {
                    // Add user message to chat first (same as normal mode)
                    const userMessage = { 
                        role: 'user', 
                        text, 
                        timestamp: new Date().toISOString(), 
                        isSpeech: lastInputWasSpeech 
                    };
                    chatHistory.push(userMessage);
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    renderMessage(userMessage);
                    
                    // Store analysis data for the analysis panel
                    storeAnalysisData(text);

                    // Remove the welcome message after the first user message
                    if (chatHistory.length === 1) {
                        const welcomeArea = document.querySelector('.welcome-message-area');
                        if (welcomeArea) {
                            welcomeArea.remove();
                        }
                    }

                    sendButton.classList.add('processing');
                    sendIcon.style.display = 'none';
                    stopIcon.style.display = 'block';

                    // Hide any previously displayed preview table if still present
                    if (currentPreviewMessageElement) {
                        removeElement(currentPreviewMessageElement);
                        currentPreviewMessageElement = null;
                    }

                    // Show loading state
                    const loader = displayLoader();

                    // Reset abort flag for new request
                    isRequestAborted = false;
                    
                    // Create abort controller for this request
                    currentAbortController = new AbortController();

                    const response = await fetch("https://pgp-excel-agent.politegrass-0dd17cd2.centralindia.azurecontainerapps.io/api/preview", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ input: text }),
                        signal: currentAbortController.signal
                    });

                    // Remove loader
                    removeElement(loader);

                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }

                    const data = await response.json();

                    // Check if request was aborted before processing response
                    if (isRequestAborted) {
                        console.log('Sheets request was aborted, skipping response rendering');
                        return;
                    }

                    if (data.success) {
                        // Create a new message div for the preview table
                        const previewMessageDiv = document.createElement('div');
                        previewMessageDiv.className = `message bot-message`;
                        previewMessageDiv.innerHTML = `
                            <img src="https://ui-avatars.com/api/?name=Bot&background=5A5A5A&color=e5e7eb&size=40" class="avatar bot-avatar" alt="Bot Avatar">
                            <div class="message-bubble">
                                <h3>Preview Parsed Data</h3>
                                <div class="table-scroll-container">
                                    <table class="preview-table-inline">
                                        <thead>
                                            <tr class="preview-table-headers-inline"></tr>
                                        </thead>
                                        <tbody class="preview-table-body-inline"></tbody>
                                    </table>
                                </div>
                                <div class="duplicate-info-inline mt-4"></div>
                                <button class="send-button submit-preview-btn-inline" style="margin-top: 10px;">
                                    Submit to Excel
                                </button>
                            </div>
                        `;
                        chatContainer.appendChild(previewMessageDiv);
                        scrollToBottom();

                        currentPreviewMessageElement = previewMessageDiv; // Store reference

                        const previewTableHeadersRow = previewMessageDiv.querySelector('.preview-table-headers-inline');
                        const previewTableBody = previewMessageDiv.querySelector('.preview-table-body-inline');
                        const duplicateInfo = previewMessageDiv.querySelector('.duplicate-info-inline');
                        const submitButton = previewMessageDiv.querySelector('.submit-preview-btn-inline');

                        // Populate table headers and values
                        const valuesRow = previewTableBody.insertRow(); // Only one row for values

                        for (const header of headers) {
                            const th = document.createElement('th');
                            th.textContent = header.replace(/\(Y\/N\)/, '').replace(/_OF_THE/, '').replace(/_/, ' ').replace(/  /g, ' ').trim(); // Clean header for display
                            previewTableHeadersRow.appendChild(th);

                            const td = valuesRow.insertCell();
                            td.textContent = data.preview[header] || '';
                        }

                        // Populate duplicate info
                        let overwriteNeeded = false;
                        if (data.duplicate_info.full_duplicate) {
                            duplicateInfo.innerHTML = `<p style="color: #ef4444;">Warning: Exact duplicate found at row ${data.duplicate_info.row}</p>`;
                        } else if (data.duplicate_info.sr_no_duplicate) {
                            duplicateInfo.innerHTML = `<p style="color: #f59e0b;">Warning: Duplicate Sr. No. found at row ${data.duplicate_info.row}</p>`;
                            overwriteNeeded = true;
                        } else {
                            duplicateInfo.innerHTML = '';
                        }

                        // Add submit button handler
                        submitButton.onclick = async () => {
                            try {
                                submitButton.disabled = true;
                                submitButton.textContent = 'Submitting...';
                                
                                const submitResponse = await fetch("https://pgp-excel-agent.politegrass-0dd17cd2.centralindia.azurecontainerapps.io/api/submit", {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        input: text,
                                        overwrite: overwriteNeeded // Use the detected overwriteNeeded flag
                                    })
                                });

                                const submitData = await submitResponse.json();
                                
                                if (submitData.success) {
                                    console.log('Submit success response:', submitData); // Debug log
                    
                                    let messageText = ` ${submitData.message.replace(/[()]/g, '')}`;  // Fix: syncedtoSharepoint's weird font formatting issue.
                                    
                                    if (submitData.web_url) {
                                        messageText += ` <a href="${submitData.web_url}" target="_blank" style="color: #ed5d05; text-decoration: underline;">View Changes on SharePoint</a>`;
                                    }
                                    
                                    // Check if it's a partial success (local save but SharePoint sync failed)
                                    console.log('Checking retry button condition:', {
                                        hasSharePointFailed: submitData.message.includes('SharePoint sync failed'),
                                        hasFileOpen: submitData.message.includes('Excel file is currently open'),
                                        fullMessage: submitData.message
                                    });
                                    
                                    // Show retry button for SharePoint sync failures (temporarily show for any sync failure to debug)
                                    if (submitData.message.includes('SharePoint sync failed') || 
                                        submitData.message.includes('Data saved locally')) {
                                        console.log('Adding retry button');
                                        messageText += `<br><br><button class="retry-sync-btn" onclick="retrySharePointSync()" style="background: #ed5d05; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin-top: 10px;"> Retry SharePoint Sync</button>`;
                                    }
                                    
                                    // Add success message to chat
                                    const successMessage = {
                                        role: 'assistant',
                                        text: messageText,
                                        timestamp: new Date().toISOString()
                                    };
                                    chatHistory.push(successMessage);
                                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                                    renderMessage(successMessage);
                                    
                                    // Remove the preview table from the chat after submission
                                    if (currentPreviewMessageElement) {
                                        removeElement(currentPreviewMessageElement);
                                        currentPreviewMessageElement = null;
                                    }
                                } else {
                                    // Display user-friendly error message
                                    let errorMsg = submitData.error || 'Failed to submit data';
                                    if (errorMsg.includes('File is currently open')) {
                                        errorMsg = ' Excel file is currently open. Please close it and try again.';
                                    } else if (errorMsg.includes('Authentication failed')) {
                                        errorMsg = ' SharePoint authentication failed. Please contact your administrator.';
                                    } else if (errorMsg.includes('Access denied')) {
                                        errorMsg = ' You don\'t have permission to modify this file.';
                                    } else if (errorMsg.includes('server error')) {
                                        errorMsg = ' SharePoint server error. Please try again in a few minutes.';
                                    }
                                    throw new Error(errorMsg);
                                }
                            } catch (error) {
                                displayError(`Error submitting data: ${error.message}`);
                            } finally {
                                submitButton.disabled = false;
                                submitButton.textContent = 'Submit to Excel';
                            }
                        };
                    } else {
                        throw new Error(data.error || 'Failed to preview data');
                    }
                } catch (error) {
                    console.error('Sheets error:', error);
                    
                    // Don't show error if request was aborted (user clicked stop)
                    if (error.name === 'AbortError') {
                        console.log('Sheets request was aborted by user');
                        return; // Exit early, don't show error message
                    }
                    
                    displayError(`Error previewing data: ${error.message}`);
                } finally {
                    // Clear the abort controller
                    currentAbortController = null;
                    
                    sendButton.classList.remove('processing');
                    sendIcon.style.display = 'block';
                    stopIcon.style.display = 'none';
                }
            } else {
                // Hide/remove the preview table if not in sheets mode
                if (currentPreviewMessageElement) {
                    removeElement(currentPreviewMessageElement);
                    currentPreviewMessageElement = null;
                }

                // Handle normal chat mode
                queryQueue.push({ text, isSpeech: lastInputWasSpeech });
                if (!lastInputWasSpeech) {
                    lastInputWasSpeech = false;
                }
                processNextQuery();
            }

            input.value = ''; // Clear input immediately
        }
        // Function to process the next query in the queue
        async function processNextQuery() {
            if (isProcessingQueue || queryQueue.length === 0) return;
            
            const sendButton = document.getElementById('send-button');
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');

            isProcessingQueue = true;
            sendButton.classList.add('processing');
            sendIcon.style.display = 'none';
            stopIcon.style.display = 'block';

            // Add glowing class when processing starts
            sendButton.classList.add('glowing');

            const { text, isSpeech } = queryQueue.shift();
            
            // Add user message to history and display immediately
            const userMessage = { 
                role: 'user', 
                text, 
                timestamp: new Date().toISOString(), 
                isSpeech 
            };
            chatHistory.push(userMessage);
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
            renderMessage(userMessage);
            
            // Store analysis data for the analysis panel
            storeAnalysisData(text);

            // Switch to chat view after first message
            if (chatHistory.length === 1 && !sheetsModeEnabled) {
                const welcomeScreen = document.getElementById('welcome-screen');
                const chatArea = document.getElementById('chat-area');
                if (welcomeScreen && welcomeScreen.style.display !== 'none') {
                    welcomeScreen.style.display = 'none';
                    chatArea.style.display = 'flex';
                }
            }

            // Show loader to reserve space
            const loader = displayLoader();

            try {
                // Sanitize history for sending
                const sanitizedHistory = chatHistory.slice(-5).map(msg => ({
                    role: msg.role,
                    text: msg.text,
                    timestamp: msg.timestamp || new Date().toISOString(),
                    isSpeech: msg.isSpeech || false
                }));

                // Reset abort flag for new request
                isRequestAborted = false;
                
                // Start response timer for enhanced feedback tracking
                if (typeof startResponseTimer === 'function') {
                    startResponseTimer();
                }
                
                // Create abort controller for this request
                currentAbortController = new AbortController();

                // Call backend chat endpoint (authentication removed)
                const response = await fetch("/chat", {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        text, 
                        history: sanitizedHistory,
                        is_speech: isSpeech, // Use the isSpeech from the queue item
                        conversation_id: window.currentSessionId
                    }),
                    signal: currentAbortController.signal
                });

                // Remove loader
                removeElement(loader);

                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.error) throw new Error(data.error);

                // Check if request was aborted before processing response
                if (isRequestAborted) {
                    console.log('Chat request was aborted, skipping response rendering');
                    return;
                }

                console.log('Backend response data:', data);
                
                // Update session stats after successful response
                updateSessionStatsFromResponse(data);
                
                // Validate and clean response text to prevent JSON display
                if (data.responses && data.responses[0]) {
                    data.responses[0] = cleanResponseText(data.responses[0]);
                }
                
                // Helper function to clean response text
                function cleanResponseText(responseText) {
                    // Check if the response looks like JSON
                    if (typeof responseText === 'string') {
                        const trimmed = responseText.trim();
                        
                        // If it starts and ends with curly braces, it might be JSON
                        if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
                            try {
                                const parsed = JSON.parse(trimmed);
                                // If it's a JSON object with a 'response' field, extract that
                                if (parsed && typeof parsed === 'object' && parsed.response) {
                                    console.log('Extracted response from JSON object:', parsed.response);
                                    return parsed.response;
                                }
                                // If it's JSON but doesn't have expected structure, return as is
                                console.log('JSON detected but no response field found');
                                return responseText;
                            } catch (e) {
                                // If JSON parsing fails, return original text
                                console.log('Failed to parse JSON-like response, returning as text');
                                return responseText;
                            }
                        }
                        
                        // Check for markdown JSON blocks and clean them
                        if (trimmed.includes('```json') || trimmed.includes('```')) {
                            let cleaned = trimmed.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                            // Try to parse the cleaned version
                            if (cleaned.startsWith('{') && cleaned.endsWith('}')) {
                                try {
                                    const parsed = JSON.parse(cleaned);
                                    if (parsed && typeof parsed === 'object' && parsed.response) {
                                        console.log('Extracted response from markdown JSON:', parsed.response);
                                        return parsed.response;
                                    }
                                } catch (e) {
                                    console.log('Failed to parse cleaned markdown JSON');
                                }
                            }
                        }
                    }
                    
                    // Return original response if no JSON patterns detected
                    return responseText;
                }
                console.log('Sources from backend:', data.sources);
                console.log('Number of sources:', data.sources ? data.sources.length : 0);
                
                // Debug each source
                if (data.sources && data.sources.length > 0) {
                    data.sources.forEach((source, index) => {
                        console.log(`Source ${index + 1}:`, source);
                        console.log(`  - filename: ${source.filename}`);
                        console.log(`  - link: ${source.link}`);
                        console.log(`  - page_info: ${source.page_info}`);
                    });
                } else {
                    console.log('No sources found in backend response');
                }

                // Debug: Check what we received from API
                console.log('API Response data:', data);
                console.log('Response text:', data.responses[0]);
                console.log('Response type:', typeof data.responses[0]);
                
                // Handle single response with typing animation and optional audio
                const botMessage = { 
                    role: 'assistant', 
                    text: data.responses[0],
                    sources: data.sources || [], // Add sources to the message
                    sql_query: data.sql_query || null, // Add SQL query to the message
                    query_type: data.query_type || null, // Add query type to the message
                    timestamp: new Date().toISOString(),
                    isSpeech: isSpeech, // Use the isSpeech from the queue item
                    docx_base64: data.docx_base64,
                    excel_download: data.excel_download || false, // Add Excel download flag
                    excel_file_id: data.excel_file_id || null // Add Excel file ID
                };
                
                console.log('Created botMessage:', botMessage);
                console.log('botMessage.sources:', botMessage.sources);
                console.log('botMessage.sources.length:', botMessage.sources.length);
                
                // Store response for TTS
                window.lastBotResponse = data.responses[0];
                
                chatHistory.push(botMessage);
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                
                // Update analysis data with SQL query if available
                if (data.sql_query) {
                    const analysisData = JSON.parse(sessionStorage.getItem('analysisData') || '[]');
                    if (analysisData.length > 0) {
                        // Update the last entry with SQL query
                        analysisData[analysisData.length - 1].sql_query = data.sql_query;
                        sessionStorage.setItem('analysisData', JSON.stringify(analysisData));
                    }
                }
                
                // Use typeMessage for streaming effect and optional simultaneous audio
                await typeMessage(botMessage, data.responses[0], sanitizedHistory, () => {
                    isProcessingQueue = false;
                    sendButton.classList.remove('processing');
                    
                    // Apply current analysis toggle state to newly rendered message
                    applyAnalysisToggleStateToNewMessage();
                    sendIcon.style.display = 'block';
                    stopIcon.style.display = 'none';
                    // Remove glowing class when typing is complete
                    sendButton.classList.remove('glowing');
                    
                    // Render chart if provided IMMEDIATELY - no delays
                    if (data.chart) {
                        console.log('Chart data received:', data.chart);
                        // Validate chart structure before rendering
                        if (data.chart && typeof data.chart === 'object' && 
                            data.chart.series && Array.isArray(data.chart.series) && 
                            data.chart.series.length > 0) {
                            try {
                                renderChart(data.chart);
                            } catch (chartError) {
                                console.error('Error rendering chart:', chartError);
                                console.error('Chart config that failed:', data.chart);
                            }
                        } else {
                            console.error('Invalid chart data structure:', data.chart);
                        }
                        // Add suggested prompts after chart is rendered
                        setTimeout(() => {
                            addSuggestedPrompts(data.suggestions || []);
                        }, 200);
                    } else {
                        // Add suggested prompts immediately if no chart
                        addSuggestedPrompts(data.suggestions || []);
                    }
                    
                    // Refresh sidebar from server after response is complete
                    updateChatHistoryDisplay();
                    
                    processNextQuery(); // Process next query in queue
                });
            } catch (error) {
                console.error('Fetch error details:', error);
                removeElement(loader);
                removeElement(document.querySelector('.typing-indicator'));
                displayError(`Error: ${error.message}. Ensure the backend is running on http://localhost:8000.`);
                isProcessingQueue = false;
                sendButton.classList.remove('processing');
                sendIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                // Remove glowing class on error
                sendButton.classList.remove('glowing');
                processNextQuery(); // Process next query in queue
            }
        }

        // Removed duplicate toggleSpeechRecognition function - using enhanced version above

        // Server-side transcription fallback
        async function startServerSideTranscription() {
            const micButton = document.getElementById('mic-button');
            
            if (!isMediaRecorderSupported) {
                displayError('Audio recording not supported in this browser. Please use Chrome or Edge.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.wav');

                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch('/transcribe', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            },
                            body: formData
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error ${response.status}`);
                        }

                        const data = await response.json();
                        if (data.text) {
                            document.getElementById('user-input').value = data.text;
                            lastInputWasSpeech = true;
                            enqueueMessage();
                        } else {
                            displayError('No speech detected. Please try again.');
                        }
                    } catch (error) {
                        displayError('Speech transcription error: ' + error.message);
                    } finally {
                        window.isRecording = false;
                        micButton.classList.remove('recording');
                        stream.getTracks().forEach(track => track.stop());
                    }
                };

                window.isRecording = true;
                micButton.classList.add('recording');
                mediaRecorder.start();
            } catch (error) {
                displayError('Failed to start audio recording: ' + error.message);
                window.isRecording = false;
                micButton.classList.remove('recording');
            }
        }

        // Handle Enter key to send message
        document.getElementById('user-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                window.lastInputWasSpeech = false; // Set to false when input is typed
                const input = document.getElementById('user-input');
                if (input.value.trim()) {  // Only send if there's actual text
                    enqueueMessage();
                }
            }
        });

        // Initial scroll to bottom
        scrollToBottom();

        async function syncSharePoint(action) {
            try {
                const response = await fetch('/api/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action })
                });
                const data = await response.json();

                if (!data.success) {
                    showMessage(data.error, 'error');
                    return;
                }

                let message = '';
                if (data.results.download) {
                    message += `Download: ${data.results.download.message} `;
                }
                if (data.results.upload) {
                    message += `Upload: ${data.results.upload.message}`;
                }
                
                if (data.web_url) {
                    message += ` <a href="${data.web_url}" target="_blank" style="color: #ed5d05; text-decoration: underline;">View in SharePoint</a>`;
                }
                showMessage(message.trim(), 'success');
            } catch (error) {
                showMessage(`Sync failed: ${error.message}`, 'error');
            }
        }

        // Initialize
        document.getElementById('previewBtn').addEventListener('click', previewData);
        document.getElementById('submitBtn').addEventListener('click', submitData);
        document.getElementById('syncDownloadBtn').addEventListener('click', () => syncSharePoint('download'));
        document.getElementById('syncUploadBtn').addEventListener('click', () => syncSharePoint('upload'));
        document.getElementById('syncBothBtn').addEventListener('click', () => syncSharePoint('both'));
        document.getElementById('sheetsModeCheckbox').addEventListener('change', (e) => toggleSheetsMode(e.target.checked));

        // Check initial sheets mode
        async function checkSheetsMode() {
            sheetsModeEnabled = document.getElementById('sheetsModeCheckbox').checked;
            toggleSheetsMode();
        }

        // Sync SharePoint function removed

        // Copilot Search Interface Functions
        function fillCopilotSearch(text) {
            const copilotInput = document.getElementById('copilot-search-input');
            if (copilotInput) {
                copilotInput.value = text;
                copilotInput.focus();
                
                // Add visual feedback
                copilotInput.style.backgroundColor = '#fef2f2';
                setTimeout(() => {
                    copilotInput.style.backgroundColor = 'transparent';
                }, 500);
            }
        }

        function sendCopilotMessage() {
            const copilotInput = document.getElementById('copilot-search-input');
            const sendBtn = document.getElementById('copilot-send-btn');
            
            if (!copilotInput || !copilotInput.value.trim()) {
                return;
            }

            // Disable send button temporarily
            sendBtn.disabled = true;
            sendBtn.style.opacity = '0.6';

            // Get the message text
            const messageText = copilotInput.value.trim();
            
            // Clear the input
            copilotInput.value = '';
            
            // Transfer to main chat input and send
            const mainInput = document.getElementById('user-input');
            if (mainInput) {
                mainInput.value = messageText;
                
                // Switch to chat view
                const welcomeScreen = document.getElementById('welcome-screen');
                const chatArea = document.getElementById('chat-area');
                if (welcomeScreen && chatArea) {
                    welcomeScreen.style.display = 'none';
                    chatArea.style.display = 'flex';
                }
                
                // Show floating button in chat area
                toggleFloatingButton(true);
                
                // Send the message
                enqueueMessage();
            }

            // Re-enable send button
            setTimeout(() => {
                sendBtn.disabled = false;
                sendBtn.style.opacity = '1';
            }, 1000);
        }

        // Enhanced microphone functionality for copilot search using PocketSphinx
        async function startVoiceRecognition() {
            console.log('Starting copilot voice recognition...');
            
            // Check if any speech recognition is supported
            if (!window.isPocketSphinxSupported && !window.isWebSpeechSupported) {
                console.error('Voice recognition not supported in this browser');
                alert('Voice recognition not supported in this browser. Please use a modern browser.');
                return;
            }

            const micButton = document.getElementById('copilot-mic-btn');
            console.log('Microphone button found:', !!micButton);

            try {
                // Use the same recognition system as the main chat
                if (window.isPocketSphinxSupported && window.pocketSphinxRecognizer) {
                    await startCopilotPocketSphinxRecognition(micButton);
                } else if (window.isWebSpeechSupported) {
                    startCopilotWebSpeechRecognition(micButton);
                } else {
                    throw new Error('No speech recognition method available');
                }
                
            } catch (error) {
                console.error('Error starting copilot voice recognition:', error);
                alert('Error starting voice recognition: ' + error.message);
                
                // Reset button state on error
                if (micButton) {
                    resetCopilotMicButton(micButton);
                }
            }
        }

        // PocketSphinx recognition for copilot search
        async function startCopilotPocketSphinxRecognition(micButton) {
            console.log('Starting PocketSphinx copilot recognition...');
            
            // Set up one-time event handlers for this recognition session
            const originalResultHandler = window.pocketSphinxRecognizer._events?.result?.[0];
            const originalErrorHandler = window.pocketSphinxRecognizer._events?.error?.[0];
            
            // Temporary handlers for copilot search
            const copilotResultHandler = (text) => {
                console.log('Copilot PocketSphinx result:', text);
                handleCopilotResult(text);
                resetCopilotMicButton(micButton);
                
                // Restore original handlers
                if (originalResultHandler) {
                    window.pocketSphinxRecognizer.off('result', copilotResultHandler);
                    window.pocketSphinxRecognizer.on('result', originalResultHandler);
                }
            };
            
            const copilotErrorHandler = (error) => {
                console.error('Copilot PocketSphinx error:', error);
                alert('Voice recognition error: ' + error);
                resetCopilotMicButton(micButton);
                
                // Restore original handlers
                if (originalErrorHandler) {
                    window.pocketSphinxRecognizer.off('error', copilotErrorHandler);
                    window.pocketSphinxRecognizer.on('error', originalErrorHandler);
                }
            };
            
            // Set copilot-specific handlers
            window.pocketSphinxRecognizer.off('result', originalResultHandler);
            window.pocketSphinxRecognizer.off('error', originalErrorHandler);
            window.pocketSphinxRecognizer.on('result', copilotResultHandler);
            window.pocketSphinxRecognizer.on('error', copilotErrorHandler);
            
            // Start recognition (reuse the existing audio setup if available)
            if (window.isRecording) {
                // If main recognition is already running, just change the handler
                setCopilotMicRecording(micButton);
            } else {
                // Start new recognition session
                await startPocketSphinxRecognition();
                setCopilotMicRecording(micButton);
            }
        }

        // Web Speech API recognition for copilot search (fallback)
        function startCopilotWebSpeechRecognition(micButton) {
            console.log('Starting Web Speech copilot recognition...');
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();

            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = function() {
                console.log('Copilot voice recognition started');
                setCopilotMicRecording(micButton);
            };

            recognition.onresult = function(event) {
                console.log('Copilot voice recognition result received');
                const transcript = event.results[0][0].transcript;
                console.log('Copilot transcript:', transcript);
                handleCopilotResult(transcript);
            };

            recognition.onerror = function(event) {
                console.error('Copilot speech recognition error:', event.error);
                alert('Voice recognition error: ' + event.error);
                resetCopilotMicButton(micButton);
            };

            recognition.onend = function() {
                console.log('Copilot voice recognition ended');
                resetCopilotMicButton(micButton);
            };

            recognition.start();
            console.log('Copilot voice recognition started successfully');
        }

        // Handle copilot search result
        function handleCopilotResult(transcript) {
            const searchInput = document.getElementById('copilot-search-input');
            
            if (searchInput) {
                searchInput.value = transcript;
                searchInput.focus();
                
                // Trigger input event for any listeners
                const inputEvent = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(inputEvent);
                
                console.log('Copilot transcript inserted into input field');
            } else {
                console.error('Copilot search input field not found');
            }
        }

        // Set copilot microphone to recording state
        function setCopilotMicRecording(micButton) {
            if (micButton) {
                micButton.style.backgroundColor = '#059669'; // Green when listening
                micButton.style.animation = 'pulse 1s infinite';
                micButton.classList.add('recording');
            }
        }

        // Reset copilot microphone button state
        function resetCopilotMicButton(micButton) {
            if (micButton) {
                micButton.style.backgroundColor = '#1F7246'; // Back to red
                micButton.style.animation = 'none';
                micButton.classList.remove('recording');
            }
        }

        // Enhanced search function
        function handleSearch(query) {
            try {
                if (!query || query.trim() === '') {
                    console.warn('Empty search query');
                    return;
                }

                console.log('Processing search:', query);
                
                // Use existing sendCopilotMessage function
                const copilotInput = document.getElementById('copilot-search-input');
                if (copilotInput) {
                    copilotInput.value = query;
                    console.log('Calling sendCopilotMessage with query:', query);
                    sendCopilotMessage();
                } else {
                    console.error('Copilot input field not found');
                }
                
            } catch (error) {
                console.error('Search error:', error);
            }
        }

        // Enhanced Copilot Search Event Handlers
        function initializeCopilotSearch() {
            console.log('Initializing copilot search functionality...');
            
            const copilotInput = document.getElementById('copilot-search-input');
            const copilotMicButton = document.getElementById('copilot-mic-btn');
            
            if (!copilotInput) {
                console.error('Copilot input not found');
                return;
            }

            console.log('Copilot input found:', copilotInput);

            // Remove any existing event listeners to prevent duplicates
            copilotInput.removeEventListener('keydown', handleCopilotEnterKey);
            copilotInput.removeEventListener('keypress', handleCopilotEnterKey);
            if (copilotMicButton) {
                copilotMicButton.removeEventListener('click', handleCopilotMicClick);
            }

            // Add Enter key functionality
            copilotInput.addEventListener('keydown', handleCopilotEnterKey);
            copilotInput.addEventListener('keypress', handleCopilotEnterKey);
            console.log('Enter key event listeners added to copilot input');

            // Add microphone functionality
            if (copilotMicButton) {
                copilotMicButton.addEventListener('click', handleCopilotMicClick);
                console.log('Microphone button event listener added');
            } else {
                console.error('Microphone button not found');
            }

            // Test if event listeners are working
            console.log('Testing Enter key functionality...');
            copilotInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    console.log('Enter key detected on copilot input!');
                }
            });

            console.log('Copilot search functionality initialized successfully');
        }

        // Handle Enter key for copilot search
        function handleCopilotEnterKey(event) {
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault();
                event.stopPropagation();
                
                const inputValue = event.target.value.trim();
                console.log('Enter key pressed, input value:', inputValue);
                
                if (inputValue) {
                    // Call sendCopilotMessage directly instead of handleSearch
                    console.log('Calling sendCopilotMessage directly');
                    sendCopilotMessage();
                } else {
                    console.log('Empty input, not processing');
                }
            }
        }

        // Handle microphone click for copilot search
        function handleCopilotMicClick(event) {
            event.preventDefault();
            event.stopPropagation();
            console.log('Microphone button clicked');
            startVoiceRecognition();
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - initializing copilot search');
            // Wait a bit for all elements to be fully loaded
            setTimeout(initializeCopilotSearch, 100);
            // Try again after a longer delay in case elements load later
            setTimeout(initializeCopilotSearch, 1000);
            
            // Initialize analysis toggle
            initializeAnalysisToggle();
        });

        // Also try to initialize if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeCopilotSearch);
        } else {
            console.log('DOM already loaded - initializing copilot search immediately');
            initializeCopilotSearch();
        }

        // Additional fallback - try to initialize when window loads
        window.addEventListener('load', function() {
            console.log('Window loaded - ensuring copilot search is initialized');
            setTimeout(initializeCopilotSearch, 500);
            
            // Also initialize dropdown functionality
            setTimeout(initializeAllCardDropdowns, 1000);
        });

        // Click outside to close dropdowns
        document.addEventListener('click', function(e) {
            // Check if click is outside any dropdown
            if (!e.target.closest('.prompt-card, .prompt-card-extended')) {
                document.querySelectorAll('.card-expanded-content.expanded').forEach(content => {
                    content.classList.remove('expanded');
                    const button = content.closest('.prompt-card, .prompt-card-extended').querySelector('.dropdown-toggle');
                    if (button) {
                        button.classList.remove('rotated');
                        const chevron = button.querySelector('i');
                        if (chevron) {
                            chevron.className = 'fa fa-chevron-down';
                        }
                    }
                });
            }
        });

        // Initialize dropdown functionality when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded - initializing dropdown functionality');
            setTimeout(initializeAllCardDropdowns, 500);
        });

        // Quick fix function that can be called manually
        function quickFixDropdowns() {
            console.log(' Quick fix for dropdowns...');
            
            // Wait for elements to be available
            setTimeout(() => {
                const cardTypes = ['anomaly', 'failure', 'inventory', 'metrics', 'assets', 'scheduling'];
                
                cardTypes.forEach(cardType => {
                    const arrow = document.querySelector(`[onclick*="toggleCardDropdown.*${cardType}"]`);
                    const dropdown = document.getElementById('dropdown-' + cardType);
                    
                    if (arrow && dropdown) {
                        console.log(` Fixing ${cardType} dropdown`);
                        
                        // Remove all existing event listeners
                        const newArrow = arrow.cloneNode(true);
                        arrow.parentNode.replaceChild(newArrow, arrow);
                        
                        // Add direct click handler
                        newArrow.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log(` Direct click on ${cardType}`);
                            
                            // Simple toggle logic
                            if (dropdown.style.display === 'block') {
                                dropdown.style.display = 'none';
                                newArrow.textContent = '';
                            } else {
                                dropdown.style.display = 'block';
                                newArrow.textContent = '';
                            }
                        });
                        
                        // Set onclick attribute as backup
                        newArrow.setAttribute('onclick', `event.preventDefault(); event.stopPropagation(); console.log('onclick ${cardType}'); if(document.getElementById('dropdown-${cardType}').style.display === 'block') { document.getElementById('dropdown-${cardType}').style.display = 'none'; this.textContent = ''; } else { document.getElementById('dropdown-${cardType}').style.display = 'block'; this.textContent = ''; }`);
                        
                    } else {
                        console.warn(` Could not fix ${cardType} - elements not found`);
                    }
                });
                
                console.log(' Quick fix complete');
            }, 1000);
        }

        // Make quick fix available globally
        window.quickFixDropdowns = quickFixDropdowns;

        // Mutation observer to watch for new cards being added
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.addedNodes.length > 0) {
                    // Check if new cards were added
                    const hasNewCards = Array.from(mutation.addedNodes).some(node =>
                        node.nodeType === 1 && (
                            node.classList.contains('prompt-card-extended') ||
                            node.classList.contains('prompt-card') ||
                            node.hasAttribute('data-card')
                        )
                    );

                    if (hasNewCards) {
                        console.log('New cards detected, reinitializing dropdowns');
                        setTimeout(() => {
                            initializeAllCardDropdowns();
                        }, 100);
                    }
                }
            });
        });

        // Start observing
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Chat Search Interface Functions
        function fillChatSearch(text) {
            const chatInput = document.getElementById('user-input');
            if (chatInput) {
                chatInput.value = text;
                chatInput.focus();
                
                // Add visual feedback
                chatInput.style.backgroundColor = '#fef2f2';
                setTimeout(() => {
                    chatInput.style.backgroundColor = 'transparent';
                }, 500);
            }
        }

        // New function for floating suggestions that fill and send
        function fillChatSearchAndSend(text) {
            const chatInput = document.getElementById('user-input');
            if (chatInput) {
                chatInput.value = text;
                chatInput.focus();
                
                // Add visual feedback
                chatInput.style.backgroundColor = '#fef2f2';
                setTimeout(() => {
                    chatInput.style.backgroundColor = 'transparent';
                }, 500);
                
                // Auto-send the message
                setTimeout(() => {
                    enqueueMessage();
                }, 100);
            }
        }

        // Retry SharePoint sync function
        async function retrySharePointSync() {
            try {
                // Disable the retry button temporarily
                const retryButton = event.target;
                retryButton.disabled = true;
                retryButton.textContent = ' Retrying...';
                
                const response = await fetch("https://pgp-excel-agent.politegrass-0dd17cd2.centralindia.azurecontainerapps.io/api/retry-sync", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const submitData = await response.json();
                
                if (submitData.success) {
                    
                    let messageText = ` ${submitData.message.replace(/[()]/g, '')}`;  // Fix: syncedtoSharepoint's weird font formatting issue.
                                    
                    if (submitData.web_url) {
                        messageText += ` <a href="${submitData.web_url}" target="_blank" style="color: #ed5d05; text-decoration: underline;">View Changes on SharePoint</a>`;
                    }
                    
                    // Add retry success message to chat
                    const retryMessage = {
                        role: 'assistant',
                        text: messageText,
                        timestamp: new Date().toISOString()
                    };
                    chatHistory.push(retryMessage);
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    renderMessage(retryMessage);
                    
                    // Remove the retry button from the previous message
                    retryButton.parentElement.removeChild(retryButton);
                } else {
                    // Re-enable button and show error
                    retryButton.disabled = false;
                    retryButton.textContent = ' Retry SharePoint Sync';
                    
                    let errorMsg = submitData.error || 'Retry failed';
                    if (errorMsg.includes('File is currently open')) {
                        errorMsg = ' File is still open. Please close the Excel file first.';
                    }
                    
                    const errorMessage = {
                        role: 'assistant',
                        text: errorMsg,
                        timestamp: new Date().toISOString()
                    };
                    chatHistory.push(errorMessage);
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    renderMessage(errorMessage);
                }
            } catch (error) {
                // Re-enable button on error
                const retryButton = event.target;
                retryButton.disabled = false;
                retryButton.textContent = ' Retry SharePoint Sync';
                
                displayError(`Retry failed: ${error.message}`);
            }
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            function isExternalLink(url) {
                try {
                    const link = new URL(url, window.location.href);
                    return link.hostname !== window.location.hostname;
                } catch (e) {
                    return false;
                }
            }
                // ============ Floating Prompts Button + Modal ============
                const userInputEl = document.getElementById('user-input');
                const promptsFab = document.getElementById('prompts-fab');
                const promptsModal = document.getElementById('promptsModal');
                const promptsGridHost = document.getElementById('promptsGridHost');
                const closePromptsModalBtn = document.getElementById('closePromptsModal');

                // Track if conversation has started
                let conversationStarted = false;

                  function updatePromptsFabVisibility() {
                    const hasText = !!userInputEl.value.trim();
                    
                    // Check if we're still on the first page (welcome screen)
                    const isFirstPage = chatHistory.length === 0 && !conversationStarted;
                    
                    // Hide button ONLY on first page, otherwise always show (except in sheets mode)
                    if (isFirstPage) {
                        // First page: hide button always
                        promptsFab.classList.add('hidden');
                    } else {
                        // Subsequent pages: show button always (except in sheets mode)
                        promptsFab.classList.toggle('hidden', sheetsModeEnabled);
                    }
                }

                // Update conversation started flag when first message is sent
                const originalEnqueueMessage = window.enqueueMessage;
                window.enqueueMessage = function() {
                    // Mark conversation as started
                    conversationStarted = true;
                    
                    // Update button visibility immediately
                    updatePromptsFabVisibility();
                    
                    // Call original function
                    return originalEnqueueMessage.apply(this, arguments);
                };


                // Show on typing
                userInputEl.addEventListener('input', updatePromptsFabVisibility);

                // Hide when sheets mode toggles
                function refreshFabForSheets() {
                    // Called after toggleSheetsMode flips the global flag
                    updatePromptsFabVisibility();
                }
                // Hook into existing toggleSheetsMode by wrapping it
                // Use setTimeout to ensure toggleSheetsMode is defined
                setTimeout(function() {
                    if (typeof window.toggleSheetsMode === 'function' || typeof toggleSheetsMode === 'function') {
                        const _toggleSheetsModeOrig = window.toggleSheetsMode || toggleSheetsMode;
                        window.toggleSheetsMode = function() {
                            if (_toggleSheetsModeOrig) {
                                _toggleSheetsModeOrig();
                            }
                            refreshFabForSheets();
                        };
                    }
                }, 0);

                // Ensure it stays hidden while processing queue
                document.addEventListener('visibilitychange', updatePromptsFabVisibility);

                // Fixed modal opening with proper event handling to prevent double triggers
                promptsFab.addEventListener('click', () => {
                    const modal = document.getElementById('promptsModal');
                    const overlay = document.getElementById('cardsOverlay');
                    const grid = overlay ? overlay.querySelector('.cards-grid') : null;
                    const gridHost = document.getElementById('promptsGridHost');
                    
                    // Clear and populate grid
                    gridHost.innerHTML = '';
                    if (grid) {
                        const clone = grid.cloneNode(true);
                        
                        // Reset dropdown states
                        clone.querySelectorAll('.dropdown-content').forEach(dc => {
                            dc.classList.remove('show');
                            dc.style.display = 'none';
                        });
                        
                        clone.querySelectorAll('.dropdown-toggle').forEach(arrow => {
                            arrow.classList.remove('rotated');
                        });
                        
                        // **FIX 1: Add dropdown arrow functionality with proper event handling**
                        clone.querySelectorAll('.dropdown-toggle').forEach(arrow => {
                            arrow.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                e.stopImmediatePropagation(); // Prevent double triggering
                                
                                const card = arrow.closest('.ai-card');
                                if (!card) return;
                                
                                // Check if current dropdown is already open
                                const isCurrentlyOpen = card.classList.contains('active');
                                
                                // Close all dropdowns first
                                const allCards = clone.querySelectorAll('.ai-card');
                                allCards.forEach(c => {
                                    c.classList.remove('active');
                                    const dropdown = c.querySelector('.dropdown-content');
                                    const arrow = c.querySelector('.dropdown-arrow');
                                    if (dropdown) dropdown.style.display = 'none';
                                    if (arrow) arrow.classList.remove('rotated');
                                });
                                
                                // If current dropdown was not open, open it
                                if (!isCurrentlyOpen) {
                                    card.classList.add('active');
                                }
                            });
                        });
                        
                        // **FIX 2: Add dropdown item click functionality with debouncing**
                        let lastClickTime = 0;
                        const debounceDelay = 500; // 500ms debounce
                        
                        clone.querySelectorAll('.dropdown-item').forEach(item => {
                            const promptText = item.textContent.trim();
                            item.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                e.stopImmediatePropagation();
                                
                                // **DEBOUNCE: Prevent double clicks**
                                const currentTime = Date.now();
                                if (currentTime - lastClickTime < debounceDelay) {
                                    console.log('Double click prevented');
                                    return;
                                }
                                lastClickTime = currentTime;
                                
                                console.log('Prompt selected:', promptText);
                                userInputEl.value = promptText;
                                modal.close();
                                
                        // Do not auto-send; just fill input
                        const evt = new Event('input', { bubbles: true });
                        userInputEl.dispatchEvent(evt);
                            });
                        });
                        
                        // **FIX 3: Show More/Less Categories with proper event handling**
                        const showMoreButton = clone.querySelector('#show-more-button');
                        const additionalCategories = clone.querySelector('#additional-categories');
                        
                        if (showMoreButton && additionalCategories) {
                            additionalCategories.style.display = 'none';
                            showMoreButton.innerHTML = `
                                <span>Show More Categories</span>
                                <span class="show-more-arrow"></span>
                            `;
                            
                            showMoreButton.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                e.stopImmediatePropagation();
                                
                                const arrow = showMoreButton.querySelector('.show-more-arrow');
                                const textSpan = showMoreButton.querySelector('span:first-child');
                                
                                const isHidden = (additionalCategories.style.display === 'none' || 
                                                additionalCategories.style.display === '');
                                
                                if (isHidden) {
                                    additionalCategories.style.display = 'grid';
                                    textSpan.textContent = 'Show Less Categories';
                                    arrow.textContent = '';
                                    arrow.classList.add('rotated');
                                } else {
                                    additionalCategories.style.display = 'none';
                                    textSpan.textContent = 'Show More Categories';
                                    arrow.textContent = '';
                                    arrow.classList.remove('rotated');
                                }
                            });
                            
                            // **FIX 4: Handle additional category items with same debouncing**
                            additionalCategories.querySelectorAll('.dropdown-toggle').forEach(arrow => {
                                arrow.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    
                                    const card = arrow.closest('.ai-card');
                                    if (!card) return;
                                    
                                    // Check if current dropdown is already open
                                    const isCurrentlyOpen = card.classList.contains('active');
                                    
                                    // Close all dropdowns first
                                    const allCards = additionalCategories.querySelectorAll('.ai-card');
                                    allCards.forEach(c => {
                                        c.classList.remove('active');
                                        const dropdown = c.querySelector('.dropdown-content');
                                        const arrow = c.querySelector('.dropdown-arrow');
                                        if (dropdown) dropdown.style.display = 'none';
                                        if (arrow) arrow.classList.remove('rotated');
                                    });
                                    
                                    // If current dropdown was not open, open it
                                    if (!isCurrentlyOpen) {
                                        card.classList.add('active');
                                    }
                                });
                            });
                            
                            additionalCategories.querySelectorAll('.dropdown-item').forEach(item => {
                                const promptText = item.textContent.trim();
                                item.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    
                                    // Same debounce logic
                                    const currentTime = Date.now();
                                    if (currentTime - lastClickTime < debounceDelay) {
                                        console.log('Double click prevented (additional)');
                                        return;
                                    }
                                    lastClickTime = currentTime;
                                    
                                    console.log('Additional prompt selected:', promptText);
                                    userInputEl.value = promptText;
                                    modal.close();
                                    
                                    setTimeout(() => {
                                        enqueueMessage();
                                    }, 100);
                                });
                            });
                        }
                        
                        gridHost.appendChild(clone);
                    }
                    
                    // Show modal
                    modal.showModal();
                });




                // Open modal and load cards
                promptsFab.addEventListener('click', () => {
                // Clone the first page prompt cards grid
                try {
                    const overlay = document.getElementById('cardsOverlay');
                    const grid = overlay ? overlay.querySelector('.cards-grid') : null;
                    promptsGridHost.innerHTML = '';
                    if (grid) {
                    const clone = grid.cloneNode(true);
                    // Expand all dropdowns inside modal by default
                    clone.querySelectorAll('.dropdown-content').forEach(dc => dc.classList.add('show'));
                    // Prevent the card container click from hiding overlay logic
                    clone.querySelectorAll('.ai-card').forEach(card => {
                        card.onclick = null; // disable original card root click
                    });
                    // Keep dropdown toggles working inside modal
                    clone.querySelectorAll('.dropdown-toggle').forEach(arrow => {
                        arrow.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const dc = arrow.closest('.card-header').parentElement.querySelector('.dropdown-content');
                        dc.classList.toggle('show');
                        arrow.classList.toggle('rotated');
                        });
                    });
                    // When a dropdown item is clicked, insert the text to input and send
                    clone.querySelectorAll('.dropdown-item').forEach(item => {
                        const promptText = item.textContent.trim();
                        item.addEventListener('click', (e) => {
                        e.preventDefault();
                        // Put prompt into input, preserve any typed prefix
                        userInputEl.value = promptText;
                        updatePromptsFabVisibility();
                        // Close modal and fill input only
                        if (typeof promptsModal.close === 'function') promptsModal.close();
                        const input = document.getElementById('user-input');
                        if (input) {
                            input.value = promptText;
                            const evt = new Event('input', { bubbles: true });
                            input.dispatchEvent(evt);
                        }
                        });
                    });
                    promptsGridHost.appendChild(clone);
                    } else {
                    // Fallback: simple list if cards missing
                    const fallback = document.createElement('div');
                    fallback.className = 'p-5 text-sm text-gray-600';
                    fallback.textContent = 'Prompt cards unavailable.';
                    promptsGridHost.appendChild(fallback);
                    }
                } catch (e) {
                    console.warn('Failed to prepare prompt grid:', e);
                }
                if (typeof promptsModal.showModal === 'function') {
                    promptsModal.showModal(); // native modal
                } else {
                    // Fallback if dialog not supported
                    promptsModal.classList.remove('hidden');
                }
                });

                // Close modal
                closePromptsModalBtn.addEventListener('click', () => {
                if (typeof promptsModal.close === 'function') promptsModal.close();
                userInputEl.focus();
                });

                // Close on backdrop click
                promptsModal.addEventListener('click', (e) => {
                const rect = promptsModal.querySelector('div.bg-white').getBoundingClientRect();
                const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
                if (!inside) {
                    if (typeof promptsModal.close === 'function') promptsModal.close();
                    userInputEl.focus();
                }
                });

                // Also hide FAB once a message is enqueued
                const _enqueueMessageOrig = enqueueMessage;
                window.enqueueMessage = async function() {
                promptsFab.classList.add('hidden');
                return _enqueueMessageOrig.apply(this, arguments);
                };

                // Initial state
                updatePromptsFabVisibility();
    
            function updateExistingLinks() {
                const allLinks = document.querySelectorAll('a[href]');
                allLinks.forEach(link => {
                    if (isExternalLink(link.href)) {
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer'; 
                    }
                });
            }

            updateExistingLinks();

            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            if (node.tagName === 'A' && node.href && isExternalLink(node.href)) {
                                node.target = '_blank';
                                node.rel = 'noopener noreferrer';
                            }
                            
                            const links = node.querySelectorAll ? node.querySelectorAll('a[href]') : [];
                            links.forEach(link => {
                                if (isExternalLink(link.href)) {
                                    link.target = '_blank';
                                    link.rel = 'noopener noreferrer';
                                }
                            });
                        }
                    });
                });
            });

            observer.observe(document.body, {
                childList: true,
                subtree: true
            });

            // backup
            document.addEventListener('click', function(e) {
                if (e.target.tagName === 'A' && e.target.href && isExternalLink(e.target.href)) {
                    if (!e.target.target || e.target.target === '_self') {
                        e.preventDefault();
                        window.open(e.target.href, '_blank', 'noopener,noreferrer');
                    }
                }
            });
        });

    </script>
    <script>
        // Utility to render charts described in code blocks or detect chart JSON in text
        function renderChartsInElement(container) {
            if (!container) return;
            
            // Method 1: Find all code blocks with chart language indicators
            const codeBlocks = container.querySelectorAll('pre code');
            codeBlocks.forEach((codeBlock, index) => {
                const className = codeBlock.className || '';
                if (className.includes('language-chart') || className.includes('language-plotly') || className.includes('language-echart')) {
                    renderChartFromCodeBlock(codeBlock, index);
                }
            });
            
            // Method 2: Scan for chart data patterns in text content
            scanAndRenderChartsFromText(container);
        }
        
        function renderChartFromCodeBlock(codeBlock, index) {
            let jsonText = codeBlock.textContent.trim();
            try {
                const cfg = JSON.parse(jsonText);
                const className = codeBlock.className || '';
                
                // Create wrapper div
                const chartWrapper = document.createElement('div');
                const chartId = `chart-${Date.now()}-${index}`;
                chartWrapper.id = chartId;
                chartWrapper.style.maxWidth = '100%';
                chartWrapper.style.height = '400px';
                chartWrapper.style.marginTop = '15px';
                chartWrapper.style.marginBottom = '15px';
                chartWrapper.style.border = '1px solid #e0e0e0';
                chartWrapper.style.borderRadius = '8px';
                chartWrapper.style.padding = '10px';
                chartWrapper.style.position = 'relative';

                // Replace code block with chart container
                const pre = codeBlock.parentElement; // <pre>
                pre.parentElement.replaceChild(chartWrapper, pre);

                if (className.includes('language-plotly')) {
                    // Plotly chart
                    Plotly.newPlot(chartWrapper, cfg.data || [], cfg.layout || {}, {responsive: true});
                    // Add download button for Plotly chart
                    addChartDownloadButton(chartWrapper, 'plotly', chartId);
                } else {
                    // ECharts chart
                    const echartsDiv = document.createElement('div');
                    echartsDiv.style.width = '100%';
                    echartsDiv.style.height = '100%';
                    chartWrapper.appendChild(echartsDiv);
                    
                    // Convert Chart.js config to ECharts if needed
                    let echartsConfig = cfg;
                    if (cfg.type && ['bar', 'line', 'pie', 'doughnut'].includes(cfg.type)) {
                        echartsConfig = convertChartJsToECharts(cfg);
                    }
                    
                    // Initialize ECharts
                    if (typeof echarts !== 'undefined') {
                        const chart = echarts.init(echartsDiv);
                        const finalConfig = { ...echartsConfig };
                        delete finalConfig.type; // Remove type field for ECharts
                        chart.setOption(finalConfig);
                        
                        // Add download button for ECharts chart
                        addChartDownloadButton(chartWrapper, 'echarts', chartId, chart);
                    } else {
                        echartsDiv.innerHTML = '<div style="text-align: center; padding: 20px;">ECharts library not loaded</div>';
                    }
                }
            } catch (e) {
                console.error('Failed to render chart from code block:', e);
            }
        }
        
        function scanAndRenderChartsFromText(container) {
            const textContent = container.textContent || container.innerText || '';
            
            // Look for common chart data patterns
            if (textContent.includes('Fault Type Distribution') || textContent.includes('Symptom Distribution') || 
                textContent.includes('pie chart') || textContent.includes('bar chart')) {
                
                // Extract data from tables if present
                const tables = container.querySelectorAll('table');
                tables.forEach((table, index) => {
                    const chartData = extractChartDataFromTable(table);
                    if (chartData) {
                        const chartWrapper = createChartFromData(chartData, index);
                        if (chartWrapper) {
                            table.parentElement.insertBefore(chartWrapper, table.nextSibling);
                        }
                    }
                });
            }
        }
        
        function extractChartDataFromTable(table) {
            const rows = table.querySelectorAll('tr');
            if (rows.length < 2) return null;
            
            const headers = Array.from(rows[0].querySelectorAll('th, td')).map(cell => cell.textContent.trim());
            const data = [];
            
            for (let i = 1; i < rows.length; i++) {
                const cells = Array.from(rows[i].querySelectorAll('td'));
                if (cells.length >= 2) {
                    const label = cells[0].textContent.trim();
                    const value = cells[1].textContent.trim();
                    // Try to parse percentage or number
                    const numValue = parseFloat(value.replace('%', '').replace(',', ''));
                    if (!isNaN(numValue)) {
                        data.push({ label, value: numValue });
                    }
                }
            }
            
            return data.length > 0 ? { headers, data } : null;
        }
        
        function createChartFromData(chartData, index) {
            if (!chartData || !chartData.data || chartData.data.length === 0) return null;
            
            const chartWrapper = document.createElement('div');
            chartWrapper.id = `auto-chart-${Date.now()}-${index}`;
            chartWrapper.style.maxWidth = '100%';
            chartWrapper.style.height = '400px';
            chartWrapper.style.marginTop = '15px';
            chartWrapper.style.marginBottom = '15px';
            chartWrapper.style.border = '1px solid #e0e0e0';
            chartWrapper.style.borderRadius = '8px';
            chartWrapper.style.padding = '10px';
            chartWrapper.style.backgroundColor = '#fafafa';
            chartWrapper.style.position = 'relative';
            
            const canvas = document.createElement('canvas');
            canvas.width = chartWrapper.clientWidth || 800;
            canvas.height = chartWrapper.clientHeight || 400;
            chartWrapper.appendChild(canvas);
            
            // Create pie chart configuration
            const config = {
                type: 'pie',
                data: {
                    labels: chartData.data.map(item => item.label),
                    datasets: [{
                        data: chartData.data.map(item => item.value),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
                        ],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartData.headers[0] || 'Data Distribution',
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            };
            
            // Use ECharts instead of Chart.js
            const echartsDiv = document.createElement('div');
            echartsDiv.style.width = '100%';
            echartsDiv.style.height = '100%';
            chartWrapper.appendChild(echartsDiv);
            
            // Convert Chart.js config to ECharts
            const echartsConfig = convertChartJsToECharts(config);
            
            if (typeof echarts !== 'undefined') {
                const chart = echarts.init(echartsDiv);
                const finalConfig = { ...echartsConfig };
                delete finalConfig.type;
                chart.setOption(finalConfig);
                
                // Add download button for ECharts chart
                addChartDownloadButton(chartWrapper, 'echarts', chartWrapper.id, chart);
            } else {
                echartsDiv.innerHTML = '<div style="text-align: center; padding: 20px;">ECharts library not loaded</div>';
            }
            return chartWrapper;
        }

        // Function to add download button to charts
        function addChartDownloadButton(chartWrapper, chartType, chartId, chartInstance = null) {
            const downloadButton = document.createElement('button');
            downloadButton.innerHTML = ' Download PNG';
            downloadButton.title = 'Download chart as PNG image';
            downloadButton.style.position = 'absolute';
            downloadButton.style.top = '8px';
            downloadButton.style.right = '8px';
            downloadButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            downloadButton.style.color = 'white';
            downloadButton.style.border = 'none';
            downloadButton.style.borderRadius = '8px';
            downloadButton.style.padding = '10px 15px';
            downloadButton.style.fontSize = '13px';
            downloadButton.style.fontWeight = '600';
            downloadButton.style.cursor = 'pointer';
            downloadButton.style.zIndex = '1000';
            downloadButton.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            downloadButton.style.transition = 'all 0.3s ease';
            downloadButton.style.backdropFilter = 'blur(10px)';
            downloadButton.style.border = '1px solid rgba(255,255,255,0.2)';

            // Store original styles for reset
            const originalStyles = {
                background: downloadButton.style.background,
                innerHTML: downloadButton.innerHTML
            };

            downloadButton.addEventListener('mouseenter', () => {
                if (!downloadButton.disabled) {
                    downloadButton.style.background = 'linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%)';
                    downloadButton.style.transform = 'translateY(-2px) scale(1.05)';
                    downloadButton.style.boxShadow = '0 6px 20px rgba(0,0,0,0.25)';
                }
            });

            downloadButton.addEventListener('mouseleave', () => {
                if (!downloadButton.disabled) {
                    downloadButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    downloadButton.style.transform = 'translateY(0) scale(1)';
                    downloadButton.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                }
            });

            downloadButton.addEventListener('click', async () => {
                // Disable button and show loading state
                downloadButton.disabled = true;
                downloadButton.innerHTML = ' Downloading...';
                downloadButton.style.background = 'linear-gradient(135deg, #6B7280 0%, #4B5563 100%)';
                downloadButton.style.cursor = 'not-allowed';
                downloadButton.style.transform = 'translateY(0) scale(1)';

                try {
                    // Call the download function
                    await downloadChart(chartType, chartId, chartInstance);

                    // Show success state briefly
                    downloadButton.innerHTML = ' Downloaded!';
                    downloadButton.style.background = 'linear-gradient(135deg, #10B981 0%, #059669 100%)';
                    downloadButton.style.background = '#10B981';

                    // Reset after 2 seconds
                    setTimeout(() => {
                        downloadButton.disabled = false;
                        downloadButton.innerHTML = originalStyles.innerHTML;
                        downloadButton.style.background = originalStyles.background;
                        downloadButton.style.cursor = 'pointer';
                    }, 2000);
                } catch (error) {
                    // Show error state briefly
                    downloadButton.innerHTML = ' Failed';
                    downloadButton.style.background = '#EF4444';

                    // Reset after 3 seconds
                    setTimeout(() => {
                        downloadButton.disabled = false;
                        downloadButton.innerHTML = originalStyles.innerHTML;
                        downloadButton.style.background = originalStyles.background;
                        downloadButton.style.cursor = 'pointer';
                    }, 3000);
                }
            });

            chartWrapper.appendChild(downloadButton);
        }

        // Enhanced helper to force a download of a blob directly to local system
        function forceDownloadFromBlob(blob, filename) {
            try {
                // Ensure we have a valid blob
                if (!blob || !(blob instanceof Blob)) {
                    throw new Error('Invalid blob provided');
                }

                // Create blob URL
                const url = URL.createObjectURL(blob);

                // Create download link with enhanced attributes
                const link = document.createElement('a');
                link.style.display = 'none';
                link.href = url;
                link.download = filename;
                link.target = '_self';
                
                // Add additional attributes to ensure download behavior
                link.setAttribute('download', filename);
                link.setAttribute('type', 'application/octet-stream');

                // Add to DOM temporarily
                document.body.appendChild(link);

                // Use requestAnimationFrame to ensure DOM is ready
                requestAnimationFrame(() => {
                try {
                    // Method 1: Direct click (works in most modern browsers)
                    link.click();
                        console.log('Download triggered via direct click');
                } catch (e) {
                        console.warn('Direct click failed, trying mouse event:', e);
                        try {
                    // Method 2: Dispatch mouse event (fallback for some browsers)
                    const evt = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true,
                        ctrlKey: false,
                        altKey: false,
                        shiftKey: false,
                        metaKey: false
                    });
                    link.dispatchEvent(evt);
                            console.log('Download triggered via mouse event');
                        } catch (e2) {
                            console.warn('Mouse event failed, trying manual approach:', e2);
                            // Method 3: Manual trigger for older browsers
                            if (document.createEvent) {
                                const event = document.createEvent('MouseEvents');
                                event.initEvent('click', true, true);
                                link.dispatchEvent(event);
                                console.log('Download triggered via manual event');
                            } else {
                                // Method 4: Fallback - try to open in new tab with download hint
                                console.warn('All click methods failed, trying window.open fallback');
                                const newWindow = window.open(url, '_blank');
                                if (newWindow) {
                                    newWindow.document.title = filename;
                                    // Try to trigger download via meta refresh
                                    setTimeout(() => {
                                        newWindow.document.write(`
                                            <html>
                                                <head>
                                                    <meta http-equiv="refresh" content="0; url=${url}">
                                                    <meta http-equiv="content-disposition" content="attachment; filename=${filename}">
                                                </head>
                                                <body>
                                                    <p>If download doesn't start automatically, <a href="${url}" download="${filename}">click here</a></p>
                                                </body>
                                            </html>
                                        `);
                                        newWindow.document.close();
                                    }, 100);
                                }
                            }
                        }
                    }

                    // Cleanup after a short delay to ensure download starts
                setTimeout(() => {
                        try {
                    URL.revokeObjectURL(url);
                            if (document.body.contains(link)) {
                    document.body.removeChild(link);
                            }
                        } catch (cleanupError) {
                            console.warn('Cleanup error (non-critical):', cleanupError);
                        }
                    }, 1000); // Increased delay to ensure download starts
                });

                console.log(`Chart image download initiated for: ${filename}`);
            } catch (error) {
                console.error('Error in forceDownloadFromBlob:', error);
                alert(`Failed to download the image: ${error.message}. Please try again.`);
            }
        }

        // Function to download charts using library methods
        async function downloadChart(chartType, chartId, chartInstance = null) {
            try {
                if (chartType === 'plotly') {
                    // Download Plotly chart as PNG using Plotly's toImage method
                    const wrapper = document.getElementById(chartId);
                    if (wrapper) {
                        // Prefer the inner plot div if present
                        const plotDiv = wrapper.querySelector('.js-plotly-plot') || wrapper;

                        // Use Plotly's toImage method to get high-quality PNG
                        Plotly.toImage(plotDiv, {
                            format: 'png',
                            width: 1200,
                            height: 800,
                            scale: 2  // Higher resolution for better quality
                        }).then((dataUrl) => {
                            // Convert data URL to blob
                            fetch(dataUrl)
                                .then(res => res.blob())
                                .then(blob => {
                                    const filename = `plotly-chart-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                                    forceDownloadFromBlob(blob, filename);
                                })
                                .catch(err => {
                                    console.error('Error converting Plotly chart to blob:', err);
                                    alert('Failed to download Plotly chart. Please try again.');
                                });
                        }).catch(err => {
                            console.error('Plotly toImage error:', err);
                            alert('Failed to generate Plotly chart image. Please try again.');
                        });
                    } else {
                        alert('Chart element not found.');
                    }
                } else if (chartType === 'echarts' && chartInstance) {
                    // Download ECharts chart as high-quality PNG
                    try {
                        console.log('Downloading ECharts chart with instance:', chartInstance);
                        
                        // Wait for chart to be fully rendered
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        const dataURL = chartInstance.getDataURL({
                            type: 'png',
                            pixelRatio: 3, // High resolution
                            backgroundColor: '#ffffff',
                            excludeComponents: ['toolbox', 'brush'] // Clean export
                        });
                        
                        console.log('ECharts dataURL generated, converting to blob...');
                        
                        // Convert data URL to blob for reliable download
                        const response = await fetch(dataURL);
                        const blob = await response.blob();
                        
                        // Generate descriptive filename
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                        const filename = `echarts-chart-${timestamp}.png`;
                        
                        console.log('Downloading ECharts chart as:', filename);
                        forceDownloadFromBlob(blob, filename);
                        
                    } catch (error) {
                        console.error('Error generating ECharts image:', error);
                        alert('Failed to generate chart image: ' + error.message);
                    }
                } else if (chartType === 'echarts' && !chartInstance) {
                    // Fallback for ECharts without instance - find chart by DOM
                    console.log('ECharts fallback download for chartId:', chartId);
                    const wrapper = document.getElementById(chartId);
                    
                    if (wrapper) {
                        // Try multiple selectors to find the ECharts div
                        const echartsDiv = wrapper.querySelector('div[_echarts_instance_]') || 
                                         wrapper.querySelector('.echarts-chart div') ||
                                         wrapper.querySelector('div[style*="position: relative"]');
                        
                        if (echartsDiv) {
                            const chart = echarts.getInstanceByDom(echartsDiv);
                            if (chart) {
                                try {
                                    console.log('Found ECharts instance, generating download...');
                                    
                                    // Wait for chart to be stable
                                    await new Promise(resolve => setTimeout(resolve, 300));
                                    
                                    const dataURL = chart.getDataURL({
                                        type: 'png',
                                        pixelRatio: 3,
                                        backgroundColor: '#ffffff',
                                        excludeComponents: ['toolbox', 'brush']
                                    });
                                    
                                    const response = await fetch(dataURL);
                                    const blob = await response.blob();
                                    
                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                                    const filename = `echarts-fallback-${timestamp}.png`;
                                    
                                    console.log('Fallback download initiated:', filename);
                                    forceDownloadFromBlob(blob, filename);
                                    
                                } catch (error) {
                                    console.error('Error in fallback ECharts download:', error);
                                    alert('Failed to download chart: ' + error.message);
                                }
                            } else {
                                console.error('No ECharts instance found in DOM element');
                                alert('Chart instance not found. Please try refreshing the page.');
                            }
                        } else {
                            console.error('No ECharts div found in wrapper');
                            alert('Chart element not found. Please try refreshing the page.');
                        }
                    } else {
                        console.error('Chart wrapper not found for ID:', chartId);
                        alert('Chart container not found. Please try refreshing the page.');
                    }
                } else if (chartType === 'chartjs') {
                    // Legacy Chart.js support (should not be used anymore)
                    alert('Chart.js charts are no longer supported. Please use ECharts instead.');
                } else {
                    alert('Unsupported chart type for download.');
                }
            } catch (error) {
                console.error('Error downloading chart:', error);
                alert('Error downloading chart. Please try again.');
            }
        }
        
        // Function to manually create sample charts
        function createSampleChart(type = 'pie') {
            const chartWrapper = document.createElement('div');
            chartWrapper.style.maxWidth = '100%';
            chartWrapper.style.height = '400px';
            chartWrapper.style.marginTop = '15px';
            chartWrapper.style.marginBottom = '15px';
            chartWrapper.style.border = '1px solid #e0e0e0';
            chartWrapper.style.borderRadius = '8px';
            chartWrapper.style.padding = '10px';
            
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            
            let config;
            
            if (type === 'pie') {
                config = {
                    type: 'pie',
                    data: {
                        labels: ['F2 - Applicator Problem', 'Other Faults'],
                        datasets: [{
                            data: [60, 40],
                            backgroundColor: ['#FF6384', '#36A2EB'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Fault Type Distribution'
                            }
                        }
                    }
                };
            } else if (type === 'bar') {
                config = {
                    type: 'bar',
                    data: {
                        labels: ['Conductor Show Problem', 'Excess Burr Problem', 'Other Symptoms'],
                        datasets: [{
                            label: 'Occurrence %',
                            data: [40, 30, 30],
                            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Symptom Distribution'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Percentage (%)'
                                }
                            }
                        }
                    }
                };
            }
            
            // Use ECharts instead of Chart.js
            const echartsDiv = document.createElement('div');
            echartsDiv.style.width = '100%';
            echartsDiv.style.height = '100%';
            chartWrapper.appendChild(echartsDiv);
            
            const echartsConfig = convertChartJsToECharts(config);
            
            if (typeof echarts !== 'undefined') {
                const chart = echarts.init(echartsDiv);
                const finalConfig = { ...echartsConfig };
                delete finalConfig.type;
                chart.setOption(finalConfig);
            } else {
                echartsDiv.innerHTML = '<div style="text-align: center; padding: 20px;">ECharts library not loaded</div>';
            }
            return chartWrapper;
        }
    </script>
    <!-- Gallery Backdrop -->
    <div class="gallery-backdrop" style="display: none;"></div>
    
    <!-- CGMSCL Prompt Gallery Modal -->
    <dialog id="promptsModal" class="CGMSCL-prompt-gallery-modal">
                <div class="gallery-header">
                    <h2>CGMSCL Prompt Gallery</h2>
                    <div class="header-controls">
                        <!-- Settings dropdown -->
                        <div class="settings-dropdown">
                            <button class="settings-btn" onclick="toggleSettingsDropdown()" aria-label="Settings">
                                <i class="fa fa-cog"></i>
                            </button>
                            <!-- Dropdown menu -->
                            <div class="settings-dropdown-menu" id="settingsDropdown">
                                <div class="dropdown-option" onclick="manageInternalPrompts()">
                                    <i class="fa fa-list"></i>
                                    <span>Manage Internal Prompts</span>
                                </div>
                                <div class="dropdown-option" onclick="addNewPrompt()">
                                    <i class="fa fa-plus"></i>
                                    <span>Add Prompt</span>
                                </div>
                                <div class="dropdown-option" onclick="editPrompt()">
                                    <i class="fa fa-edit"></i>
                                    <span>Edit Prompt</span>
                                </div>
                                <div class="dropdown-option" onclick="deletePrompt()">
                                    <i class="fa fa-trash"></i>
                                    <span>Delete Prompt</span>
                                </div>
                            </div>
                        </div>
                        <button id="closePromptsModal" class="close-btn" onclick="closePromptGallery()" aria-label="Close"></button>
                    </div>
                </div>

        <!-- Gallery Search Section -->
        <div class="gallery-search-section">
            <div class="search-container">
                <div class="search-input-wrapper">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" 
                           id="prompt-search-input" 
                           class="prompt-search-input" 
                           placeholder="Search prompts..." 
                           autocomplete="off"
                           onkeydown="handleSearchKeydown(event)">
                    <button class="clear-search-btn" 
                            id="clear-search-btn" 
                            onclick="clearSearch()" 
                            style="display: none;"
                            title="Clear search">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="search-results-counter" id="search-results-counter" style="display: none;"></div>
            </div>
        </div>

        <div class="prompts-grid" id="promptsGridHost">
            <!-- Prompt cards will be dynamically generated -->
        </div>
    </dialog>

    <!-- Internal Prompts Management Modal -->
    <dialog id="internalPromptsModal" class="internal-prompts-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Internal Prompts</h3>
                <button class="modal-close" onclick="closeInternalPromptsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p class="modal-info">Add up to 5 internal prompts. Click on any prompt to copy it to clipboard.</p>
                <div class="internal-prompts-list" id="internalPromptsList">
                    <!-- Internal prompts will be displayed here -->
                </div>
                <div class="add-prompt-section">
                    <input type="text" id="newInternalPrompt" placeholder="Enter new internal prompt..." maxlength="100">
                    <button onclick="addInternalPrompt()" id="addInternalPromptBtn">Add Prompt</button>
                </div>
                <div class="prompt-counter">
                    <span id="promptCounter">0/5 prompts</span>
                </div>
            </div>
        </div>
    </dialog>

    <script>
    // Quick fix for Show More/Less immediate response
    function fixShowMoreButton() {
        const modal = document.getElementById('promptsModal');
        if (!modal) return;
        
        const showMoreButton = modal.querySelector('#show-more-button');
        const additionalCategories = modal.querySelector('#additional-categories');
        
        if (!showMoreButton || !additionalCategories) return;
        
        // **KEY FIX: Initialize with explicit inline style**
        additionalCategories.style.display = 'none';
        
        // Remove any existing listeners
        const newButton = showMoreButton.cloneNode(true);
        showMoreButton.parentNode.replaceChild(newButton, showMoreButton);
        
        // Add new listener
        newButton.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('Button clicked, current display:', additionalCategories.style.display);
            
            // Check for both hidden states
            if (additionalCategories.style.display === 'none' || additionalCategories.style.display === '') {
                // Show
                additionalCategories.style.display = 'grid';
                newButton.innerHTML = '<span>Show Less Categories</span><span class="show-more-arrow"></span>';
                console.log('Showing categories');
            } else {
                // Hide
                additionalCategories.style.display = 'none';
                newButton.innerHTML = '<span>Show More Categories</span><span class="show-more-arrow"></span>';
                console.log('Hiding categories');
            }
        });
    }

    // Call when modal opens
    document.addEventListener('DOMContentLoaded', function() {
        const promptsFab = document.getElementById('prompts-fab');
        if (promptsFab) {
            promptsFab.addEventListener('click', function() {
                setTimeout(fixShowMoreButton, 150); // Small delay for content to load
            });
        }
    });
    </script>
    <script>
    // Quick fix to prevent double prompt execution
    let lastPromptTime = 0;
    const promptDebounceDelay = 1000; // 1 second debounce

    // Override the original enqueueMessage function
    const originalEnqueueMessage = window.enqueueMessage;
    window.enqueueMessage = function() {
        const currentTime = Date.now();
        if (currentTime - lastPromptTime < promptDebounceDelay) {
            console.log('Double prompt execution prevented');
            return;
        }
        lastPromptTime = currentTime;
        console.log('Executing prompt...');
        return originalEnqueueMessage.apply(this, arguments);
    };

    // Add click debouncing to modal items
    document.addEventListener('DOMContentLoaded', function() {
        const promptsFab = document.getElementById('prompts-fab');
        if (promptsFab) {
            promptsFab.addEventListener('click', function() {
                setTimeout(() => {
                    const modal = document.getElementById('promptsModal');
                    if (!modal) return;
                    
                    // Add debouncing to all dropdown items
                    const dropdownItems = modal.querySelectorAll('.dropdown-item');
                    dropdownItems.forEach(item => {
                        // Remove existing listeners
                        const newItem = item.cloneNode(true);
                        item.parentNode.replaceChild(newItem, item);
                        
                        // Add new debounced listener
                        newItem.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            const currentTime = Date.now();
                            if (currentTime - lastPromptTime < promptDebounceDelay) {
                                console.log('Item double click prevented');
                                return;
                            }
                            lastPromptTime = currentTime;
                            
                            const promptText = this.textContent.trim();
                            console.log('Setting prompt:', promptText);
                            document.getElementById('user-input').value = promptText;
                            modal.close();
                            
                            // Do not auto-send; just populate input
                            const inputEl = document.getElementById('user-input');
                            if (inputEl) {
                                const evt = new Event('input', { bubbles: true });
                                inputEl.dispatchEvent(evt);
                            }
                        });
                    });
                }, 200);
            });
        }
    });
    </script>
    <script>
    // Populate input only (no auto-send)
    function autoSendPrompt(promptText) {
        const userInput = document.getElementById('user-input');
        if (userInput) {
            userInput.value = promptText;
            const evt = new Event('input', { bubbles: true });
            userInput.dispatchEvent(evt);
        }
    }

    // Clean modal event handlers to prevent duplicates
    function cleanAndSetupModal() {
        const modal = document.getElementById('promptsModal');
        if (!modal) return;
        
        // Get all dropdown items
        const dropdownItems = modal.querySelectorAll('.dropdown-item');
        
        dropdownItems.forEach(item => {
            // **KEY FIX: Completely replace element to remove ALL existing listeners**
            const newItem = item.cloneNode(true);
            item.parentNode.replaceChild(newItem, item);
            
            // Add ONLY our fill-input listener
            newItem.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation(); // Stop ALL event propagation
                
                const promptText = this.textContent.trim();
                console.log('Insert prompt into input only:', promptText);
                
                // Close modal immediately
                modal.close();
                
                // Fill input only
                autoSendPrompt(promptText);
                
                // Prevent any further event processing
                return false;
            }, { once: true }); // Fire only once per click
        });
    }

    // Setup when DOM loads
    document.addEventListener('DOMContentLoaded', function() {
        const promptsFab = document.getElementById('prompts-fab');
        if (promptsFab) {
            promptsFab.addEventListener('click', function() {
                // Clean setup after modal content loads
                setTimeout(cleanAndSetupModal, 300);
            });
        }
    });

    // **ADDITIONAL FIX: Override any existing modal handlers to fill only**
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('dropdown-item') && 
            document.getElementById('promptsModal').open) {
            
            e.stopImmediatePropagation();
            e.preventDefault();
            
            const promptText = e.target.textContent.trim();
            document.getElementById('promptsModal').close();
            autoSendPrompt(promptText);
            
            return false;
        }
    }, true); // Use capture phase to intercept first
    </script>
    <script>
        // Settings Dropdown Functionality
        class SettingsDropdown {
            constructor() {
                this.settingsBtn = null;
                this.settingsMenu = null;
                this.isOpen = false;
                
                this.init();
            }
            
            init() {
                // Target the main settings dropdown specifically (the one with ellipsis icon, not the CGMSCL gallery one)
                this.settingsBtn = document.querySelector('.settings-btn i.fa-ellipsis-v').closest('.settings-btn');
                this.settingsMenu = document.querySelector('.settings-menu');
                
                if (this.settingsBtn && this.settingsMenu) {
                    this.bindEvents();
                }
            }
            
            bindEvents() {
                // Toggle dropdown on button click
                this.settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleDropdown();
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.settingsBtn.contains(e.target) && !this.settingsMenu.contains(e.target)) {
                        this.closeDropdown();
                    }
                });
                
                // Handle menu item clicks
                this.settingsMenu.addEventListener('click', (e) => {
                    const settingsItem = e.target.closest('.settings-item');
                    if (settingsItem) {
                        const action = settingsItem.dataset.action;
                        this.handleMenuAction(action);
                        this.closeDropdown();
                    }
                });
                
                // Keyboard navigation
                this.settingsMenu.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });
                
                // Close on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.closeDropdown();
                        this.settingsBtn.focus();
                    }
                });
            }
            
            toggleDropdown() {
                if (this.isOpen) {
                    this.closeDropdown();
                } else {
                    this.openDropdown();
                }
            }
            
            openDropdown() {
                this.settingsMenu.setAttribute('aria-hidden', 'false');
                this.settingsBtn.setAttribute('aria-expanded', 'true');
                this.isOpen = true;
                
                // Focus first menu item
                setTimeout(() => {
                    const firstItem = this.settingsMenu.querySelector('.settings-item');
                    if (firstItem) {
                        firstItem.focus();
                    }
                }, 100);
            }
            
            closeDropdown() {
                this.settingsMenu.setAttribute('aria-hidden', 'true');
                this.settingsBtn.setAttribute('aria-expanded', 'false');
                this.isOpen = false;
            }
            
            handleKeyDown(e) {
                const items = Array.from(this.settingsMenu.querySelectorAll('.settings-item'));
                const currentIndex = items.indexOf(document.activeElement);
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                        items[nextIndex].focus();
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                        items[prevIndex].focus();
                        break;
                        
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        if (document.activeElement.classList.contains('settings-item')) {
                            document.activeElement.click();
                        }
                        break;
                }
            }
            
            handleMenuAction(action) {
                switch (action) {
                    case 'add':
                        this.handleAdd();
                        break;
                    case 'edit':
                        this.handleEdit();
                        break;
                    case 'delete':
                        this.handleDelete();
                        break;
                    case 'recent':
                        this.showRecentPages();
                        break;
                    case 'about':
                        this.showAbout();
                        break;
                    case 'feedback':
                        this.showFeedback();
                        break;
                    case 'settings':
                        this.showSettings();
                        break;
                    case 'clear-cache':
                        this.clearAllCaches();
                        break;
                }
            }
            
            handleAdd() {
                // Use existing addNewPrompt function for prompt cards
                console.log('Add action triggered');
                addNewPrompt();
            }
            
            handleEdit() {
                // Use existing editPrompt function for prompt cards
                console.log('Edit action triggered');
                editPrompt();
            }
            
            handleDelete() {
                // Use existing deletePrompt function for prompt cards
                console.log('Delete action triggered');
                deletePrompt();
            }
            
            showRecentPages() {
                // Implement recent pages functionality
                console.log('Show Recent Pages');
                this.showModal('Recent Pages', 'Recent pages functionality will be implemented here.\n\nThis will show a list of recently visited pages and allow quick navigation.');
            }
            
            showAbout() {
                // Implement about functionality
                console.log('Show About');
                this.showModal('About', 'CGMSCL AI Assistant v1.0\n\nBuilt with advanced AI technology for predictive maintenance, asset management, and optimization.\n\n 2024 CGMSCL. All rights reserved.');
            }
            
            showFeedback() {
                // Implement feedback functionality
                console.log('Show Send Feedback');
                const email = 'feedback@CGMSCL.com';
                const subject = 'CGMSCL Feedback';
                const body = 'Please share your feedback about CGMSCL:\n\n';
                window.location.href = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            }
            
            showSettings() {
                // Implement settings functionality
                console.log('Show Settings');
                this.showModal('Settings', 'Settings panel will be implemented here with various configuration options:\n\n Theme preferences\n Notification settings\n Data privacy options\n Language selection');
            }
            
            clearAllCaches() {
                // Show confirmation dialog
                const confirmed = confirm('Are you sure you want to clear all cached queries and session data?\n\nThis will:\n Clear all cached responses\n Clear all conversation history\n Clear all session metadata\n\nThis action cannot be undone.');
                
                if (!confirmed) {
                    return;
                }
                
                console.log('Clearing all caches...');
                
                // Call the backend API to clear all caches
                fetch('/clear-all-caches', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        const totalCleared = data.cleared_items.total_items_cleared;
                        this.showModal('Cache Cleared Successfully', 
                            `All caches have been cleared successfully!\n\n` +
                            `Items cleared:\n` +
                            ` Response cache entries: ${data.cleared_items.response_cache_entries}\n` +
                            ` Conversation sessions: ${data.cleared_items.conversation_sessions}\n` +
                            ` Session metadata entries: ${data.cleared_items.session_metadata_entries}\n\n` +
                            `Total items cleared: ${totalCleared}\n\n` +
                            `The system is now running with a clean cache.`
                        );
                        
                        // Also clear local storage
                        localStorage.removeItem('chatHistory');
                        localStorage.removeItem('conversationId');
                        
                        console.log('All caches cleared successfully:', data);
                    } else {
                        throw new Error(data.message || 'Failed to clear caches');
                    }
                })
                .catch(error => {
                    console.error('Error clearing caches:', error);
                    this.showModal('Error', `Failed to clear caches: ${error.message}\n\nPlease try again or contact support if the problem persists.`);
                });
            }
            
            showModal(title, content) {
                // Simple modal implementation
                const modal = document.createElement('div');
                modal.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; display: flex; align-items: center; justify-content: center;">
                        <div style="background: white; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 20px 40px rgba(0,0,0,0.2);">
                            <h3 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; color: #1f2937;">${title}</h3>
                            <p style="margin: 0 0 20px 0; line-height: 1.5; white-space: pre-line; color: #374151;">${content}</p>
                            <button onclick="this.closest('div').parentElement.remove()" style="background: #1F7246
; color: white; border: none; border-radius: 6px; padding: 8px 16px; cursor: pointer; font-weight: 500;">Close</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.textContent = message;
                // Set background color based on type
                let backgroundColor = '#3b82f6'; // default blue
                if (type === 'error') backgroundColor = '#1F7246';
                else if (type === 'warning') backgroundColor = '#f59e0b';
                else if (type === 'success') backgroundColor = '#16a34a';
                
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 10001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    color: white;
                    background: ${backgroundColor};
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                `;
                
                document.body.appendChild(notification);
                
                // Fade in
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                });
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
        }

        // CopilotStyleSearchBox class for enhanced chat functionality
        class CopilotStyleSearchBox {
            constructor() {
                this.searchContainer = null;
                this.searchInput = null;
                this.micButton = null;
                this.sendButton = null;
                
                this.init();
            }
            
            init() {
                this.bindEvents();
            }
            
            bindEvents() {
                // Get elements
                this.searchContainer = document.querySelector('.chat-search-container');
                this.searchInput = document.getElementById('user-input');
                this.micButton = document.getElementById('mic-button');
                this.sendButton = document.getElementById('send-button');
                
                if (!this.searchInput || !this.micButton || !this.sendButton) {
                    console.log('Copilot search box elements not found');
                    return;
                }
                
                // Input events
                this.searchInput.addEventListener('input', (e) => {
                    this.handleInputChange(e);
                });
                
                this.searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSendMessage();
                    }
                });
                
                // Button events
                this.micButton.addEventListener('click', () => {
                    this.handleMicClick();
                });
                
                // Focus events for enhanced UX
                this.searchInput.addEventListener('focus', () => {
                    this.searchContainer.classList.add('focused');
                });
                
                this.searchInput.addEventListener('blur', () => {
                    this.searchContainer.classList.remove('focused');
                });
            }
            
            handleInputChange(e) {
                const hasText = e.target.value.trim().length > 0;
                
                // Enable/disable send button based on input content
                if (hasText) {
                    this.sendButton.removeAttribute('disabled');
                    this.sendButton.style.opacity = '1';
                } else {
                    this.sendButton.setAttribute('disabled', 'true');
                    this.sendButton.style.opacity = '0.4';
                }
            }
            
            handleMicClick() {
                // Call existing mic functionality
                console.log('Mic button clicked');
                
                // Add visual feedback
                this.micButton.style.background = '#deecf9';
                setTimeout(() => {
                    this.micButton.style.background = '';
                }, 200);
                
                // Trigger existing mic handlers
                if (typeof toggleSpeechRecognition === 'function') {
                    toggleSpeechRecognition();
                }
            }
            
            handleSendMessage() {
                const message = this.searchInput.value.trim();
                if (!message) return;
                
                console.log('Sending message:', message);
                
                // Add visual feedback
                this.sendButton.style.background = '#deecf9';
                setTimeout(() => {
                    this.sendButton.style.background = '';
                }, 200);
                
            // Do not auto-send; only set the value
            }
            
            // Public methods for external access
            focus() {
                this.searchInput.focus();
            }
            
            getValue() {
                return this.searchInput.value;
            }
            
            setValue(value) {
                this.searchInput.value = value;
                this.handleInputChange({ target: this.searchInput });
            }
            
            disable() {
                this.searchInput.disabled = true;
                this.micButton.disabled = true;
                this.sendButton.disabled = true;
            }
            
            enable() {
                this.searchInput.disabled = false;
                this.micButton.disabled = false;
                this.sendButton.disabled = false;
            }
        }

        // Initialize settings dropdown when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new SettingsDropdown();
            
            // Remove Coming Soon cards on page load
            removeComingSoonCards();
            
            // Initialize Copilot-style search box
            window.copilotSearchBox = new CopilotStyleSearchBox();
        });
    </script>

    <script>
        // Profile Manager Functionality
        class ProfileManager {
            constructor() {
                this.profileBtn = null;
                this.profileMenu = null;
                this.userEmailDisplay = null;
                this.profileEmailValue = null;
                this.currentUser = null;
                this.isOpen = false;
                
                this.init();
            }
            
            init() {
                this.profileBtn = document.getElementById('profileButton');
                this.profileMenu = document.getElementById('profileMenu');
                this.userEmailDisplay = document.getElementById('userEmailDisplay');
                this.profileEmailValue = document.getElementById('profileEmailValue');
                
                if (this.profileBtn && this.profileMenu) {
                    this.loadUserData();
                    this.bindEvents();
                }
            }
            
            async loadUserData() {
                try {
                    // Get current user data - replace with your actual auth method
                    this.currentUser = await this.getCurrentUser();
                    
                    if (this.currentUser && this.currentUser.email) {
                        this.userEmailDisplay.textContent = this.currentUser.email;
                        this.profileEmailValue.textContent = this.currentUser.email;
                    } else {
                        this.userEmailDisplay.textContent = 'Not logged in';
                        this.profileEmailValue.textContent = 'Not logged in';
                    }
                } catch (error) {
                    console.error('Error loading user data:', error);
                    this.userEmailDisplay.textContent = 'Error loading';
                }
            }
            
            async getCurrentUser() {
                // Replace this with your actual authentication method
                // Examples for different auth systems:
                
                // For Firebase Auth:
                // return firebase.auth().currentUser;
                
                // For custom JWT:
                // const token = localStorage.getItem('authToken');
                // if (token) {
                //     const response = await fetch('/api/user', {
                //         headers: { Authorization: `Bearer ${token}` }
                //     });
                //     return await response.json();
                // }
                
                // For session-based auth:
                // const response = await fetch('/api/current-user');
                // return await response.json();
                
                // Mock user for demo - replace with actual implementation
                return {
                    email: localStorage.getItem('userEmail') || 'user@example.com',
                    name: localStorage.getItem('userName') || 'User'
                };
            }
            
            bindEvents() {
                // Toggle dropdown on button click
                this.profileBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleDropdown();
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.profileBtn.contains(e.target) && !this.profileMenu.contains(e.target)) {
                        this.closeDropdown();
                    }
                });
                
                // Handle email option click
                document.getElementById('emailOption').addEventListener('click', () => {
                    this.showUserEmail();
                });
                
                // Handle logout option click
                document.getElementById('logoutOption').addEventListener('click', () => {
                    this.handleLogout();
                });
                
                // Keyboard navigation
                this.profileMenu.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });
                
                // Close on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.closeDropdown();
                        this.profileBtn.focus();
                    }
                });
            }
            
            toggleDropdown() {
                if (this.isOpen) {
                    this.closeDropdown();
                } else {
                    this.openDropdown();
                }
            }
            
            openDropdown() {
                this.profileMenu.setAttribute('aria-hidden', 'false');
                this.profileBtn.setAttribute('aria-expanded', 'true');
                this.isOpen = true;
                
                // Focus first menu item
                setTimeout(() => {
                    const firstItem = this.profileMenu.querySelector('.profile-item');
                    if (firstItem) {
                        firstItem.focus();
                    }
                }, 100);
            }
            
            closeDropdown() {
                this.profileMenu.setAttribute('aria-hidden', 'true');
                this.profileBtn.setAttribute('aria-expanded', 'false');
                this.isOpen = false;
            }
            
            handleKeyDown(e) {
                const items = Array.from(this.profileMenu.querySelectorAll('.profile-item'));
                const currentIndex = items.indexOf(document.activeElement);
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                        items[nextIndex].focus();
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                        items[prevIndex].focus();
                        break;
                        
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        if (document.activeElement.classList.contains('profile-item')) {
                            document.activeElement.click();
                        }
                        break;
                }
            }
            
            showUserEmail() {
                if (this.currentUser && this.currentUser.email) {
                    this.showNotification(`Current user: ${this.currentUser.email}`, 'info');
                } else {
                    this.showNotification('No user logged in', 'warning');
                }
                this.closeDropdown();
            }
            
            async handleLogout() {
                try {
                    // Show loading state
                    this.showNotification('Logging out...', 'info');
                    
                    // Perform logout - replace with your actual logout method
                    await this.performLogout();
                    
                    // Clear user data
                    this.currentUser = null;
                    
                    // Redirect to login page
                    window.location.href = '/login'; // Replace with your login URL
                    
                } catch (error) {
                    console.error('Logout error:', error);
                    this.showNotification('Logout failed. Please try again.', 'error');
                }
                
                this.closeDropdown();
            }
            
            async performLogout() {
                // Replace with your actual logout implementation
                
                // For Firebase Auth:
                // await firebase.auth().signOut();
                
                // For JWT/localStorage:
                localStorage.removeItem('authToken');
                localStorage.removeItem('userEmail');
                localStorage.removeItem('userName');
                
                // For session-based auth:
                // await fetch('/api/logout', { method: 'POST' });
                
                // Simulate async operation
                return new Promise(resolve => setTimeout(resolve, 500));
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.textContent = message;
                
                // Set background color based on type
                let backgroundColor = '#10b981'; // default green
                if (type === 'error') backgroundColor = '#1F7246';
                else if (type === 'warning') backgroundColor = '#f59e0b';
                
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 10001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    color: white;
                    background: ${backgroundColor};
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                `;
                
                document.body.appendChild(notification);
                
                // Fade in
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                });
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
        }

        // Initialize profile manager when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new ProfileManager();
        });

        // Internal Prompts Management
        let internalPrompts = JSON.parse(localStorage.getItem('internalPrompts') || '[]');

        function manageInternalPrompts() {
            const modal = document.getElementById('internalPromptsModal');
            modal.showModal();
            renderInternalPrompts();
            updatePromptCounter();
        }

        function closeInternalPromptsModal() {
            const modal = document.getElementById('internalPromptsModal');
            modal.close();
        }

        function renderInternalPrompts() {
            const list = document.getElementById('internalPromptsList');
            list.innerHTML = '';

            internalPrompts.forEach((prompt, index) => {
                const item = document.createElement('div');
                item.className = 'internal-prompt-item';
                item.innerHTML = `
                    <span class="internal-prompt-text" onclick="copyToClipboard('${prompt.replace(/'/g, "\\'")}')">${prompt}</span>
                    <button class="internal-prompt-delete" onclick="deleteInternalPrompt(${index})" title="Delete prompt">
                        <i class="fa fa-times"></i>
                    </button>
                `;
                list.appendChild(item);
            });
        }

        function addInternalPrompt() {
            const input = document.getElementById('newInternalPrompt');
            const text = input.value.trim();
            
            if (!text) {
                showNotification('Please enter a prompt text', 'warning');
                return;
            }

            if (internalPrompts.length >= 5) {
                showNotification('Maximum 5 prompts allowed', 'warning');
                return;
            }

            if (internalPrompts.includes(text)) {
                showNotification('This prompt already exists', 'warning');
                return;
            }

            internalPrompts.push(text);
            localStorage.setItem('internalPrompts', JSON.stringify(internalPrompts));
            
            input.value = '';
            renderInternalPrompts();
            updatePromptCounter();
            showNotification('Prompt added successfully', 'success');
        }

        function deleteInternalPrompt(index) {
            if (confirm('Are you sure you want to delete this prompt?')) {
                internalPrompts.splice(index, 1);
                localStorage.setItem('internalPrompts', JSON.stringify(internalPrompts));
                renderInternalPrompts();
                updatePromptCounter();
                showNotification('Prompt deleted successfully', 'success');
            }
        }

        function updatePromptCounter() {
            const counter = document.getElementById('promptCounter');
            const addBtn = document.getElementById('addInternalPromptBtn');
            
            counter.textContent = `${internalPrompts.length}/5 prompts`;
            addBtn.disabled = internalPrompts.length >= 5;
        }

        // Allow Enter key to add prompt
        document.addEventListener('DOMContentLoaded', function() {
            const input = document.getElementById('newInternalPrompt');
            if (input) {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addInternalPrompt();
                    }
                });
            }
        });

        // Excel Download Button functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners for Excel download buttons
            const excelDownloadButton = document.getElementById('excelDownloadButton');
            const excelDownloadButtonChat = document.getElementById('excelDownloadButtonChat');
            
            if (excelDownloadButton) {
                excelDownloadButton.addEventListener('click', async function() {
                    await downloadExcelFeedback();
                });
            }
            
            if (excelDownloadButtonChat) {
                excelDownloadButtonChat.addEventListener('click', async function() {
                    await downloadExcelFeedback();
                });
            }
        });

        // New Chat Button functionality
        document.addEventListener('DOMContentLoaded', function() {
            const newChatButton = document.getElementById('newChatButton');
            if (newChatButton) {
                newChatButton.addEventListener('click', function() {
                    // Clear the current chat interface and start fresh
                    startNewChat();
                });
            }
        });

        // Function to start a new chat session (legacy duplicate; unused)
        function startNewChatLegacy() {
            // Clear the chat history
            chatHistory = [];
            localStorage.removeItem('chatHistory');
            
            // Clear the chat area
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            
            // Reset to welcome screen
            const welcomeScreen = document.getElementById('welcome-screen');
            const chatArea = document.getElementById('chat-area');
            
            if (welcomeScreen && chatArea) {
                chatArea.style.display = 'none';
                welcomeScreen.style.display = 'flex';
            }
            
            // Clear the input field
            const userInput = document.getElementById('user-input');
            if (userInput) {
                userInput.value = '';
            }
            
            // Session management removed - no session variables to reset
            
            // Reset processing states
            isProcessingQueue = false;
            isTyping = false;
            queryQueue = [];
            
            // Reset send button state
            const sendButton = document.getElementById('send-button');
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');
            
            if (sendButton) {
                sendButton.classList.remove('processing', 'glowing');
            }
            if (sendIcon) {
                sendIcon.style.display = 'block';
            }
            if (stopIcon) {
                stopIcon.style.display = 'none';
            }
            
            // Hide floating button if visible
            toggleFloatingButton(false);
            
            console.log('New chat session started');
        }

        // Global click handler to close all dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            // Check if the clicked element is a dropdown toggle button or inside a dropdown
            const isDropdownToggle = event.target.closest('.dropdown-toggle');
            const isInsideDropdown = event.target.closest('.dropdown-content-main, .dropdown-content-extended, .card-expanded-content');
            const isInsideCard = event.target.closest('.prompt-card, .prompt-card-main, .prompt-card-extended');
            
            // If clicked outside dropdowns and not on a toggle button, close all dropdowns
            if (!isDropdownToggle && !isInsideDropdown && !isInsideCard) {
                closeAllDropdowns();
            }
        });

        // Function to hide loading screen
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen && !loadingScreen.classList.contains('fade-out')) {
                loadingScreen.classList.add('fade-out');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 300);
            }
        }

        // Hide loading screen when page is fully loaded
        window.addEventListener('load', function() {
            hideLoadingScreen();
        });

        // Hide loading screen when DOM is ready (primary method)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                // Hide after a short delay to ensure basic rendering is complete
                setTimeout(hideLoadingScreen, 500);
            });
        } else {
            // DOM is already ready, hide immediately
            setTimeout(hideLoadingScreen, 300);
        }

        // Aggressive fallback: hide after maximum 1.5 seconds regardless
        setTimeout(function() {
            hideLoadingScreen();
        }, 1500);

    </script>

    <!-- Version and Disclaimer -->
    
    <div class="ai-disclaimer" style="position: fixed; bottom: 12px; left: 12px; z-index: 9999; background: #fffbe7; border: 1px solid #ffe08a; border-radius: 8px; padding: 12px 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.07); font-size: 13px; color: #b48a00; font-weight: 500; opacity: 0.96; display: inline-block;">
        v 1.0.8 [17 NOV 25']
    </div>

</body>
</html>